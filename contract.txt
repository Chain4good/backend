// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract CharityDonation {
    struct Campaign {
        address creator;
        string title;
        address tokenAddress;
        uint256 goal;
        uint256 deadline;
        uint256 totalDonated;
        bool isClosed;
        bool isNoLimit;
        address[] donors;
    }

    struct DonorInfo {
        address donorAddress;
        uint256 totalAmount;
        uint256 donationCount;
        uint256 lastDonationTime;
    }

    mapping(uint256 => Campaign) public campaigns;
    mapping(uint256 => mapping(address => uint256)) public donations;
    mapping(uint256 => mapping(address => bool)) public hasDonated;
    mapping(uint256 => mapping(address => DonorInfo)) public donorInfo;
    uint256 public campaignCount;

    event DonationMade(uint256 campaignId, address donor, uint256 amount);
    event CampaignClosed(uint256 campaignId, bool reachedGoal);
    event FundsWithdrawn(uint256 campaignId, address creator, uint256 amount);

    function createCampaign(
        string memory _title,
        address _tokenAddress,
        uint256 _goal,
        uint256 _duration,
        bool _isNoLimit
    ) public {
        require(_goal > 0, "Goal must be greater than 0");
        require(_duration > 0, "Duration must be greater than 0");

        campaigns[campaignCount] = Campaign({
            creator: msg.sender,
            title: _title,
            tokenAddress: _tokenAddress,
            goal: _goal,
            deadline: block.timestamp + _duration,
            totalDonated: 0,
            isClosed: false,
            isNoLimit: _isNoLimit,
            donors: new address[](0)
        });
        campaignCount++;
    }

    function donate(uint256 _campaignId, uint256 _amount) public payable {
        Campaign storage campaign = campaigns[_campaignId];
        require(!campaign.isClosed, "Campaign is closed");
        require(block.timestamp < campaign.deadline, "Campaign has ended");
        require(_amount > 0, "Amount must be greater than 0");

        if (campaign.tokenAddress == address(0)) {
            require(msg.value == _amount, "Mismatch ETH amount");
        } else {
            require(msg.value == 0, "Do not send ETH");
            require(
                IERC20(campaign.tokenAddress).transferFrom(msg.sender, address(this), _amount),
                "Token transfer failed"
            );
        }

        campaign.totalDonated += _amount;
        donations[_campaignId][msg.sender] += _amount;

        DonorInfo storage donor = donorInfo[_campaignId][msg.sender];
        if (!hasDonated[_campaignId][msg.sender]) {
            donor.donorAddress = msg.sender;
            campaign.donors.push(msg.sender);
            hasDonated[_campaignId][msg.sender] = true;
        }
        donor.totalAmount += _amount;
        donor.donationCount += 1;
        donor.lastDonationTime = block.timestamp;

        emit DonationMade(_campaignId, msg.sender, _amount);

        if (!campaign.isNoLimit && campaign.totalDonated >= campaign.goal) {
            _withdrawFunds(_campaignId);
        }
    }

    function closeCampaign(uint256 _campaignId) public {
        Campaign storage campaign = campaigns[_campaignId];
        require(msg.sender == campaign.creator || block.timestamp >= campaign.deadline, 
                "Only creator can close before deadline");
        require(!campaign.isClosed, "Campaign already closed");

        campaign.isClosed = true;
        bool reachedGoal = campaign.totalDonated >= campaign.goal;
        emit CampaignClosed(_campaignId, reachedGoal);

        if (reachedGoal || campaign.isNoLimit) {
            _withdrawFunds(_campaignId);
        }
    }

    function _withdrawFunds(uint256 _campaignId) internal {
        Campaign storage campaign = campaigns[_campaignId];
        uint256 amount = campaign.totalDonated;
        
        if (amount > 0) {
            campaign.totalDonated = 0;
            if (campaign.tokenAddress == address(0)) {
                payable(campaign.creator).transfer(amount);
            } else {
                IERC20(campaign.tokenAddress).transfer(campaign.creator, amount);
            }
            emit FundsWithdrawn(_campaignId, campaign.creator, amount);
        }
    }

    function getDonors(uint256 _campaignId) public view returns (
        DonorInfo[] memory donors
    ) {
        Campaign storage campaign = campaigns[_campaignId];
        address[] memory donorAddresses = campaign.donors;
        donors = new DonorInfo[](donorAddresses.length);

        for (uint256 i = 0; i < donorAddresses.length; i++) {
            donors[i] = donorInfo[_campaignId][donorAddresses[i]];
        }
        return donors;
    }

    function getCampaignStatus(uint256 _campaignId) public view returns (
        bool isActive,
        bool isSuccessful,
        uint256 remainingTime
    ) {
        Campaign storage campaign = campaigns[_campaignId];
        isActive = !campaign.isClosed && block.timestamp < campaign.deadline;
        isSuccessful = campaign.totalDonated >= campaign.goal || campaign.isNoLimit;

        if (block.timestamp < campaign.deadline) {
            remainingTime = campaign.deadline - block.timestamp;
        } else {
            remainingTime = 0;
        }
    }

    function getDonorInfo(uint256 _campaignId, address _donor) public view returns (
        uint256 totalAmount,
        uint256 donationCount,
        uint256 lastDonationTime
    ) {
        DonorInfo storage donor = donorInfo[_campaignId][_donor];
        return (
            donor.totalAmount,
            donor.donationCount,
            donor.lastDonationTime
        );
    }
}
