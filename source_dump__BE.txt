# ==================================================
# Path: /home/tommy/Documents/charity/backend
# Detected tech: angular, docker, gitlab_ci, javascript, python, react, typescript
# ==================================================

## DIRECTORY STRUCTURE
```
backend/
├── .git/
├── .github/
├── .vscode/
├── dist/
├── node_modules/
├── prisma/
│   ├── migrations/
│   │   ├── 20250418033523_init/
│   │   │   └── migration.sql
│   │   ├── 20250523044952_change_name_fundraise/
│   │   │   └── migration.sql
│   │   ├── 20250526081123_add_table_report_and_status_campain_col/
│   │   │   └── migration.sql
│   │   ├── 20250526102518_update_name_enum/
│   │   │   └── migration.sql
│   │   ├── 20250528024446_update_goal_col/
│   │   │   └── migration.sql
│   │   ├── 20250528152051_add_new_col_campaign_model/
│   │   │   └── migration.sql
│   │   ├── 20250528152543_add_new_col_campaign_model/
│   │   │   └── migration.sql
│   │   ├── 20250530031841_add_new_col_for_donation_model/
│   │   │   └── migration.sql
│   │   ├── 20250530084947_add_comment_system/
│   │   │   └── migration.sql
│   │   ├── 20250530110832_add_refresh_tokens/
│   │   │   └── migration.sql
│   │   ├── 20250530120806_add_cover_col_user/
│   │   │   └── migration.sql
│   │   ├── 20250531085325_remove_unique_constraint_donation/
│   │   │   └── migration.sql
│   │   ├── 20250531090050_add_col_goal_eth_campaign_model/
│   │   │   └── migration.sql
│   │   ├── 20250531090754_remove_col_campaign/
│   │   │   └── migration.sql
│   │   ├── 20250531091250_update_col_total_donated/
│   │   │   └── migration.sql
│   │   ├── 20250531163344_add_notifications/
│   │   │   └── migration.sql
│   │   ├── 20250601083337_add_campaign_approval_status/
│   │   │   └── migration.sql
│   │   ├── 20250603103308_add_token_col_donation/
│   │   │   └── migration.sql
│   │   ├── 20250603122112_update_type_amount_donation/
│   │   │   └── migration.sql
│   │   ├── 20250603153326_add_post_and_topic/
│   │   │   └── migration.sql
│   │   ├── 20250605040557_add_verify_mail_system/
│   │   │   └── migration.sql
│   │   ├── 20250605074827_add_new_col_user_model/
│   │   │   └── migration.sql
│   │   ├── 20250606035831_add_badge_system/
│   │   │   └── migration.sql
│   │   ├── 20250607115215_add_progress_campaign/
│   │   │   └── migration.sql
│   │   ├── 20250611084237_add_new_col_campaign/
│   │   │   └── migration.sql
│   │   └── migration_lock.toml
│   └── schema.prisma
├── src/
│   ├── ai/
│   │   ├── dto/
│   │   │   └── analyze-campaign.dto.ts
│   │   ├── types/
│   │   │   ├── analyze-campaign.type.ts
│   │   │   ├── campaign-optimization.type.ts
│   │   │   ├── campaign-recommendations.type.ts
│   │   │   ├── thank-you-letter.type.ts
│   │   │   └── trust-analyze.type.ts
│   │   ├── ai.controller.ts
│   │   ├── ai.module.ts
│   │   └── ai.service.ts
│   ├── auth/
│   │   ├── decorators/
│   │   │   └── auth.decorators.ts
│   │   ├── dtos/
│   │   │   ├── user-login.dto.ts
│   │   │   ├── user-register.dto.ts
│   │   │   └── verify-otp.dto.ts
│   │   ├── guards/
│   │   │   ├── jwt-auth.guard.ts
│   │   │   └── local-auth.guard.ts
│   │   ├── strategies/
│   │   │   ├── jwt.strategy.ts
│   │   │   └── local.strategy.ts
│   │   ├── auth.controller.ts
│   │   ├── auth.module.ts
│   │   ├── auth.service.ts
│   │   └── refresh-token.service.ts
│   ├── badge/
│   │   ├── badge.module.ts
│   │   ├── badge.repository.ts
│   │   ├── badge.service.ts
│   │   └── user-badge.repository.ts
│   ├── campaign/
│   │   ├── dto/
│   │   │   ├── create-campaign-progress.dto.ts
│   │   │   ├── create-campaign.dto.ts
│   │   │   └── update-campaign.dto.ts
│   │   ├── entities/
│   │   │   └── campaign.entity.ts
│   │   ├── events/
│   │   │   └── campaign-created.event.ts
│   │   ├── listeners/
│   │   │   └── campaign-created.listener.ts
│   │   ├── use-cases/
│   │   │   └── create-campaign-with-images.use-case.ts
│   │   ├── campaign.controller.ts
│   │   ├── campaign.module.ts
│   │   ├── campaign.repository.ts
│   │   └── campaign.service.ts
│   ├── category/
│   │   ├── dto/
│   │   │   ├── create-category.dto.ts
│   │   │   └── update-category.dto.ts
│   │   ├── entities/
│   │   │   └── category.entity.ts
│   │   ├── category.controller.ts
│   │   ├── category.module.ts
│   │   ├── category.repository.ts
│   │   └── category.service.ts
│   ├── comment/
│   │   ├── dto/
│   │   │   └── create-comment.dto.ts
│   │   ├── comment.controller.ts
│   │   ├── comment.module.ts
│   │   ├── comment.repository.ts
│   │   ├── comment.service.ts
│   │   └── like.repository.ts
│   ├── common/
│   │   ├── filters/
│   │   │   └── all-exceptions.filter.ts
│   │   └── base.repository.ts
│   ├── config/
│   │   ├── mailer.config.ts
│   │   └── redis.config.ts
│   ├── country/
│   │   ├── dto/
│   │   │   ├── create-country.dto.ts
│   │   │   └── update-country.dto.ts
│   │   ├── entities/
│   │   │   └── country.entity.ts
│   │   ├── country.controller.ts
│   │   ├── country.module.ts
│   │   ├── country.repository.ts
│   │   └── country.service.ts
│   ├── cover/
│   │   ├── dto/
│   │   │   ├── create-cover.dto.ts
│   │   │   └── update-cover.dto.ts
│   │   ├── entities/
│   │   │   └── cover.entity.ts
│   │   ├── cover.controller.ts
│   │   ├── cover.module.ts
│   │   ├── cover.repository.ts
│   │   └── cover.service.ts
│   ├── dashboard/
│   │   ├── dashboard.controller.ts
│   │   ├── dashboard.module.ts
│   │   └── dashboard.service.ts
│   ├── donation/
│   │   ├── dto/
│   │   │   ├── create-donation.dto.ts
│   │   │   └── update-donation.dto.ts
│   │   ├── entities/
│   │   │   └── donation.entity.ts
│   │   ├── use-cases/
│   │   │   └── create-donation.use-case.ts
│   │   ├── donation.controller.ts
│   │   ├── donation.module.ts
│   │   ├── donation.repository.ts
│   │   └── donation.service.ts
│   ├── email/
│   │   └── campaign-email.service.ts
│   ├── fundraise-type/
│   │   ├── dto/
│   │   │   ├── create-fundraise-type.dto.ts
│   │   │   └── update-fundraise-type.dto.ts
│   │   ├── entities/
│   │   │   └── fundraise-type.entity.ts
│   │   ├── fundraise-type.controller.ts
│   │   ├── fundraise-type.module.ts
│   │   ├── fundraise-type.repository.ts
│   │   └── fundraise-type.service.ts
│   ├── gemini/
│   │   ├── gemini.module.ts
│   │   └── gemini.service.ts
│   ├── image/
│   │   ├── dto/
│   │   │   ├── create-image.dto.ts
│   │   │   └── update-image.dto.ts
│   │   ├── entities/
│   │   │   └── image.entity.ts
│   │   ├── image.controller.ts
│   │   ├── image.module.ts
│   │   ├── image.repository.ts
│   │   └── image.service.ts
│   ├── mailer/
│   │   ├── mailer.module.ts
│   │   └── mailer.service.ts
│   ├── notification/
│   │   ├── dto/
│   │   │   ├── create-notification.dto.ts
│   │   │   └── update-notification.dto.ts
│   │   ├── mappers/
│   │   │   └── notification.mapper.ts
│   │   ├── types/
│   │   │   └── notification.types.ts
│   │   ├── notification.controller.ts
│   │   ├── notification.gateway.ts
│   │   ├── notification.module.ts
│   │   ├── notification.repository.ts
│   │   └── notification.service.ts
│   ├── otp/
│   │   └── otp.service.ts
│   ├── post/
│   │   ├── dto/
│   │   │   ├── create-post.dto.ts
│   │   │   └── update-post.dto.ts
│   │   ├── post.controller.ts
│   │   ├── post.module.ts
│   │   ├── post.repository.ts
│   │   └── post.service.ts
│   ├── prisma/
│   │   ├── prisma.module.ts
│   │   └── prisma.service.ts
│   ├── providers/
│   ├── report/
│   │   ├── dto/
│   │   │   ├── create-report.dto.ts
│   │   │   └── update-report.dto.ts
│   │   ├── entities/
│   │   │   └── report.entity.ts
│   │   ├── report.controller.ts
│   │   ├── report.module.ts
│   │   ├── report.repository.ts
│   │   └── report.service.ts
│   ├── templates/
│   │   ├── campaign-created-admin.hbs
│   │   ├── campaign-created.hbs
│   │   ├── campaign-progress-update.hbs
│   │   └── verify-email.hbs
│   ├── topic/
│   │   ├── dto/
│   │   │   ├── create-topic.dto.ts
│   │   │   └── update-topic.dto.ts
│   │   ├── topic.controller.ts
│   │   ├── topic.module.ts
│   │   ├── topic.repository.ts
│   │   └── topic.service.ts
│   ├── upload/
│   │   ├── cloudinary.provider.ts
│   │   ├── upload.controller.ts
│   │   ├── upload.module.ts
│   │   └── upload.service.ts
│   ├── users/
│   │   ├── dto/
│   │   │   └── update-user.dto.ts
│   │   ├── user.repository.ts
│   │   ├── users.controller.ts
│   │   ├── users.module.ts
│   │   └── users.service.ts
│   ├── utils/
│   │   └── string.ts
│   ├── app.controller.spec.ts
│   ├── app.controller.ts
│   ├── app.module.ts
│   ├── app.service.ts
│   └── main.ts
├── test/
│   ├── app.e2e-spec.ts
│   └── jest-e2e.json
├── uploads/
├── .dockerignore
├── .env
├── .gitignore
├── .prettierrc
├── Dockerfile
├── README.md
├── docker-compose.yml
├── eslint.config.mjs
├── nest-cli.json
├── package-lock.json
├── package.json
├── source_dump.txt
├── tsconfig.build.json
└── tsconfig.json
```

## FILE CONTENTS

### docker-compose.yml
```yml
version: '3.8'

services:
  api:
    container_name: charity-api
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - '3000:3000'
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${DATABASE_URL}
      # Add other environment variables
    restart: always
    networks:
      - charity-network

networks:
  charity-network:
    driver: bridge

```

### eslint.config.mjs
```mjs
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'warn',
      '@typescript-eslint/no-unsafe-argument': 'warn'
    },
  },
);
```

### src/app.controller.ts
```ts
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

```

### src/app.module.ts
```ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PrismaModule } from './prisma/prisma.module';
import { UsersModule } from './users/users.module';
import { AuthModule } from './auth/auth.module';
import { CampaignModule } from './campaign/campaign.module';
import { CountryModule } from './country/country.module';
import { FundraiseTypeModule } from './fundraise-type/fundraise-type.module';
import { CoverModule } from './cover/cover.module';
import { ImageModule } from './image/image.module';
import { UploadModule } from './upload/upload.module';
import { CategoryModule } from './category/category.module';
import { MailerModule } from './mailer/mailer.module';
import { DonationModule } from './donation/donation.module';
import { CommentModule } from './comment/comment.module';
import { AiModule } from './ai/ai.module';
import { NotificationModule } from './notification/notification.module';
import { DashboardModule } from './dashboard/dashboard.module';
import { TopicModule } from './topic/topic.module';
import { PostModule } from './post/post.module';
import { GeminiModule } from './gemini/gemini.module';
import { ReportModule } from './report/report.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    PrismaModule,
    UsersModule,
    AuthModule,
    CampaignModule,
    FundraiseTypeModule,
    CoverModule,
    ImageModule,
    UploadModule,
    CategoryModule,
    CountryModule,
    MailerModule,
    DonationModule,
    CommentModule,
    AiModule,
    NotificationModule,
    DashboardModule,
    TopicModule,
    PostModule,
    GeminiModule,
    ReportModule,
    ReportModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

```

### src/app.service.ts
```ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

```

### src/app.controller.spec.ts
```ts
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});

```

### src/main.ts
```ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { AllExceptionsFilter } from './common/filters/all-exceptions.filter';
import * as cookieParser from 'cookie-parser';
import { ValidationPipe } from '@nestjs/common';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());
  app.useGlobalFilters(new AllExceptionsFilter());

  app.enableCors({
    origin: [
      'http://localhost:5173',
      'http://127.0.0.1:5173',
      'http://localhost:8080',
      'http://127.0.0.1:8080',
      'http://192.168.1.26:5173',
      'http://185.200.65.252',
      'http://chain4good.io.vn',
      'https://chain4good.io.vn',
      'https://admin.chain4good.io.vn',
      // Add your production domain when deploying
    ],
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
  });

  // eslint-disable-next-line @typescript-eslint/no-unsafe-call
  app.use(cookieParser());
  await app.listen(process.env.PORT ?? 3000, '0.0.0.0'); // Listen on all network interfaces
}
void bootstrap();

```

### src/auth/auth.controller.ts
```ts
import {
  Body,
  Controller,
  Get,
  Post,
  Res,
  UseGuards,
  Req,
  UnauthorizedException,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { GetUser } from './decorators/auth.decorators';
import { JwtAuthGuard } from './guards/jwt-auth.guard';
import { LocalAuthGuard } from './guards/local-auth.guard';
import { UserRegisterDTO } from './dtos/user-register.dto';
import { Response, Request } from 'express';
import { VerifyOTPDto } from './dtos/verify-otp.dto';
import { OTPService } from 'src/otp/otp.service';

@Controller('auth')
export class AuthController {
  constructor(
    private authService: AuthService,
    private otpService: OTPService,
  ) {}

  @UseGuards(LocalAuthGuard)
  @Post('login')
  async login(
    @GetUser() userReq: { email: string; id: number },
    @Res({ passthrough: true }) res: Response,
  ) {
    const { user, access_token, refresh_token } =
      await this.authService.login(userReq);

    // Set access token in HTTP-only cookie
    res.cookie('access_token', access_token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      path: '/',
      maxAge: 1 * 60 * 60 * 1000, // 1 hour
      // maxAge: 30 * 1000, // 30 second
    });

    res.cookie('refresh_token', refresh_token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      path: '/',
      maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
    });

    return user;
  }

  @Post('refresh')
  async refresh(
    @Req() req: Request,
    @Res({ passthrough: true }) res: Response,
  ) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
    const refreshToken = req.cookies['refresh_token'];
    if (!refreshToken) {
      throw new UnauthorizedException('Refresh token not found');
    }

    const { access_token } =
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      await this.authService.refreshAccessToken(refreshToken);

    res.cookie('access_token', access_token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      path: '/',
      maxAge: 1 * 60 * 60 * 1000, // 1 hour
    });

    return { message: 'Token refreshed successfully' };
  }

  @UseGuards(JwtAuthGuard)
  @Post('logout')
  async logout(@Req() req: Request, @Res({ passthrough: true }) res: Response) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
    const refreshToken = req.cookies['refresh_token'];
    if (refreshToken) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      await this.authService.logout(refreshToken);
    }

    res.clearCookie('access_token');
    res.clearCookie('refresh_token');

    return { message: 'Logged out successfully' };
  }

  @Post('register')
  async register(@Body() userRegisterDto: UserRegisterDTO) {
    return this.authService.register(userRegisterDto);
  }

  @Post('verify-email')
  async verifyEmail(
    @Body() verifyOTPDto: VerifyOTPDto,
    @Body('userData') userData: UserRegisterDTO,
  ) {
    return this.authService.verifyEmailAndCreateUser(verifyOTPDto, userData);
  }

  @Post('resend-otp')
  async resendOTP(@Body('email') email: string) {
    await this.otpService.generateOTP(email);
    return { message: 'OTP resent successfully' };
  }

  @UseGuards(JwtAuthGuard)
  @Get('profile')
  getProfile(@GetUser() user: { id: number; email: string }) {
    const existingUser = this.authService.getMe(user.id);
    return existingUser;
  }
}

```

### src/auth/auth.module.ts
```ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { UsersModule } from '../users/users.module';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import { RefreshTokenService } from './refresh-token.service';
import { JwtStrategy } from './strategies/jwt.strategy';
import { LocalStrategy } from './strategies/local.strategy';
import { OTPService } from 'src/otp/otp.service';
import { MailerService } from 'src/mailer/mailer.service';

@Module({
  imports: [
    UsersModule,
    PassportModule,
    JwtModule.register({
      secret: process.env.JWT_SECRET || 'secr3t',
      signOptions: { expiresIn: '1h' },
    }),
  ],
  providers: [
    AuthService,
    LocalStrategy,
    JwtStrategy,
    OTPService,
    RefreshTokenService,
    MailerService,
  ],
  controllers: [AuthController],
})
export class AuthModule {}

```

### src/auth/refresh-token.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class RefreshTokenService {
  constructor(private prisma: PrismaService) {}

  async createRefreshToken(userId: number): Promise<string> {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call
    const token = uuidv4();
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 7); // Token expires in 7 days

    await this.prisma.refreshToken.create({
      data: {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        token,
        userId,
        expiresAt,
      },
    });

    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return token;
  }

  async validateRefreshToken(token: string) {
    const refreshToken = await this.prisma.refreshToken.findUnique({
      where: { token },
      include: { user: true },
    });

    if (!refreshToken) return null;
    if (new Date() > refreshToken.expiresAt) {
      await this.prisma.refreshToken.delete({ where: { id: refreshToken.id } });
      return null;
    }

    return refreshToken.user;
  }

  async deleteRefreshToken(token: string) {
    await this.prisma.refreshToken.delete({ where: { token } });
  }
}

```

### src/auth/auth.service.ts
```ts
import {
  Injectable,
  UnauthorizedException,
  ConflictException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import * as bcrypt from 'bcrypt';
import { UsersService } from '../users/users.service';
import { UserRegisterDTO } from './dtos/user-register.dto';
import { RefreshTokenService } from './refresh-token.service';
import { VerifyOTPDto } from './dtos/verify-otp.dto';
import { OTPService } from 'src/otp/otp.service';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService,
    private otpService: OTPService,
    private refreshTokenService: RefreshTokenService,
  ) {}

  async validateUser(email: string, password: string): Promise<any> {
    const user = await this.usersService.findByEmail(email);
    if (user && (await bcrypt.compare(password, user.password))) {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const { password, ...result } = user;
      return result;
    }
    return null;
  }

  async login(user: { email: string; id: number }) {
    const payload = { email: user.email, sub: user.id };
    const accessToken = this.jwtService.sign(payload);

    const refreshToken = await this.refreshTokenService.createRefreshToken(
      user.id,
    );

    return {
      user,
      access_token: accessToken,
      refresh_token: refreshToken,
    };
  }

  async refreshAccessToken(refreshToken: string) {
    const user =
      await this.refreshTokenService.validateRefreshToken(refreshToken);
    if (!user) {
      throw new UnauthorizedException('Invalid refresh token');
    }

    const payload = { email: user.email, sub: user.id };
    const accessToken = this.jwtService.sign(payload);

    return {
      access_token: accessToken,
    };
  }

  async logout(refreshToken: string) {
    await this.refreshTokenService.deleteRefreshToken(refreshToken);
  }

  async register(data: UserRegisterDTO) {
    const existingUser = await this.usersService.findByEmail(data.email);
    if (existingUser) {
      throw new ConflictException('Email already exists');
    }

    // Generate and send OTP
    await this.otpService.generateOTP(data.email);

    // Store user data temporarily (you may want to use Redis here)
    // For now, we'll hash the password but not create the user yet
    const hashedPassword = await bcrypt.hash(data.password, 10);
    return {
      message: 'OTP sent to your email',
      data: {
        ...data,
        password: hashedPassword,
      },
    };
  }

  async verifyEmailAndCreateUser(
    verifyOTPDto: VerifyOTPDto,
    userData: UserRegisterDTO,
  ) {
    const isValid = await this.otpService.verifyOTP(
      verifyOTPDto.email,
      verifyOTPDto.code,
    );

    if (!isValid) {
      throw new UnauthorizedException('Invalid or expired OTP');
    }

    const user = await this.usersService.create({
      ...userData,
      isVerified: true,
    });

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { password: _, ...result } = user;
    return result;
  }

  async getMe(id: number) {
    const user = await this.usersService.findById(id);
    if (!user) {
      throw new Error('User not found');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { password, ...result } = user;
    return result;
  }
}

```

### src/auth/dtos/user-register.dto.ts
```ts
import {
  IsBoolean,
  IsEmail,
  IsNotEmpty,
  IsOptional,
  IsString,
} from 'class-validator';

export class UserRegisterDTO {
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @IsString()
  @IsNotEmpty()
  password: string;

  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsNotEmpty()
  address: string;

  @IsString()
  @IsOptional()
  cover?: string;

  @IsString()
  @IsOptional()
  image?: string;

  @IsString()
  @IsOptional()
  bio?: string;

  @IsBoolean()
  @IsOptional()
  isVerified?: boolean;

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;

  @IsString()
  @IsOptional()
  phoneNumber?: string;
}

```

### src/auth/dtos/verify-otp.dto.ts
```ts
import { IsEmail, IsString, IsNotEmpty } from 'class-validator';

export class VerifyOTPDto {
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @IsString()
  @IsNotEmpty()
  code: string;
}

```

### src/auth/dtos/user-login.dto.ts
```ts
import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class UserLoginDto {
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @IsString()
  @IsNotEmpty()
  password: string;
}

```

### src/auth/decorators/auth.decorators.ts
```ts
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { Request } from 'express';

export interface UserExtract {
  id: number;
  email: string;
}

export const GetUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request: Request = ctx.switchToHttp().getRequest();
    return request.user as UserExtract;
  },
);

```

### src/auth/strategies/jwt.strategy.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/require-await */
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';
import { Request } from 'express';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromExtractors([
        (request: Request) => {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          return request?.cookies?.access_token;
        },
      ]),
      ignoreExpiration: false,
      secretOrKey: process.env.JWT_SECRET || 'secr3t',
    });
  }

  async validate(payload: any) {
    return { id: payload.sub, email: payload.email };
  }
}

```

### src/auth/strategies/local.strategy.ts
```ts
import { Strategy } from 'passport-local';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { AuthService } from '../auth.service';
import { User } from '@prisma/client';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super({ usernameField: 'email' });
  }

  async validate(email: string, password: string): Promise<any> {
    const user = await this.authService.validateUser(email, password);
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }
    return user;
  }
}

```

### src/auth/guards/jwt-auth.guard.ts
```ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}

```

### src/auth/guards/local-auth.guard.ts
```ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {}

```

### src/donation/donation.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Donation, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class DonationRepo extends BaseRepository<
  Donation,
  Prisma.DonationWhereInput,
  Prisma.DonationCreateInput,
  Prisma.DonationUpdateInput,
  Prisma.DonationOrderByWithRelationInput,
  Prisma.DonationInclude
> {
  protected readonly modelName = 'Donation' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
  findAll<T extends Prisma.DonationInclude>(params: {
    where?: Prisma.DonationWhereInput;
    include?: T;
  }) {
    return this.prisma.donation.findMany({
      where: params.where,
      include: params.include,
    }) as Promise<Prisma.DonationGetPayload<{ include: T }>[]>;
  }

  async findAllByUserId(userId: number) {
    return this.prisma.donation.findMany({
      where: { userId },
      include: {
        campaign: {
          select: {
            id: true,
            title: true,
            categoryId: true,
            countryId: true,
          },
        },
      },
      orderBy: { donatedAt: 'desc' },
    });
  }
  async aggregateDonationsByUser(userId: number) {
    return this.prisma.donation.aggregate({
      _sum: { amount: true },
      where: { userId },
    });
  }
}

```

### src/donation/donation.module.ts
```ts
import { Module, forwardRef } from '@nestjs/common';
import { CampaignModule } from '../campaign/campaign.module';
import { DonationRepo } from './donation.repository';
import { DonationService } from './donation.service';
import { DonationController } from './donation.controller';
import { CreateDonationUseCase } from './use-cases/create-donation.use-case';
import { UsersModule } from '../users/users.module';
import { NotificationModule } from '../notification/notification.module';
import { BadgeModule } from '../badge/badge.module';

@Module({
  imports: [
    forwardRef(() => CampaignModule),
    UsersModule,
    NotificationModule,
    BadgeModule,
  ],
  controllers: [DonationController],
  providers: [DonationService, DonationRepo, CreateDonationUseCase],
  exports: [DonationService],
})
export class DonationModule {}

```

### src/donation/donation.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
} from '@nestjs/common';
import { DonationService } from './donation.service';
import { CreateDonationDto } from './dto/create-donation.dto';
import { UpdateDonationDto } from './dto/update-donation.dto';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { GetUser, UserExtract } from 'src/auth/decorators/auth.decorators';

@Controller('donations')
export class DonationController {
  constructor(private readonly donationService: DonationService) {}

  @Post()
  @UseGuards(JwtAuthGuard)
  create(
    @Body() createDonationDto: CreateDonationDto,
    @GetUser() user: UserExtract,
  ) {
    return this.donationService.create({
      ...createDonationDto,
      userId: user.id,
    });
  }

  @Get()
  findAll() {
    return this.donationService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.donationService.findOne(+id);
  }

  @Patch(':id')
  update(
    @Param('id') id: string,
    @Body() updateDonationDto: UpdateDonationDto,
  ) {
    return this.donationService.update(+id, updateDonationDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.donationService.remove(+id);
  }
}

```

### src/donation/donation.service.ts
```ts
import { Inject, Injectable, forwardRef } from '@nestjs/common';
import { Prisma } from '@prisma/client';
import { BadgeService } from 'src/badge/badge.service';
import { CampaignService } from 'src/campaign/campaign.service';
import { UsersService } from 'src/users/users.service';
import { DonationRepo } from './donation.repository';
import { CreateDonationDto } from './dto/create-donation.dto';
import { UpdateDonationDto } from './dto/update-donation.dto';
import { CreateDonationUseCase } from './use-cases/create-donation.use-case';

type DonationWithUser = Prisma.DonationGetPayload<{
  include: {
    user: {
      select: {
        id: true;
        name: true;
        email: true;
      };
    };
  };
}>;

@Injectable()
export class DonationService {
  constructor(
    private readonly donationRepo: DonationRepo,
    private readonly createDonationUseCase: CreateDonationUseCase,
    @Inject(forwardRef(() => CampaignService))
    private readonly campaignService: CampaignService,
    private readonly userService: UsersService,
    private readonly badgeService: BadgeService,
  ) {}

  async create(createDonationDto: CreateDonationDto & { userId: number }) {
    const donation =
      await this.createDonationUseCase.execute(createDonationDto);
    // const campaign = await this.campaignService.findOne(
    //   createDonationDto.campaignId,
    // );
    // const ethPrice = await this.campaignService.getEthPrice();
    // const totalDonated = await this.donationRepo.aggregateDonationsByUser(
    //   createDonationDto.userId,
    // );
    // const amount: any = totalDonated._sum.amount ?? 0;
    // if (amount * ethPrice >= 1000000) {
    //   await this.badgeService.awardBadgeToUser(createDonationDto.userId, 1);
    // }

    // if (!campaign) throw new Error('Campaign not found');
    // const user = await this.userService.findById(createDonationDto.userId);
    // if (!user) throw new Error('User not found');
    return donation;
  }

  findAll() {
    return this.donationRepo.findAll({});
  }

  findOne(id: number) {
    return this.donationRepo.findOne(id);
  }

  update(id: number, updateDonationDto: UpdateDonationDto) {
    return this.donationRepo.update(id, updateDonationDto);
  }

  remove(id: number) {
    return this.donationRepo.delete(id);
  }

  async findAllUserDonationByCampaignId(
    campaignId: number,
  ): Promise<DonationWithUser[]> {
    return this.donationRepo.findAll({
      where: {
        campaignId,
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    });
  }

  async findAllByUserId(userId: number) {
    return this.donationRepo.findAllByUserId(userId);
  }
}

```

### src/donation/entities/donation.entity.ts
```ts
export class Donation {}

```

### src/donation/dto/update-donation.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateDonationDto } from './create-donation.dto';

export class UpdateDonationDto extends PartialType(CreateDonationDto) {}

```

### src/donation/dto/create-donation.dto.ts
```ts
import {
  IsInt,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
} from 'class-validator';

export class CreateDonationDto {
  @IsNumber()
  @IsNotEmpty()
  amount: number;

  @IsInt()
  @IsNotEmpty()
  campaignId: number;

  @IsInt()
  @IsOptional()
  onChainDonatedId?: number;

  @IsString()
  @IsOptional()
  txHash?: string;

  @IsString()
  @IsOptional()
  token?: string;

  @IsString()
  @IsOptional()
  address?: string;
}

```

### src/donation/use-cases/create-donation.use-case.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-argument */
import {
  Injectable,
  Inject,
  forwardRef,
  ConflictException,
} from '@nestjs/common';
import { DonationRepo } from '../donation.repository';
import { CampaignService } from '../../campaign/campaign.service';
import { CreateDonationDto } from '../dto/create-donation.dto';
import { Prisma } from '@prisma/client';

@Injectable()
export class CreateDonationUseCase {
  constructor(
    private readonly donationRepo: DonationRepo,
    @Inject(forwardRef(() => CampaignService))
    private readonly campaignService: CampaignService,
  ) {}

  async execute(createDonationDto: CreateDonationDto & { userId: number }) {
    const { userId, campaignId, ...rest } = createDonationDto;

    const donation = await this.donationRepo.create({
      ...rest,
      user: {
        connect: { id: userId },
      },
      campaign: {
        connect: { id: campaignId },
      },
    });

    await this.campaignService.update(campaignId, {
      totalDonated: {
        increment: rest.amount,
      },
    } as any);

    return donation;
  }
}

```

### src/comment/comment.module.ts
```ts
import { Module } from '@nestjs/common';
import { CommentService } from './comment.service';
import { CommentController } from './comment.controller';
import { CommentRepo } from './comment.repository';
import { LikeRepo } from './like.repository';
import { CampaignModule } from 'src/campaign/campaign.module';
import { NotificationModule } from 'src/notification/notification.module';
import { UsersModule } from 'src/users/users.module';

@Module({
  imports: [CampaignModule, NotificationModule, UsersModule],
  controllers: [CommentController],
  providers: [CommentService, CommentRepo, LikeRepo],
})
export class CommentModule {}

```

### src/comment/comment.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Comment, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class CommentRepo extends BaseRepository<
  Comment,
  Prisma.CommentWhereInput,
  Prisma.CommentCreateInput,
  Prisma.CommentUpdateInput,
  Prisma.CommentOrderByWithRelationInput,
  Prisma.CommentInclude
> {
  protected readonly modelName = 'Comment' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/comment/like.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Like, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class LikeRepo extends BaseRepository<
  Like,
  Prisma.LikeWhereInput,
  Prisma.LikeCreateInput,
  Prisma.LikeUpdateInput,
  Prisma.LikeOrderByWithRelationInput,
  Prisma.LikeInclude
> {
  protected readonly modelName = 'Like' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/comment/comment.controller.ts
```ts
import {
  Body,
  Controller,
  Get,
  Param,
  ParseIntPipe,
  Post,
  UseGuards,
} from '@nestjs/common';
import { CommentService } from './comment.service';
import { CreateCommentDto } from './dto/create-comment.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { GetUser } from '../auth/decorators/auth.decorators';

@Controller('comments')
export class CommentController {
  constructor(private readonly commentService: CommentService) {}

  @UseGuards(JwtAuthGuard)
  @Post()
  create(
    @Body() createCommentDto: CreateCommentDto,
    @GetUser() user: { id: number },
  ) {
    return this.commentService.create({
      ...createCommentDto,
      userId: user.id,
    });
  }

  @Get('campaign/:campaignId')
  findByCampaign(@Param('campaignId', ParseIntPipe) campaignId: number) {
    return this.commentService.findByCampaign(campaignId);
  }

  @UseGuards(JwtAuthGuard)
  @Post(':id/like')
  async toggleLike(
    @Param('id', ParseIntPipe) id: number,
    @GetUser() user: { id: number },
  ) {
    return await this.commentService.toggleLike(id, user.id);
  }
}

```

### src/comment/comment.service.ts
```ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { CampaignService } from 'src/campaign/campaign.service';
import { NotificationService } from 'src/notification/notification.service';
import { NotificationType } from 'src/notification/types/notification.types';
import { CommentRepo } from './comment.repository';
import { LikeRepo } from './like.repository';
import { CreateCommentDto } from './dto/create-comment.dto';
import { UsersService } from 'src/users/users.service';

@Injectable()
export class CommentService {
  constructor(
    private readonly commentRepo: CommentRepo,
    private readonly likeRepo: LikeRepo,
    private readonly notificationService: NotificationService,
    private readonly campaignService: CampaignService,
    private readonly userService: UsersService,
  ) {}

  async create(createCommentDto: CreateCommentDto & { userId: number }) {
    const { userId, campaignId, parentId, ...rest } = createCommentDto;

    if (parentId) {
      const parentComment = await this.commentRepo.findOne(parentId);
      if (!parentComment) {
        throw new NotFoundException('Parent comment not found');
      }
    }

    const comment = await this.commentRepo.create({
      ...rest,
      user: { connect: { id: userId } },
      campaign: { connect: { id: campaignId } },
      ...(parentId && { parent: { connect: { id: parentId } } }),
    });

    const campaign = await this.campaignService.findOne(campaignId);
    if (!campaign) throw new Error('Campaign not found');

    if (parentId) {
      const parentComment = await this.commentRepo.findOne(parentId, {
        user: true,
      });
      if (!parentComment) {
        throw new NotFoundException('Parent comment not found');
      }
      const user = await this.userService.findById(parentComment?.userId);
      if (!user) throw new Error('User not found');
      if (parentComment && parentComment.userId !== userId) {
        await this.notificationService.createAndSendNotification({
          userId: parentComment.userId,
          type: NotificationType.COMMENT_REPLY,
          content: `<p><strong>${user.name}</strong> đã trả lời bình luận của bạn</p>`,
          metadata: {
            campaignTitle: campaign.title,
            commentId: comment.id,
            campaignId,
            parentCommentId: parentId,
            replierName: comment.userId,
          },
        });
      }
    } else {
      if (campaign.userId !== userId) {
        await this.notificationService.createAndSendNotification({
          userId: campaign.userId,
          type: NotificationType.COMMENT,
          content: 'Có bình luận mới trong chiến dịch của bạn',
          metadata: {
            campaignTitle: campaign.title,
            commentId: comment.id,
            campaignId,
            commenterName: comment.userId,
          },
        });
      }
    }

    return comment;
  }

  async findByCampaign(campaignId: number) {
    return this.commentRepo.findBy(
      { campaignId },
      {
        user: {
          select: {
            id: true,
            name: true,
            image: true,
          },
        },
        replies: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                image: true,
              },
            },
            Like: {
              select: {
                userId: true,
              },
            },
            _count: {
              select: {
                Like: true,
              },
            },
          },
        },
        Like: {
          select: {
            userId: true,
          },
        },
        _count: {
          select: {
            Like: true,
          },
        },
      },
    );
  }

  async toggleLike(commentId: number, userId: number) {
    const existingLike = await this.likeRepo.findOneBy({
      userId,
      commentId,
    });

    if (existingLike) {
      await this.likeRepo.delete(existingLike.id);
      return { liked: false };
    }

    await this.likeRepo.create({
      user: { connect: { id: userId } },
      comment: { connect: { id: commentId } },
    });

    return { liked: true };
  }
}

```

### src/comment/dto/create-comment.dto.ts
```ts
import { IsNotEmpty, IsNumber, IsOptional, IsString } from 'class-validator';

export class CreateCommentDto {
  @IsString()
  @IsNotEmpty()
  content: string;

  @IsNumber()
  @IsNotEmpty()
  campaignId: number;

  @IsNumber()
  @IsOptional()
  parentId?: number;
}

```

### src/email/campaign-email.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { MailerService } from '@nestjs-modules/mailer';

@Injectable()
export class CampaignEmailService {
  constructor(private readonly mailerService: MailerService) {}

  async sendCampaignApprovalEmail(userEmail: string, campaignName: string) {
    await this.mailerService.sendMail({
      to: userEmail,
      subject: 'Campaign Approved',
      template: 'campaign-approval',
      context: {
        campaignName,
        status: 'approved',
      },
    });
  }

  async sendCampaignRejectionEmail(
    userEmail: string,
    campaignName: string,
    reason?: string,
  ) {
    await this.mailerService.sendMail({
      to: userEmail,
      subject: 'Campaign Rejected',
      template: 'campaign-rejection',
      context: {
        campaignName,
        status: 'rejected',
        reason: reason || 'No specific reason provided',
      },
    });
  }
}

```

### src/notification/notification.controller.ts
```ts
import {
  Body,
  Controller,
  Get,
  Param,
  ParseIntPipe,
  Patch,
  Post,
  Query,
  UseGuards,
} from '@nestjs/common';
import { GetUser, UserExtract } from '../auth/decorators/auth.decorators';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { NotificationService } from './notification.service';
import {
  NotificationEntity,
  NotificationResponse,
} from './types/notification.types';
import { CreateNotificationDto } from './dto/create-notification.dto';

@Controller('notifications')
@UseGuards(JwtAuthGuard)
export class NotificationController {
  constructor(private readonly notificationService: NotificationService) {}
  @Post('')
  create(@Body() createNotificationDto: CreateNotificationDto) {
    return this.notificationService.createAndSendNotification(
      createNotificationDto,
    );
  }
  @Get()
  async getUserNotifications(
    @GetUser() user: UserExtract,
    @Query('page') page: number = 1,
    @Query('limit') limit: number = 10,
  ): Promise<NotificationResponse> {
    return this.notificationService.getUserNotifications(user.id, page, limit);
  }

  @Patch(':id/read')
  async markAsRead(
    @Param('id', ParseIntPipe) id: number,
  ): Promise<NotificationEntity> {
    return this.notificationService.markAsRead(id);
  }

  @Patch('mark-all-read')
  async markAllAsRead(@GetUser() user: UserExtract) {
    return this.notificationService.markAllAsRead(user.id);
  }

  @Get('unread-count')
  async getUnreadCount(@GetUser() user: UserExtract) {
    return this.notificationService.getUnreadCount(user.id);
  }
}

```

### src/notification/notification.gateway.ts
```ts
import {
  WebSocketGateway,
  WebSocketServer,
  OnGatewayConnection,
  OnGatewayDisconnect,
  SubscribeMessage,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Injectable } from '@nestjs/common';
import { NotificationEntity } from './types/notification.types';

@Injectable()
@WebSocketGateway({
  cors: {
    origin: '*',
  },
})
export class NotificationGateway
  implements OnGatewayConnection, OnGatewayDisconnect
{
  @WebSocketServer()
  server: Server;

  private userSockets: Map<number, string[]> = new Map();

  handleConnection(client: Socket): void {
    console.log(`Client connected: ${client.id}`);
  }

  @SubscribeMessage('join')
  handleJoinRoom(
    client: Socket,
    userId: number,
  ): { status: string; message: string } {
    this.handleUserConnection(userId, client.id);
    return { status: 'ok', message: 'Joined successfully' };
  }

  handleDisconnect(client: Socket): void {
    this.removeSocket(client.id);
  }

  private removeSocket(socketId: string): void {
    this.userSockets.forEach((sockets, userId) => {
      const index = sockets.indexOf(socketId);
      if (index !== -1) {
        sockets.splice(index, 1);
        if (sockets.length === 0) {
          this.userSockets.delete(userId);
        }
      }
    });
  }

  handleUserConnection(userId: number, socketId: string): void {
    if (!this.userSockets.has(userId)) {
      this.userSockets.set(userId, []);
    }
    const sockets = this.userSockets.get(userId);
    if (sockets && !sockets.includes(socketId)) {
      sockets.push(socketId);
    }
  }

  sendNotificationToUser(
    userId: number,
    notification: NotificationEntity,
  ): void {
    const userSocketIds = this.userSockets.get(userId);
    if (userSocketIds?.length) {
      userSocketIds.forEach((socketId) => {
        this.server.to(socketId).emit('notification', notification);
      });
    }
  }
}

```

### src/notification/notification.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Notification, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class NotificationRepository extends BaseRepository<
  Notification,
  Prisma.NotificationWhereInput,
  Prisma.NotificationCreateInput,
  Prisma.NotificationUpdateInput,
  Prisma.NotificationOrderByWithRelationInput,
  Prisma.NotificationInclude
> {
  protected readonly modelName = 'Notification' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/notification/notification.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { NotificationRepository } from './notification.repository';
import { NotificationMapper } from './mappers/notification.mapper';
import { NotificationGateway } from './notification.gateway';
import { CreateNotificationDto } from './dto/create-notification.dto';
import {
  NotificationResponse,
  NotificationEntity,
} from './types/notification.types';
import { Prisma } from '@prisma/client';

@Injectable()
export class NotificationService {
  constructor(
    private readonly notificationRepo: NotificationRepository,
    private readonly notificationGateway: NotificationGateway,
  ) {}

  async createAndSendNotification(
    createNotificationDto: CreateNotificationDto,
  ): Promise<NotificationEntity> {
    const notification = await this.notificationRepo.create({
      user: {
        connect: {
          id: createNotificationDto.userId,
        },
      },
      type: createNotificationDto.type,
      content: createNotificationDto.content,
      metadata: createNotificationDto.metadata ?? Prisma.DbNull,
      isRead: false,
    });

    const notificationEntity = NotificationMapper.toEntity(notification);

    this.notificationGateway.sendNotificationToUser(
      createNotificationDto.userId,
      notificationEntity,
    );

    return notificationEntity;
  }

  async getUserNotifications(
    userId: number,
    page: number,
    limit: number,
  ): Promise<NotificationResponse> {
    const result = await this.notificationRepo.paginate(page, limit, {
      where: { userId },
      orderBy: { createdAt: 'desc' },
    });

    return {
      data: NotificationMapper.toEntities(result.data),
      meta: result.meta,
    };
  }
  async markAsRead(id: number): Promise<NotificationEntity> {
    const updatedNotification = await this.notificationRepo.update(id, {
      isRead: true,
    });
    return NotificationMapper.toEntity(updatedNotification);
  }

  async markAllAsRead(userId: number) {
    return this.notificationRepo.updateMany({ userId }, { isRead: true });
  }

  async getUnreadCount(userId: number): Promise<number> {
    return this.notificationRepo.count({
      userId,
      isRead: false,
    });
  }
}

```

### src/notification/notification.module.ts
```ts
import { Module } from '@nestjs/common';
import { NotificationService } from './notification.service';
import { NotificationController } from './notification.controller';
import { NotificationRepository } from './notification.repository';
import { NotificationGateway } from './notification.gateway';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [NotificationController],
  providers: [NotificationService, NotificationRepository, NotificationGateway],
  exports: [NotificationService],
})
export class NotificationModule {}

```

### src/notification/types/notification.types.ts
```ts
export enum NotificationType {
  DONATION = 'DONATION',
  COMMENT_REPLY = 'COMMENT_REPLY',
  COMMENT = 'COMMENT',
  CAMPAIGN_UPDATE = 'CAMPAIGN_UPDATE',
  CAMPAIGN_STATUS = 'CAMPAIGN_STATUS',
}

export interface NotificationMetadata {
  campaignId?: number;
  donationId?: number;
  commentId?: number;
  amount?: number;
  donorName?: string;
  replierName?: string;
  status?: string;
  [key: string]: any;
}

export interface NotificationEntity {
  id: number;
  type: NotificationType;
  content: string;
  metadata: NotificationMetadata | null;
  isRead: boolean;
  createdAt: Date;
  userId: number;
}

export type NotificationResponse = {
  data: NotificationEntity[];
  meta: {
    total: number;
    page: number;
    limit: number;
  };
};

```

### src/notification/dto/update-notification.dto.ts
```ts
export class UpdateNotificationDto {}

```

### src/notification/dto/create-notification.dto.ts
```ts
import {
  IsNotEmpty,
  IsNumber,
  IsString,
  IsEnum,
  IsObject,
  IsOptional,
} from 'class-validator';
import { NotificationType } from '../types/notification.types';

export class CreateNotificationDto {
  @IsNumber()
  @IsNotEmpty()
  userId: number;

  @IsEnum(NotificationType)
  @IsNotEmpty()
  type: NotificationType;

  @IsString()
  @IsNotEmpty()
  content: string;

  @IsObject()
  @IsOptional()
  metadata?: Record<string, any>;
}

```

### src/notification/mappers/notification.mapper.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { Notification } from '@prisma/client';
import {
  NotificationEntity,
  NotificationMetadata,
  NotificationType,
} from '../types/notification.types';

export class NotificationMapper {
  static toEntity(notification: Notification): NotificationEntity {
    return {
      id: notification.id,
      type: notification.type as NotificationType,
      content: notification.content,
      metadata: notification.metadata as NotificationMetadata | null,
      isRead: notification.isRead,
      createdAt: notification.createdAt,
      userId: notification.userId,
    };
  }

  static toEntities(notifications: Notification[]): NotificationEntity[] {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    return notifications.map(this.toEntity);
  }
}

```

### src/cover/cover.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { CoverService } from './cover.service';
import { CreateCoverDto } from './dto/create-cover.dto';
import { UpdateCoverDto } from './dto/update-cover.dto';

@Controller('covers')
export class CoverController {
  constructor(private readonly coverService: CoverService) {}

  @Post()
  create(@Body() createCoverDto: CreateCoverDto) {
    return this.coverService.create(createCoverDto);
  }

  @Get()
  findAll() {
    return this.coverService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.coverService.findOne(+id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCoverDto: UpdateCoverDto) {
    return this.coverService.update(+id, updateCoverDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.coverService.remove(+id);
  }
}

```

### src/cover/cover.module.ts
```ts
import { Module } from '@nestjs/common';
import { CoverService } from './cover.service';
import { CoverController } from './cover.controller';
import { CoverRepo } from './cover.repository';

@Module({
  controllers: [CoverController],
  providers: [CoverService, CoverRepo],
})
export class CoverModule {}

```

### src/cover/cover.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { CreateCoverDto } from './dto/create-cover.dto';
import { UpdateCoverDto } from './dto/update-cover.dto';
import { CoverRepo } from './cover.repository';

@Injectable()
export class CoverService {
  constructor(private readonly coverRepo: CoverRepo) {}
  create(createCoverDto: CreateCoverDto) {
    return this.coverRepo.create(createCoverDto);
  }

  findAll() {
    return this.coverRepo.findAll();
  }

  findOne(id: number) {
    return this.coverRepo.findOne(id);
  }

  update(id: number, updateCoverDto: UpdateCoverDto) {
    return this.coverRepo.update(id, updateCoverDto);
  }

  remove(id: number) {
    return this.coverRepo.delete(id);
  }
}

```

### src/cover/cover.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Cover, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class CoverRepo extends BaseRepository<
  Cover,
  Prisma.CoverWhereInput,
  Prisma.CoverCreateInput,
  Prisma.CoverUpdateInput,
  Prisma.CoverOrderByWithRelationInput,
  Prisma.CoverInclude
> {
  protected readonly modelName = 'Cover' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/cover/entities/cover.entity.ts
```ts
export class Cover {}

```

### src/cover/dto/create-cover.dto.ts
```ts
import { IsEnum, IsNotEmpty, IsString } from 'class-validator';
import { ImageType } from '@prisma/client';

export class CreateCoverDto {
  @IsNotEmpty()
  @IsString()
  url: string;

  @IsEnum(ImageType)
  type?: ImageType;
}

```

### src/cover/dto/update-cover.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateCoverDto } from './create-cover.dto';

export class UpdateCoverDto extends PartialType(CreateCoverDto) {}

```

### src/topic/topic.module.ts
```ts
import { Module } from '@nestjs/common';
import { TopicController } from './topic.controller';
import { TopicService } from './topic.service';
import { TopicRepository } from './topic.repository';

@Module({
  controllers: [TopicController],
  providers: [TopicService, TopicRepository],
  exports: [TopicService],
})
export class TopicModule {}

```

### src/topic/topic.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { TopicRepository } from './topic.repository';
import { CreateTopicDto } from './dto/create-topic.dto';
import { UpdateTopicDto } from './dto/update-topic.dto';

@Injectable()
export class TopicService {
  constructor(private readonly topicRepo: TopicRepository) {}

  create(createTopicDto: CreateTopicDto) {
    return this.topicRepo.create(createTopicDto);
  }

  findAll() {
    return this.topicRepo.findAll({
      include: {
        _count: {
          select: {
            posts: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });
  }

  findOne(id: number) {
    return this.topicRepo.findOne(id, {
      posts: {
        where: {
          published: true,
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              image: true,
            },
          },
        },
        orderBy: {
          createdAt: 'desc',
        },
      },
      _count: {
        select: {
          posts: true,
        },
      },
    });
  }

  update(id: number, updateTopicDto: UpdateTopicDto) {
    return this.topicRepo.update(id, updateTopicDto);
  }

  remove(id: number) {
    return this.topicRepo.delete(id);
  }

  async findPopularTopics(limit: number = 5) {
    return this.topicRepo.paginate(1, limit, {
      include: {
        _count: {
          select: {
            posts: true,
          },
        },
      },
      orderBy: {
        posts: {
          _count: 'desc',
        },
      },
    });
  }

  async searchTopics(search: string) {
    return this.topicRepo.findBy({
      OR: [
        {
          name: {
            contains: search,
            mode: 'insensitive',
          },
        },
        {
          description: {
            contains: search,
            mode: 'insensitive',
          },
        },
      ],
    });
  }
}

```

### src/topic/topic.controller.ts
```ts
import {
  Body,
  Controller,
  Delete,
  Get,
  Param,
  Patch,
  Post,
  UseGuards,
} from '@nestjs/common';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { CreateTopicDto } from './dto/create-topic.dto';
import { TopicService } from './topic.service';
import { UpdateTopicDto } from './dto/update-topic.dto';

@Controller('topics')
export class TopicController {
  constructor(private readonly topicService: TopicService) {}

  @Post()
  @UseGuards(JwtAuthGuard)
  create(@Body() createTopicDto: CreateTopicDto) {
    return this.topicService.create(createTopicDto);
  }

  @Get()
  findAll() {
    return this.topicService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.topicService.findOne(+id);
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard)
  update(@Param('id') id: string, @Body() updateTopicDto: UpdateTopicDto) {
    return this.topicService.update(+id, updateTopicDto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  remove(@Param('id') id: string) {
    return this.topicService.remove(+id);
  }
}

```

### src/topic/topic.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from '../common/base.repository';
import { Topic, Prisma } from '@prisma/client';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class TopicRepository extends BaseRepository<
  Topic,
  Prisma.TopicWhereInput,
  Prisma.TopicCreateInput,
  Prisma.TopicUpdateInput,
  Prisma.TopicOrderByWithRelationInput,
  Prisma.TopicInclude
> {
  protected readonly modelName = 'Topic' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/topic/dto/update-topic.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateTopicDto } from './create-topic.dto';

export class UpdateTopicDto extends PartialType(CreateTopicDto) {}

```

### src/topic/dto/create-topic.dto.ts
```ts
import { IsNotEmpty, IsOptional, IsString } from 'class-validator';

export class CreateTopicDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsString()
  @IsOptional()
  icon?: string;
}

```

### src/config/redis.config.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { CacheModule } from '@nestjs/cache-manager';
import { Global, Module, OnModuleInit } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import * as redisStore from 'cache-manager-redis-store';
import { Cache } from 'cache-manager';
import { Inject } from '@nestjs/common';
import { CACHE_MANAGER } from '@nestjs/cache-manager';

@Global()
@Module({
  imports: [
    CacheModule.registerAsync({
      imports: [ConfigModule],
      // eslint-disable-next-line @typescript-eslint/require-await
      useFactory: async (configService: ConfigService) => ({
        store: redisStore,
        host: configService.get('REDIS_HOST'),
        port: configService.get('REDIS_PORT'),
        password: configService.get('REDIS_PASSWORD'),
        ttl: configService.get('REDIS_TTL'),
        max: 100,
        isGlobal: true,
      }),
      inject: [ConfigService],
    }),
  ],
  exports: [CacheModule],
})
export class RedisCacheModule implements OnModuleInit {
  constructor(
    @Inject(CACHE_MANAGER) private cacheManager: Cache,
    private configService: ConfigService,
  ) {}

  async onModuleInit() {
    try {
      // Test connection with detailed monitoring
      const testKey = 'test-connection';
      const startTime = Date.now();

      // Test write operation
      console.log('Testing Redis write operation...');
      await this.cacheManager.set(
        testKey,
        { test: true, timestamp: startTime },
        60,
      );

      // Test read operation
      console.log('Testing Redis read operation...');
      const testValue = await this.cacheManager.get(testKey);
      const latency = Date.now() - startTime;

      // Test delete operation
      console.log('Testing Redis delete operation...');
      await this.cacheManager.del(testKey);

      // Log detailed connection status
      console.log('Redis Connection Status:', {
        success: (testValue as { test: boolean })?.test === true,
        host: this.configService.get('REDIS_HOST'),
        port: this.configService.get('REDIS_PORT'),
        latency: `${latency}ms`,
        ttl: this.configService.get('REDIS_TTL'),
        maxConnections: 100,
        operations: {
          write: 'OK',
          read: !!testValue,
          delete: 'OK',
        },
        connectionDetails: {
          secured: !!this.configService.get('REDIS_PASSWORD'),
          globalCache: true,
          defaultTTL: this.configService.get('REDIS_TTL'),
        },
      });
    } catch (error) {
      console.error('Redis Connection Failed:', {
        error: error.message,
        host: this.configService.get('REDIS_HOST'),
        port: this.configService.get('REDIS_PORT'),
        timestamp: new Date().toISOString(),
        details: {
          name: error.name,
          code: error.code,
          stack: error.stack,
        },
      });
      throw error; // Prevent app start on Redis connection failure
    }
  }
}

```

### src/config/mailer.config.ts
```ts
import { MailerOptions } from '@nestjs-modules/mailer';
import { HandlebarsAdapter } from '@nestjs-modules/mailer/dist/adapters/handlebars.adapter';
import { join } from 'path';

export const mailerConfig: MailerOptions = {
  transport: {
    host: process.env.MAIL_HOST,
    port: Number(process.env.MAIL_PORT),
    secure: false, // Set to false for TLS
    requireTLS: true, // Require TLS
    auth: {
      user: process.env.MAIL_USER,
      pass: process.env.MAIL_PASSWORD,
    },
    tls: {
      ciphers: 'SSLv3',
      rejectUnauthorized: false,
    },
  },
  defaults: {
    from: '"Chain4Good" <chain4good@gmail.com>',
  },
  template: {
    dir: join(__dirname, '..', 'templates'),
    adapter: new HandlebarsAdapter(),
    options: {
      strict: true,
    },
  },
};

```

### src/dashboard/dashboard.controller.ts
```ts
import { Controller, Get, Query, UseGuards } from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { DashboardService } from './dashboard.service';

@Controller('dashboard')
@UseGuards(JwtAuthGuard)
export class DashboardController {
  constructor(private readonly dashboardService: DashboardService) {}

  @Get('stats')
  async getStats() {
    return this.dashboardService.getStats();
  }

  @Get('campaigns-stats')
  async getCampaignStats(@Query('days') days: number = 30) {
    return this.dashboardService.getCampaignStats(days);
  }

  @Get('donations-stats')
  async getDonationStats(@Query('days') days: number = 30) {
    return this.dashboardService.getDonationStats(days);
  }

  @Get('recent-activities')
  async getRecentActivities(@Query('limit') limit: number = 10) {
    return this.dashboardService.getRecentActivities(limit);
  }

  @Get('top-campaigns')
  async getTopCampaigns(@Query('limit') limit: number = 5) {
    return this.dashboardService.getTopCampaigns(limit);
  }

  @Get('user-growth')
  async getUserGrowth(@Query('days') days: number = 30) {
    return this.dashboardService.getUserGrowth(days);
  }
}

```

### src/dashboard/dashboard.module.ts
```ts
import { Module } from '@nestjs/common';
import { DashboardController } from './dashboard.controller';
import { DashboardService } from './dashboard.service';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [DashboardController],
  providers: [DashboardService],
})
export class DashboardModule {}

```

### src/dashboard/dashboard.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CampaignStatus } from '@prisma/client';

@Injectable()
export class DashboardService {
  constructor(private prisma: PrismaService) {}

  async getStats() {
    const [
      totalUsers,
      totalCampaigns,
      totalDonations,
      totalAmount,
      activeCampaigns,
    ] = await Promise.all([
      this.prisma.user.count(),
      this.prisma.campaign.count(),
      this.prisma.donation.count(),
      this.prisma.donation.aggregate({
        _sum: {
          amount: true,
        },
      }),
      this.prisma.campaign.count({
        where: {
          status: CampaignStatus.ACTIVE,
        },
      }),
    ]);

    return {
      totalUsers,
      totalCampaigns,
      totalDonations,
      totalAmount: totalAmount._sum.amount || 0,
      activeCampaigns,
    };
  }

  async getCampaignStats(days: number) {
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const campaigns = await this.prisma.campaign.groupBy({
      by: ['status'],
      where: {
        createdAt: {
          gte: startDate,
        },
      },
      _count: true,
    });

    return campaigns;
  }

  async getDonationStats(days: number) {
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const donations = await this.prisma.donation.findMany({
      where: {
        donatedAt: {
          gte: startDate,
        },
      },
      select: {
        amount: true,
        donatedAt: true,
      },
      orderBy: {
        donatedAt: 'asc',
      },
    });

    return donations;
  }

  async getRecentActivities(limit: number) {
    const activities = await this.prisma.donation.findMany({
      take: limit,
      orderBy: {
        donatedAt: 'desc',
      },
      include: {
        user: {
          select: {
            name: true,
            image: true,
          },
        },
        campaign: {
          select: {
            title: true,
          },
        },
      },
    });

    return activities;
  }

  async getTopCampaigns(limit: number) {
    return this.prisma.campaign.findMany({
      take: limit,
      orderBy: {
        totalDonated: 'desc',
      },
      include: {
        _count: {
          select: {
            donations: true,
          },
        },
        user: {
          select: {
            name: true,
          },
        },
      },
    });
  }

  async getUserGrowth(days: number) {
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const users = await this.prisma.user.groupBy({
      by: ['createdAt'],
      where: {
        createdAt: {
          gte: startDate,
        },
      },
      _count: true,
      orderBy: {
        createdAt: 'asc',
      },
    });

    return users;
  }
}

```

### src/common/base.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';
import { toCamelCase } from 'src/utils/string';

@Injectable()
export abstract class BaseRepository<
  T,
  TWhereInput,
  TCreateInput,
  TUpdateInput,
  TOrderByInput,
  TInclude,
> {
  protected abstract readonly prisma: PrismaService;
  protected abstract readonly modelName: Prisma.ModelName;

  protected get model() {
    return this.prisma[
      toCamelCase(this.modelName) as keyof PrismaService
    ] as unknown as {
      findMany: (args?: {
        where?: TWhereInput;
        orderBy?: TOrderByInput;
        skip?: number;
        take?: number;
        include?: TInclude;
      }) => Promise<T[]>;
      findUnique: (args: {
        where: { id: number };
        include?: TInclude;
      }) => Promise<T | null>;
      findFirst: (args: {
        where: TWhereInput;
        include?: TInclude;
      }) => Promise<T | null>;
      create: (args: { data: TCreateInput; include?: TInclude }) => Promise<T>;
      update: (args: {
        where: { id: number };
        data: TUpdateInput;
        include?: TInclude;
      }) => Promise<T>;
      delete: (args: { where: { id: number } }) => Promise<T>;
      count: (args?: { where?: TWhereInput }) => Promise<number>;
      updateMany: (args: {
        where: TWhereInput;
        data: TUpdateInput;
      }) => Promise<T>;
    };
  }

  async findAll(args?: {
    where?: TWhereInput;
    orderBy?: TOrderByInput;
    include?: TInclude;
  }): Promise<T[]> {
    return this.model.findMany(args);
  }

  async findOne(id: number, include?: TInclude): Promise<T | null> {
    return this.model.findUnique({
      where: { id },
      include,
    });
  }

  async findBy(where: TWhereInput, include?: TInclude): Promise<T[]> {
    return this.model.findMany({
      where,
      include,
    });
  }

  async findOneBy(where: TWhereInput, include?: TInclude): Promise<T | null> {
    return this.model.findFirst({
      where,
      include,
    });
  }

  async create(data: TCreateInput, include?: TInclude): Promise<T> {
    return this.model.create({
      data,
      include,
    });
  }

  async update(id: number, data: TUpdateInput, include?: TInclude): Promise<T> {
    return this.model.update({
      where: { id },
      data,
      include,
    });
  }

  async updateMany(where: TWhereInput, data: TUpdateInput): Promise<T> {
    return this.model.updateMany({
      where,
      data,
    });
  }

  async delete(id: number): Promise<T> {
    return this.model.delete({
      where: { id },
    });
  }

  async count(where?: TWhereInput): Promise<number> {
    return this.model.count({
      where,
    });
  }

  async paginate(
    page: number = 1,
    limit: number = 10,
    options?: {
      where?: TWhereInput;
      orderBy?: TOrderByInput;
      include?: TInclude;
    },
  ): Promise<{
    data: T[];
    meta: {
      total: number;
      page: number;
      limit: number;
    };
  }> {
    const skip = (page - 1) * limit;
    const { where, orderBy, include } = options || {};

    const [data, total] = await Promise.all([
      this.model.findMany({
        where,
        orderBy,
        skip: Number(skip),
        take: Number(limit),
        include,
      }),
      this.model.count({ where }),
    ]);

    return {
      data,
      meta: {
        total,
        page: Number(page),
        limit: Number(limit),
      },
    };
  }
}

```

### src/common/filters/all-exceptions.filter.ts
```ts
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { Response } from 'express';

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    const status =
      exception instanceof HttpException
        ? exception.getStatus()
        : HttpStatus.INTERNAL_SERVER_ERROR;

    const message =
      exception instanceof HttpException
        ? exception.getResponse()
        : typeof exception === 'object' &&
            exception !== null &&
            'message' in exception
          ? (exception as { message: string }).message
          : 'Internal server error';

    const stack =
      typeof exception === 'object' &&
      exception !== null &&
      'stack' in exception
        ? (exception as { stack: string }).stack
        : undefined;

    response.status(status).json({
      statusCode: status,
      message,
      timestamp: new Date().toISOString(),
      path: request.url,
      // Optional: send stack trace
      stack,
    });
  }
}

```

### src/country/country.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { CountryService } from './country.service';
import { CreateCountryDto } from './dto/create-country.dto';
import { UpdateCountryDto } from './dto/update-country.dto';

@Controller('countries')
export class CountryController {
  constructor(private readonly countryService: CountryService) {}

  @Post()
  create(@Body() createCountryDto: CreateCountryDto) {
    return this.countryService.create(createCountryDto);
  }

  @Get()
  findAll() {
    return this.countryService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.countryService.findOne(+id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCountryDto: UpdateCountryDto) {
    return this.countryService.update(+id, updateCountryDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.countryService.remove(+id);
  }
}

```

### src/country/country.module.ts
```ts
import { Module } from '@nestjs/common';
import { CountryService } from './country.service';
import { CountryController } from './country.controller';
import { CountryRepo } from './country.repository';

@Module({
  controllers: [CountryController],
  providers: [CountryService, CountryRepo],
})
export class CountryModule {}

```

### src/country/country.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { CreateCountryDto } from './dto/create-country.dto';
import { UpdateCountryDto } from './dto/update-country.dto';
import { CountryRepo } from './country.repository';

@Injectable()
export class CountryService {
  constructor(private readonly countryRepo: CountryRepo) {}
  create(createCountryDto: CreateCountryDto) {
    return this.countryRepo.create(createCountryDto);
  }

  findAll() {
    return this.countryRepo.findAll();
  }

  findOne(id: number) {
    return this.countryRepo.findOne(id);
  }

  update(id: number, updateCountryDto: UpdateCountryDto) {
    return this.countryRepo.update(id, updateCountryDto);
  }

  remove(id: number) {
    return this.countryRepo.delete(id);
  }
}

```

### src/country/country.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Country, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class CountryRepo extends BaseRepository<
  Country,
  Prisma.CountryWhereInput,
  Prisma.CountryCreateInput,
  Prisma.CountryUpdateInput,
  Prisma.CountryOrderByWithRelationInput,
  Prisma.CountryInclude
> {
  protected readonly modelName = 'Country' as Prisma.ModelName;

  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/country/entities/country.entity.ts
```ts
export class Country {}

```

### src/country/dto/create-country.dto.ts
```ts
import { IsNotEmpty, IsString } from 'class-validator';
export class CreateCountryDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsNotEmpty()
  code: string;

  @IsString()
  @IsNotEmpty()
  phoneCode: string;
}

```

### src/country/dto/update-country.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateCountryDto } from './create-country.dto';

export class UpdateCountryDto extends PartialType(CreateCountryDto) {}

```

### src/category/category.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Category, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class CategoryRepo extends BaseRepository<
  Category,
  Prisma.CategoryWhereInput,
  Prisma.CategoryCreateInput,
  Prisma.CategoryUpdateInput,
  Prisma.CategoryOrderByWithRelationInput,
  Prisma.CategoryInclude
> {
  protected readonly modelName = 'Category' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/category/category.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { CategoryService } from './category.service';
import { CreateCategoryDto } from './dto/create-category.dto';
import { UpdateCategoryDto } from './dto/update-category.dto';

@Controller('categories')
export class CategoryController {
  constructor(private readonly categoryService: CategoryService) {}

  @Post()
  create(@Body() createCategoryDto: CreateCategoryDto) {
    return this.categoryService.create(createCategoryDto);
  }

  @Get()
  findAll() {
    return this.categoryService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.categoryService.findOne(+id);
  }

  @Patch(':id')
  update(
    @Param('id') id: string,
    @Body() updateCategoryDto: UpdateCategoryDto,
  ) {
    return this.categoryService.update(+id, updateCategoryDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.categoryService.remove(+id);
  }
}

```

### src/category/category.module.ts
```ts
import { Module } from '@nestjs/common';
import { CategoryService } from './category.service';
import { CategoryController } from './category.controller';
import { CategoryRepo } from './category.repository';

@Module({
  controllers: [CategoryController],
  providers: [CategoryService, CategoryRepo],
})
export class CategoryModule {}

```

### src/category/category.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { CreateCategoryDto } from './dto/create-category.dto';
import { UpdateCategoryDto } from './dto/update-category.dto';
import { CategoryRepo } from './category.repository';

@Injectable()
export class CategoryService {
  constructor(private readonly categoryRepo: CategoryRepo) {}

  create(createCategoryDto: CreateCategoryDto) {
    return this.categoryRepo.create(createCategoryDto);
  }

  findAll() {
    return this.categoryRepo.findAll();
  }

  findOne(id: number) {
    return this.categoryRepo.findOne(id);
  }

  update(id: number, updateCategoryDto: UpdateCategoryDto) {
    return this.categoryRepo.update(id, updateCategoryDto);
  }

  remove(id: number) {
    return this.categoryRepo.delete(id);
  }
}

```

### src/category/entities/category.entity.ts
```ts
export class Category {}

```

### src/category/dto/update-category.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateCategoryDto } from './create-category.dto';

export class UpdateCategoryDto extends PartialType(CreateCategoryDto) {}

```

### src/category/dto/create-category.dto.ts
```ts
import { IsNotEmpty, IsOptional, IsString } from 'class-validator';

export class CreateCategoryDto {
  @IsString()
  @IsNotEmpty({ message: 'Name is required' })
  name: string;

  @IsString()
  @IsOptional()
  icon?: string;

  @IsString()
  @IsOptional()
  description?: string;
}

```

### src/badge/user-badge.repository.ts
```ts
// user-badge.repository.ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { UserBadge, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class UserBadgeRepository extends BaseRepository<
  UserBadge,
  Prisma.UserBadgeWhereInput,
  Prisma.UserBadgeCreateInput,
  Prisma.UserBadgeUpdateInput,
  Prisma.UserBadgeOrderByWithRelationInput,
  Prisma.UserBadgeInclude
> {
  protected readonly modelName = 'UserBadge' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/badge/badge.module.ts
```ts
import { Module } from '@nestjs/common';
import { BadgeService } from './badge.service';
import { UserBadgeRepository } from './user-badge.repository';
import { BadgeRepository } from './badge.repository';

@Module({
  imports: [],
  controllers: [],
  providers: [BadgeService, BadgeRepository, UserBadgeRepository],
  exports: [BadgeService, BadgeRepository, UserBadgeRepository], // Export all required providers
})
export class BadgeModule {}

```

### src/badge/badge.repository.ts
```ts
// badge.repository.ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Badge, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class BadgeRepository extends BaseRepository<
  Badge,
  Prisma.BadgeWhereInput,
  Prisma.BadgeCreateInput,
  Prisma.BadgeUpdateInput,
  Prisma.BadgeOrderByWithRelationInput,
  Prisma.BadgeInclude
> {
  protected readonly modelName = 'Badge' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/badge/badge.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { BadgeRepository } from './badge.repository';
import { UserBadgeRepository } from './user-badge.repository';

@Injectable()
export class BadgeService {
  constructor(
    private readonly badgeRepo: BadgeRepository,
    private readonly userBadgeRepo: UserBadgeRepository,
  ) {}

  async getAllBadges() {
    return this.badgeRepo.findAll();
  }

  async getUserBadges(userId: number) {
    return this.userBadgeRepo.findBy({ userId }, { badge: true });
  }

  async awardBadgeToUser(userId: number, badgeId: number) {
    // Kiểm tra user đã có badge chưa
    const existing = await this.userBadgeRepo.findBy({ userId, badgeId });
    if (existing.length > 0) return existing[0];

    return this.userBadgeRepo.create({
      user: { connect: { id: userId } },
      badge: { connect: { id: badgeId } },
    });
  }
}

```

### src/ai/ai.module.ts
```ts
import { Module, forwardRef } from '@nestjs/common';
import { AiController } from './ai.controller';
import { AiService } from './ai.service';
import { GeminiModule } from 'src/gemini/gemini.module';
import { CampaignModule } from 'src/campaign/campaign.module';
import { UsersModule } from 'src/users/users.module';
import { DonationModule } from 'src/donation/donation.module';

@Module({
  imports: [
    GeminiModule,
    forwardRef(() => CampaignModule), // Add forwardRef here
    UsersModule,
    DonationModule,
  ],
  controllers: [AiController],
  providers: [AiService],
  exports: [AiService],
})
export class AiModule {}

```

### src/ai/ai.service.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { Injectable, Inject, forwardRef } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import OpenAI from 'openai';
import { ThankYouLetterResponse } from './types/thank-you-letter.type';
import { GeminiService } from 'src/gemini/gemini.service';
import { CampaignAnalysis } from './types/analyze-campaign.type';
import { TrustAnalysis } from './types/trust-analyze.type';
import { CampaignService } from 'src/campaign/campaign.service';
import { CampaignOptimization } from './types/campaign-optimization.type';
import { RecommendationResponse } from './types/campaign-recommendations.type';
import { UsersService } from 'src/users/users.service';
import { DonationService } from 'src/donation/donation.service';

@Injectable()
export class AiService {
  private openai: OpenAI;

  constructor(
    private configService: ConfigService,
    private geminiService: GeminiService,
    @Inject(forwardRef(() => CampaignService))
    private campaignService: CampaignService,
    private userService: UsersService,
    private donationService: DonationService,
  ) {
    this.openai = new OpenAI({
      apiKey: this.configService.get('OPENAI_API_KEY'),
    });
  }

  async analyzeCampaign(title: string, description: string) {
    const prompt = `
            Phân tích và tóm tắt chiến dịch từ thiện sau:
            Tiêu đề: ${title}
            Mô tả: ${description}
            Trả về JSON với 2 field:
            - summary: tóm tắt ngắn gọn chiến dịch
            - analysis: phân tích ngắn gọn về mức độ thuyết phục, tính nhân văn, khả năng kêu gọi.
            `;

    const response = await this.openai.chat.completions.create({
      model: 'gpt-3.5-turbo-0125',
      messages: [{ role: 'user', content: prompt }],
    });

    const content = response.choices[0].message?.content;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return JSON.parse(content || '{}');
  }

  async generateThankYouLetter(
    campaignName: string,
  ): Promise<ThankYouLetterResponse> {
    const prompt = `
      Bạn là một chuyên gia thiết kế email marketing cao cấp. Hãy tạo một email cảm ơn chuyên nghiệp với các yêu cầu sau:

      THÔNG TIN:
      - Tên chiến dịch: "${campaignName}"

      YÊU CẦU THIẾT KẾ:
      - Sử dụng HTML5 và inline CSS
      - Màu sắc: 
        + Màu chủ đạo: #16A34A (xanh lá)
        + Màu phụ: #F0FDF4 (nền nhạt)
        + Màu accent: #166534 (nhấn mạnh)
      - Font: 'Helvetica Neue', Arial, sans-serif
      - Responsive design
      - Có background pattern tinh tế
      - Thêm icon trái tim hoặc bàn tay nắm lại phù hợp

      NỘI DUNG:
      - Độ dài: 100-150 từ
      - Giọng điệu: Chân thành, ấm áp nhưng chuyên nghiệp
      - Nhấn mạnh tác động tích cực của sự đóng góp
      - Tránh klisê và từ ngữ sáo rỗng
      - Kết thúc bằng lời mời tiếp tục đồng hành

      Trả về JSON với định dạng:
      {
        "subject": "Tiêu đề email ngắn gọn, thu hút",
        "content": "HTML template với đầy đủ styling (inline CSS)"
      }
    `;

    const response = await this.openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [{ role: 'user', content: prompt }],
      response_format: { type: 'json_object' },
    });

    try {
      const content = response.choices[0].message?.content;
      if (!content) {
        throw new Error('Empty response from OpenAI');
      }

      // Clean the response string of any control characters
      // eslint-disable-next-line no-control-regex
      const cleanContent = content.replace(/[\x00-\x1F\x7F-\x9F]/g, '');

      return JSON.parse(cleanContent) as ThankYouLetterResponse;
    } catch (error) {
      console.error('Failed to parse AI response:', error);
      return {
        subject: 'Thank You for Your Support',
        content: '<p>Thank you for your generous contribution.</p>',
      };
    }
  }

  async analyzeCampaignWithGemini(
    title: string,
    description: string,
  ): Promise<CampaignAnalysis> {
    const prompt = `
      Hãy phân tích và tóm tắt chiến dịch từ thiện sau.
      Trả về kết quả dưới dạng JSON với định dạng chính xác như sau:
      {
        "summary": "tóm tắt ngắn gọn về chiến dịch",
        "analysis": "phân tích về tính thuyết phục, tính nhân văn và khả năng kêu gọi"
      }

      Thông tin chiến dịch:
      Tiêu đề: ${title}
      Mô tả: ${description}
    `;

    try {
      const result = await this.geminiService.generateContent(prompt);
      const data = JSON.parse(result);
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      return data;
    } catch (error) {
      console.error('Failed to analyze campaign with Gemini:', error);
      return {
        summary: 'Không thể phân tích chiến dịch.',
        analysis: 'Đã xảy ra lỗi trong quá trình phân tích.',
      };
    }
  }

  async analyzeCampaignTrust(campaignId: number): Promise<TrustAnalysis> {
    const campaign = await this.campaignService.findOne(campaignId);
    if (!campaign) {
      throw new Error('Campaign not found');
    }
    const prompt = `
      Đánh giá độ tin cậy và sentiment của chiến dịch:
      - Tiêu đề: ${campaign.title}
      - Mô tả: ${campaign.description}
      
      Trả về JSON:
      {
        "trustScore": number, // 0-100
        "sentiment": "positive" | "neutral" | "negative",
        "credibilityFactors": ["yếu tố 1", "yếu tố 2"],
        "riskFactors": ["rủi ro 1", "rủi ro 2"],
        "recommendations": ["đề xuất 1", "đề xuất 2"]
      }
    `;
    const result = await this.geminiService.generateContent(prompt);
    const data = JSON.parse(result);
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return data;
  }

  async optimizeCampaignContent(
    title: string,
    description: string,
  ): Promise<CampaignOptimization> {
    const prompt = ` Bạn là một chuyên gia về truyền thông xã hội và viết nội dung từ thiện. Hãy phân tích và tối ưu hóa chiến dịch dưới đây, chỉ cải thiện cách diễn đạt, từ ngữ và cấu trúc – **không rút gọn hay bỏ bất kỳ thông tin nào**.
    Chiến dịch:
    Tiêu đề: ${title}
    Mô tả: ${description}
    
    YÊU CẦU NGHIÊM NGẶT:
    - KHÔNG được tóm tắt hoặc rút gọn mô tả
    - Phải giữ nguyên toàn bộ độ dài và nội dung gốc
    - Chỉ cải thiện: ngữ pháp, cách hành văn, cách diễn đạt và bố cục
    - Mô tả sau tối ưu **phải sử dụng định dạng HTML**, gồm các thẻ <p>, <ul>, <li> khi phù hợp
    
    Trả về kết quả ở định dạng JSON (nội dung bằng tiếng Việt):
    {
      "optimizedTitle": "Tiêu đề đã cải thiện, vẫn giữ nguyên ý nghĩa gốc",
      "optimizedDescription": "<div>Mô tả được cải thiện, sử dụng HTML đầy đủ, giữ nguyên nội dung và độ dài gốc</div>",
      "keywords": ["từ khóa 1", "từ khóa 2", "từ khóa 3"],
      "suggestedImprovements": [
        "Gợi ý cải thiện cách trình bày, bố cục hoặc ngôn từ",
        "Gợi ý tăng tính cảm xúc hoặc kết nối với người đọc"
      ],
      "targetAudienceInsights": [
        "Nhận định về nhóm người có khả năng quan tâm chiến dịch",
        "Phân tích hành vi hoặc nhu cầu của đối tượng mục tiêu"
      ]
    }
    `;

    try {
      const result = await this.geminiService.generateContent(prompt);

      const parsed = JSON.parse(result);

      if (parsed.optimizedDescription.length < description.length * 0.9) {
        throw new Error('Nội dung đã bị rút gọn quá nhiều');
      }

      if (!parsed.optimizedDescription.startsWith('<')) {
        parsed.optimizedDescription = `<div>${parsed.optimizedDescription}</div>`;
      }

      return parsed as CampaignOptimization;
    } catch (error) {
      console.error('Không thể tối ưu hóa nội dung chiến dịch:', error);
      throw new Error('Tối ưu hóa chiến dịch thất bại - Vui lòng thử lại');
    }
  }

  async getPersonalizedRecommendations(
    userId: number,
  ): Promise<RecommendationResponse> {
    const user = await this.userService.findById(userId);
    const userDonations = await this.donationService.findAllByUserId(userId);

    const donationHistory = userDonations.map((d) => ({
      campaignId: d.campaignId,
      amount: d.amount,
      categoryId: d.campaign.categoryId,
      date: d.donatedAt,
    }));

    const prompt = `
      Phân tích mẫu quyên góp của người dùng và đề xuất các chiến dịch phù hợp.
      
      Thông tin người dùng:
      - Địa chỉ ví: ${user?.address || 'Chưa xác định'} // Địa chỉ ví MetaMask
      - Lịch sử giao dịch: ${JSON.stringify(donationHistory)}
      
      Xem xét các yếu tố:
      - Mẫu giao dịch blockchain trước đây
      - Tần suất và số tiền quyên góp
      - Danh mục chiến dịch mà người dùng đã ủng hộ
      - Các tương tác với smart contract
      
      Trả về đề xuất chiến dịch dưới dạng JSON:
      {
        "recommendations": [
          {
            "campaignId": số, // ID chiến dịch
            "score": số (0-100), // Điểm đánh giá độ phù hợp
            "matchingFactors": ["yếu tố phù hợp 1", "yếu tố phù hợp 2"],
            "relevanceScore": số (0-1), // Điểm liên quan
            "blockchainFactors": {
              "gasFeeEstimate": "ước tính phí gas",
              "networkCompatibility": "độ tương thích mạng",
              "contractSecurity": "độ an toàn của hợp đồng"
            }
          }
        ],
        "explanations": ["giải thích 1", "giải thích 2"] // Các giải thích cho đề xuất
      }
    `;

    try {
      const result = await this.geminiService.generateContent(prompt);
      return JSON.parse(result) as RecommendationResponse;
    } catch (error) {
      console.error('Không thể tạo đề xuất:', error);
      throw new Error('Không thể tạo đề xuất chiến dịch');
    }
  }
}

```

### src/ai/ai.controller.ts
```ts
import { Body, Controller, Get, Param, Post, UseGuards } from '@nestjs/common';
import { AiService } from './ai.service';
import { AnalyzeCampaignDto } from './dto/analyze-campaign.dto';
import { GetUser, UserExtract } from 'src/auth/decorators/auth.decorators';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';

@Controller('ai')
export class AiController {
  constructor(private readonly aiService: AiService) {}

  @Post('analyze-campaign')
  async analyze(@Body() dto: AnalyzeCampaignDto) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return this.aiService.analyzeCampaign(dto.title, dto.description);
  }
  @Post('analyze-campaign-gemini')
  async analyzeGemine(@Body() dto: AnalyzeCampaignDto) {
    return this.aiService.analyzeCampaignWithGemini(dto.title, dto.description);
  }

  @Get('analyze-campaign-trust/:campaignId')
  async analyzeTrust(@Param('campaignId') campaignId: number) {
    return this.aiService.analyzeCampaignTrust(+campaignId);
  }

  @Post('optimize-campaign')
  async optimize(@Body() dto: AnalyzeCampaignDto) {
    return this.aiService.optimizeCampaignContent(dto.title, dto.description);
  }

  @Get('recommendations')
  @UseGuards(JwtAuthGuard)
  async getRecommendations(@GetUser() user: UserExtract) {
    return this.aiService.getPersonalizedRecommendations(+user.id);
  }
}

```

### src/ai/types/analyze-campaign.type.ts
```ts
export interface CampaignAnalysis {
  summary: string;
  analysis: string;
}

```

### src/ai/types/campaign-optimization.type.ts
```ts
export interface CampaignOptimization {
  optimizedTitle: string;
  optimizedDescription: string;
  keywords: string[];
  suggestedImprovements: string[];
  targetAudienceInsights: string[];
}

```

### src/ai/types/campaign-recommendations.type.ts
```ts
export interface BlockchainFactors {
  gasFeeEstimate: string;
  networkCompatibility: string;
  contractSecurity: string;
}

export interface CampaignRecommendation {
  campaignId: number;
  score: number;
  matchingFactors: string[];
  relevanceScore: number;
  blockchainFactors: BlockchainFactors;
}

export interface RecommendationResponse {
  recommendations: CampaignRecommendation[];
  explanations: string[];
}

```

### src/ai/types/trust-analyze.type.ts
```ts
export interface TrustAnalysis {
  trustScore: number;
  sentiment: 'positive' | 'neutral' | 'negative';
  credibilityFactors: string[];
  riskFactors: string[];
  recommendations: string[];
}

```

### src/ai/types/thank-you-letter.type.ts
```ts
export interface ThankYouLetterResponse {
  subject: string;
  content: string;
}

```

### src/ai/dto/analyze-campaign.dto.ts
```ts
import { IsString } from 'class-validator';

export class AnalyzeCampaignDto {
  @IsString()
  title: string;

  @IsString()
  description: string;
}

```

### src/prisma/prisma.module.ts
```ts
import { Module, Global } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global()
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}

```

### src/prisma/prisma.service.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-call */
// src/prisma/prisma.service.ts

import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService
  extends PrismaClient
  implements OnModuleInit, OnModuleDestroy
{
  async onModuleInit() {
    await this.$connect();
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}

```

### src/fundraise-type/fundraise-type.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { FundraiseType, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class FundraiseTypeRepo extends BaseRepository<
  FundraiseType,
  Prisma.FundraiseTypeWhereInput,
  Prisma.FundraiseTypeCreateInput,
  Prisma.FundraiseTypeUpdateInput,
  Prisma.FundraiseTypeOrderByWithRelationInput,
  Prisma.FundraiseTypeInclude
> {
  protected readonly modelName = 'FundraiseType' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/fundraise-type/fundraise-type.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { CreateFundraiseTypeDto } from './dto/create-fundraise-type.dto';
import { UpdateFundraiseTypeDto } from './dto/update-fundraise-type.dto';
import { FundraiseTypeRepo } from './fundraise-type.repository';

@Injectable()
export class FundraiseTypeService {
  constructor(private readonly fundraiseTypeRepo: FundraiseTypeRepo) {}

  create(createFundraiseTypeDto: CreateFundraiseTypeDto) {
    return this.fundraiseTypeRepo.create(createFundraiseTypeDto);
  }

  findAll() {
    return this.fundraiseTypeRepo.findAll();
  }

  findOne(id: number) {
    return this.fundraiseTypeRepo.findOne(id);
  }

  update(id: number, updateFundraiseTypeDto: UpdateFundraiseTypeDto) {
    return this.fundraiseTypeRepo.update(id, updateFundraiseTypeDto);
  }

  remove(id: number) {
    return this.fundraiseTypeRepo.delete(id);
  }
}

```

### src/fundraise-type/fundraise-type.module.ts
```ts
import { Module } from '@nestjs/common';
import { FundraiseTypeService } from './fundraise-type.service';
import { FundraiseTypeController } from './fundraise-type.controller';
import { FundraiseTypeRepo } from './fundraise-type.repository';

@Module({
  controllers: [FundraiseTypeController],
  providers: [FundraiseTypeService, FundraiseTypeRepo],
})
export class FundraiseTypeModule {}

```

### src/fundraise-type/fundraise-type.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  ParseIntPipe,
} from '@nestjs/common';
import { FundraiseTypeService } from './fundraise-type.service';
import { CreateFundraiseTypeDto } from './dto/create-fundraise-type.dto';
import { UpdateFundraiseTypeDto } from './dto/update-fundraise-type.dto';

@Controller('fundraise-types')
export class FundraiseTypeController {
  constructor(private readonly fundraiseTypeService: FundraiseTypeService) {}

  @Post()
  create(@Body() createFundraiseTypeDto: CreateFundraiseTypeDto) {
    return this.fundraiseTypeService.create(createFundraiseTypeDto);
  }

  @Get()
  findAll() {
    return this.fundraiseTypeService.findAll();
  }

  @Get(':id')
  findOne(@Param('id', ParseIntPipe) id: number) {
    return this.fundraiseTypeService.findOne(id);
  }

  @Patch(':id')
  update(
    @Param('id', ParseIntPipe) id: number,
    @Body() updateFundraiseTypeDto: UpdateFundraiseTypeDto,
  ) {
    return this.fundraiseTypeService.update(id, updateFundraiseTypeDto);
  }

  @Delete(':id')
  remove(@Param('id', ParseIntPipe) id: number) {
    return this.fundraiseTypeService.remove(id);
  }
}

```

### src/fundraise-type/entities/fundraise-type.entity.ts
```ts
export class FundraiseType {
  id: number;
  name: string;
  description: string;
}

```

### src/fundraise-type/dto/update-fundraise-type.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateFundraiseTypeDto } from './create-fundraise-type.dto';

export class UpdateFundraiseTypeDto extends PartialType(
  CreateFundraiseTypeDto,
) {}

```

### src/fundraise-type/dto/create-fundraise-type.dto.ts
```ts
import { IsString, IsNotEmpty } from 'class-validator';

export class CreateFundraiseTypeDto {
  @IsString()
  @IsNotEmpty()
  name: string;
  @IsString()
  @IsNotEmpty()
  description: string;
}

```

### src/utils/string.ts
```ts
export function toCamelCase(name: string | undefined) {
  if (!name) return '';
  return name.charAt(0).toLowerCase() + name.slice(1);
}

```

### src/post/post.module.ts
```ts
import { Module } from '@nestjs/common';
import { PostController } from './post.controller';
import { PostService } from './post.service';
import { PostRepository } from './post.repository';

@Module({
  controllers: [PostController],
  providers: [PostService, PostRepository],
  exports: [PostService],
})
export class PostModule {}

```

### src/post/post.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { PostRepository } from './post.repository';
import { CreatePostDto } from './dto/create-post.dto';
import { UpdatePostDto } from './dto/update-post.dto';
import { Post, Prisma } from '@prisma/client';

@Injectable()
export class PostService {
  constructor(private readonly postRepo: PostRepository) {}

  async create(
    createPostDto: CreatePostDto & { userId: number },
  ): Promise<Post> {
    const { userId, topicId, ...rest } = createPostDto;
    return this.postRepo.create({
      ...rest,
      user: { connect: { id: userId } },
      topic: { connect: { id: topicId } },
      slug: this.createSlug(rest.title),
    });
  }

  async findOneBySlug(slug: string) {
    return this.postRepo.findOneBy(
      {
        slug,
      },
      {
        topic: true,
        user: {
          select: {
            id: true,
            name: true,
            image: true,
          },
        },
      },
    );
  }

  async findAll(
    page: number = 1,
    limit: number = 10,
    search?: string,
    topicId?: number,
    published: boolean = true,
  ) {
    const where: Prisma.PostWhereInput = {
      published,
      ...(topicId && { topicId: Number(topicId) }),
      ...(search && {
        OR: [
          {
            title: {
              contains: search,
              mode: Prisma.QueryMode.insensitive,
            },
          },
          {
            content: {
              contains: search,
              mode: Prisma.QueryMode.insensitive,
            },
          },
        ],
      }),
    };

    return this.postRepo.paginate(page, limit, {
      where,
      orderBy: { createdAt: 'desc' },
      include: {
        topic: true,
        user: {
          select: {
            id: true,
            name: true,
            image: true,
          },
        },
      },
    });
  }

  findOne(id: number) {
    return this.postRepo.findOne(id, {
      topic: true,
      user: {
        select: {
          id: true,
          name: true,
          image: true,
        },
      },
    });
  }

  update(id: number, updatePostDto: UpdatePostDto) {
    const { topicId, ...rest } = updatePostDto;
    return this.postRepo.update(
      id,
      {
        ...rest,
        ...(topicId && { topic: { connect: { id: topicId } } }),
      },
      {
        topic: true,
        user: {
          select: {
            id: true,
            name: true,
            image: true,
          },
        },
      },
    );
  }

  remove(id: number) {
    return this.postRepo.delete(id);
  }

  private createSlug(title: string): string {
    return title
      .toLowerCase()
      .replace(/ /g, '-')
      .replace(/[^\w-]+/g, '')
      .replace(/--+/g, '-');
  }
}

```

### src/post/post.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from '../common/base.repository';
import { Post, Prisma } from '@prisma/client';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class PostRepository extends BaseRepository<
  Post,
  Prisma.PostWhereInput,
  Prisma.PostCreateInput,
  Prisma.PostUpdateInput,
  Prisma.PostOrderByWithRelationInput,
  Prisma.PostInclude
> {
  protected readonly modelName = 'Post' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/post/post.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  UseGuards,
} from '@nestjs/common';
import { PostService } from './post.service';
import { CreatePostDto } from './dto/create-post.dto';
import { UpdatePostDto } from './dto/update-post.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { GetUser } from '../auth/decorators/auth.decorators';

@Controller('posts')
export class PostController {
  constructor(private readonly postService: PostService) {}

  @Post()
  @UseGuards(JwtAuthGuard)
  create(
    @Body() createPostDto: CreatePostDto,
    @GetUser() user: { id: number },
  ) {
    return this.postService.create({
      ...createPostDto,
      userId: user.id,
    });
  }

  @Get()
  findAll(
    @Query('page') page: number,
    @Query('limit') limit: number,
    @Query('search') search: string,
    @Query('topicId') topicId: number,
    @Query('published') published: boolean,
  ) {
    return this.postService.findAll(page, limit, search, topicId, published);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.postService.findOne(+id);
  }

  @Get('slug/:slug')
  findOneBySlug(@Param('slug') slug: string) {
    return this.postService.findOneBySlug(slug);
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard)
  update(@Param('id') id: string, @Body() updatePostDto: UpdatePostDto) {
    return this.postService.update(+id, updatePostDto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  remove(@Param('id') id: string) {
    return this.postService.remove(+id);
  }
}

```

### src/post/dto/update-post.dto.ts
```ts
// filepath: src/post/dto/update-post.dto.ts
import { PartialType } from '@nestjs/mapped-types';
import { CreatePostDto } from './create-post.dto';

export class UpdatePostDto extends PartialType(CreatePostDto) {}

```

### src/post/dto/create-post.dto.ts
```ts
// filepath: src/post/dto/create-post.dto.ts
import { IsNotEmpty, IsString, IsOptional, IsBoolean } from 'class-validator';

export class CreatePostDto {
  @IsString()
  @IsNotEmpty()
  title: string;

  @IsString()
  @IsNotEmpty()
  content: string;

  @IsString()
  @IsOptional()
  thumbnail?: string;

  @IsNotEmpty()
  topicId: number;

  @IsBoolean()
  @IsOptional()
  published?: boolean;
}

```

### src/users/users.module.ts
```ts
import { Module } from '@nestjs/common';
import { UsersService } from './users.service';
import { PrismaModule } from '../prisma/prisma.module';
import { UserController } from './users.controller';
import { UserRepository } from './user.repository';

@Module({
  controllers: [UserController],
  imports: [PrismaModule],
  providers: [UsersService, UserRepository],
  exports: [UsersService],
})
export class UsersModule {}

```

### src/users/users.service.ts
```ts
import { ConflictException, Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Prisma, User } from '@prisma/client';
import { UserRegisterDTO } from 'src/auth/dtos/user-register.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { UserRepository } from './user.repository';

@Injectable()
export class UsersService {
  constructor(
    private prisma: PrismaService,
    private readonly userRepository: UserRepository,
  ) {}

  async findByEmail(email: string): Promise<User | null> {
    return this.prisma.user.findUnique({
      where: { email },
    });
  }

  async findById(id: number): Promise<User | null> {
    return this.prisma.user.findUnique({
      where: { id },
    });
  }

  async create(userRegisterDto: UserRegisterDTO): Promise<User> {
    const { email, password, name, address } = userRegisterDto;
    try {
      return await this.prisma.user.create({
        data: {
          email,
          password,
          name,
          address,
          roleId: 2,
        },
      });
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
          throw new ConflictException(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Unique constraint failed on the fields: (${error?.meta?.target})`,
          );
        }
      }
      throw error;
    }
  }
  async update(id: number, data: UpdateUserDto) {
    return this.prisma.user.update({
      where: { id },
      data,
    });
  }

  async findAllByRole(roleId: number) {
    return this.prisma.user.findMany({
      where: { roleId },
    });
  }

  async findAll(
    page: number,
    limit: number,
    name: string,
    email: string,
    role: string,
  ) {
    return this.userRepository.paginate(page, limit, {
      where: {
        ...(name && { name: { contains: name, mode: 'insensitive' } }),
        ...(email && { email: { contains: email, mode: 'insensitive' } }),
        ...(role && { roleId: Number(role) }),
      },
    });
  }
}

```

### src/users/user.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { User, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class UserRepository extends BaseRepository<
  User,
  Prisma.UserWhereInput,
  Prisma.UserCreateInput,
  Prisma.UserUpdateInput,
  Prisma.UserOrderByWithRelationInput,
  Prisma.UserInclude
> {
  protected readonly modelName = 'User' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/users/users.controller.ts
```ts
import { Body, Controller, Get, Param, Patch, Query } from '@nestjs/common';
import { UsersService } from './users.service';
import { UpdateUserDto } from './dto/update-user.dto';

@Controller('users')
export class UserController {
  constructor(private readonly userService: UsersService) {}

  @Get('')
  findAll(
    @Query('page') page: number,
    @Query('limit') limit: number,
    @Query('name') name: string,
    @Query('email') email: string,
    @Query('role') role: string,
  ) {
    return this.userService.findAll(page, limit, name, email, role);
  }

  @Patch(':id')
  update(@Body() updateUserDto: UpdateUserDto, @Param('id') id: string) {
    return this.userService.update(+id, updateUserDto);
  }
  @Get('role/:id')
  findAllByRole(@Param('id') id: number) {
    return this.userService.findAllByRole(+id);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.userService.findById(+id);
  }
}

```

### src/users/dto/update-user.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { UserRegisterDTO } from 'src/auth/dtos/user-register.dto';

export class UpdateUserDto extends PartialType(UserRegisterDTO) {}

```

### src/gemini/gemini.module.ts
```ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { GeminiService } from './gemini.service';

@Module({
  imports: [ConfigModule],
  providers: [GeminiService],
  exports: [GeminiService],
})
export class GeminiModule {}

```

### src/gemini/gemini.service.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-argument */
/* eslint-disable @typescript-eslint/await-thenable */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { GoogleGenerativeAI } from '@google/generative-ai';

@Injectable()
export class GeminiService {
  private genAI: GoogleGenerativeAI;
  private model: any;

  constructor(private configService: ConfigService) {
    this.genAI = new GoogleGenerativeAI(
      this.configService.get<string>('GEMINI_API_KEY') || '',
    );
    this.model = this.genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });
  }
  async generateContent(prompt: string): Promise<string> {
    try {
      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      let textResponse = response.text();

      // Clean and parse JSON response
      try {
        // Remove markdown code blocks if present
        textResponse = textResponse.replace(/^```json\s*/, '');
        textResponse = textResponse.replace(/\s*```$/, '');

        // Remove any trailing commas in objects/arrays
        textResponse = textResponse.replace(/,(\s*[}\]])/g, '$1');

        // Clean any non-JSON content before or after
        textResponse = textResponse.replace(/^[^{[]+/, '');
        textResponse = textResponse.replace(/[^}\]]+$/, '');

        // Attempt to parse the cleaned JSON
        const jsonParsed = JSON.parse(textResponse.trim());
        return JSON.stringify(jsonParsed, null, 2);
      } catch (parseError) {
        console.warn('Failed to parse JSON response:', parseError.message);
        console.warn('Raw response:', textResponse);
        return textResponse;
      }
    } catch (error) {
      console.error('Gemini API error:', error);
      throw new Error(`Failed to generate content: ${error.message}`);
    }
  }

  async generateContentFromImage(prompt: string, imageUrl: string) {
    try {
      const model = this.genAI.getGenerativeModel({
        model: 'gemini-2.0-flash',
      });

      const response = await fetch(imageUrl);
      const imageBytes = await response.arrayBuffer();

      const result = await model.generateContent([
        prompt,
        {
          inlineData: {
            data: Buffer.from(imageBytes).toString('base64'),
            mimeType: 'image/jpeg',
          },
        },
      ]);

      const text = await result.response;
      return text.text();
    } catch (error) {
      throw new Error(
        `Failed to generate content from image: ${error.message}`,
      );
    }
  }
}

```

### src/otp/otp.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { MailerService } from '../mailer/mailer.service';

@Injectable()
export class OTPService {
  constructor(
    private prisma: PrismaService,
    private mailerService: MailerService,
  ) {}

  async generateOTP(email: string): Promise<string> {
    const code = Math.floor(100000 + Math.random() * 900000).toString();
    const expiresAt = new Date();
    expiresAt.setMinutes(expiresAt.getMinutes() + 15);

    await this.prisma.oTP.upsert({
      where: { email },
      update: {
        code,
        expiresAt,
        verified: false,
      },
      create: {
        email,
        code,
        expiresAt,
      },
    });
    await this.mailerService.sendMail(
      email,
      'Xác thực email của bạn',
      'verify-email',
      {
        code,
        logoUrl: 'http://chain4good.io.vn/logo.png',
        supportUrl: 'http://chain4good.io.vn/support',
        privacyUrl: 'http://chain4good.io.vn/privacy',
        termsUrl: 'http://chain4good.io.vn/terms',
        currentYear: new Date().getFullYear(),
      },
    );
    return code;
  }

  async verifyOTP(email: string, code: string): Promise<boolean> {
    const otp = await this.prisma.oTP.findUniqueOrThrow({
      where: { email },
    });

    if (!otp) return false;
    if (otp.verified) return false;
    if (otp.code !== code) return false;
    if (otp.expiresAt < new Date()) return false;

    await this.prisma.oTP.update({
      where: { email },
      data: { verified: true },
    });

    return true;
  }
}

```

### src/mailer/mailer.module.ts
```ts
import { Module } from '@nestjs/common';
import { MailerModule as NestMailerModule } from '@nestjs-modules/mailer';
import { mailerConfig } from '../config/mailer.config';
import { MailerService } from './mailer.service';

@Module({
  imports: [NestMailerModule.forRoot(mailerConfig)],
  providers: [MailerService],
  exports: [MailerService],
})
export class MailerModule {}

```

### src/mailer/mailer.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { MailerService as NestMailerService } from '@nestjs-modules/mailer';

@Injectable()
export class MailerService {
  constructor(private readonly mailerService: NestMailerService) {}

  async sendCampaignCreated(
    email: string,
    campaignName: string,
    campaignId: number,
  ) {
    await this.mailerService.sendMail({
      to: email,
      subject: 'Chiến dịch tạo ra thành công',
      template: 'campaign-created',
      context: {
        campaignName,
        campaignId,
      },
    });
  }

  async sendMail(
    email: string,
    subject: string,
    template: string,
    context: object,
  ) {
    await this.mailerService.sendMail({
      to: email,
      subject: subject,
      template: template,
      context,
    });
  }

  async sendDonationConfirmation(
    email: string,
    data: {
      campaignName: string;
      amount: number;
      donorName: string;
    },
  ) {
    await this.mailerService.sendMail({
      to: email,
      subject: 'Thank You for Your Donation',
      template: 'donation-confirmation',
      context: {
        ...data,
      },
    });
  }

  async sendCampaignStatusUpdate(
    email: string,
    data: {
      campaignName: string;
      status: string;
    },
  ) {
    await this.mailerService.sendMail({
      to: email,
      subject: 'Campaign Status Updated',
      template: 'campaign-status-update',
      context: {
        ...data,
      },
    });
  }

  async sendCustomThankYouEmail(
    email: string,
    subject: string,
    content: string,
  ) {
    await this.mailerService.sendMail({
      to: email,
      subject,
      html: content,
    });
  }

  async sendCustomEmail(email: string, subject: string, content: string) {
    await this.mailerService.sendMail({
      to: email,
      subject,
      html: content,
    });
  }

  async sendToAdminCampaignCreated(email: string, campaignName: string) {
    await this.mailerService.sendMail({
      to: email,
      subject: 'Chiến dịch mới được tạo',
      template: 'campaign-created-admin',
      context: {
        campaignName,
      },
    });
  }
}

```

### src/upload/upload.module.ts
```ts
import { Module } from '@nestjs/common';
import { UploadController } from './upload.controller';
import { UploadService } from './upload.service';
import { CloudinaryProvider } from './cloudinary.provider';
import { mkdir } from 'fs/promises';

@Module({
  controllers: [UploadController],
  providers: [
    UploadService,
    CloudinaryProvider,
    {
      provide: 'UPLOAD_INIT',
      useFactory: async () => {
        try {
          await mkdir('./uploads', { recursive: true });
        } catch (error) {
          // Ignore error if directory already exists
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          if (error.code !== 'EEXIST') {
            throw error;
          }
        }
      },
    },
  ],
})
export class UploadModule {}

```

### src/upload/cloudinary.provider.ts
```ts
import { v2 as cloudinary } from 'cloudinary';

export const CloudinaryProvider = {
  provide: 'CLOUDINARY',
  useFactory: () => {
    return cloudinary.config({
      cloud_name: process.env.CLOUDINARY_NAME,
      api_key: process.env.CLOUDINARY_API_KEY,
      api_secret: process.env.CLOUDINARY_API_SECRET,
      secure: true,
    });
  },
};

```

### src/upload/upload.service.ts
```ts
/* eslint-disable @typescript-eslint/prefer-promise-reject-errors */
import { Injectable, OnModuleInit } from '@nestjs/common';
import { v2 as cloudinary } from 'cloudinary';
import { createReadStream } from 'fs';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class UploadService implements OnModuleInit {
  constructor(private configService: ConfigService) {}

  onModuleInit() {
    const cloudName: string | undefined = this.configService.get(
      'CLOUDINARY_CLOUD_NAME',
    );
    const apiKey: string | undefined =
      this.configService.get('CLOUDINARY_API_KEY');
    const apiSecret: string | undefined = this.configService.get(
      'CLOUDINARY_API_SECRET',
    );


    if (!cloudName || !apiKey || !apiSecret) {
      throw new Error('Missing required Cloudinary configuration');
    }

    cloudinary.config({
      cloud_name: cloudName,
      api_key: apiKey,
      api_secret: apiSecret,
    });
  }

  async uploadImage(file: Express.Multer.File) {
    return new Promise((resolve, reject) => {
      const uploadStream = cloudinary.uploader.upload_stream(
        {
          folder: 'charity',
          resource_type: 'auto',
        },
        (error, result) => {
          if (error) return reject(error);
          resolve(result);
        },
      );
      createReadStream(file.path).pipe(uploadStream);
    });
  }
}

```

### src/upload/upload.controller.ts
```ts
import {
  Controller,
  Post,
  UploadedFile,
  UseInterceptors,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { UploadService } from './upload.service';
import { diskStorage } from 'multer';
import { unlink } from 'fs/promises';

@Controller('uploads')
export class UploadController {
  constructor(private readonly uploadService: UploadService) {}

  @Post()
  @UseInterceptors(
    FileInterceptor('file', {
      storage: diskStorage({
        destination: './uploads',
        filename: (req, file, cb) => {
          const uniqueName = `${Date.now()}-${file.originalname}`;
          cb(null, uniqueName);
        },
      }),
    }),
  )
  async uploadFile(@UploadedFile() file: Express.Multer.File) {
    try {
      const result = await this.uploadService.uploadImage(file);

      await unlink(file.path);

      return { url: (result as { secure_url: string }).secure_url };
    } catch (error) {
      await unlink(file.path);
      throw error;
    }
  }
}

```

### src/report/report.module.ts
```ts
import { Module } from '@nestjs/common';
import { ReportService } from './report.service';
import { ReportController } from './report.controller';
import { ReportRepository } from './report.repository';

@Module({
  controllers: [ReportController],
  providers: [ReportService, ReportRepository],
})
export class ReportModule {}

```

### src/report/report.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
} from '@nestjs/common';
import { ReportService } from './report.service';
import { CreateReportDto } from './dto/create-report.dto';
import { UpdateReportDto } from './dto/update-report.dto';

@Controller('reports')
export class ReportController {
  constructor(private readonly reportService: ReportService) {}

  @Post()
  create(@Body() createReportDto: CreateReportDto) {
    return this.reportService.create(createReportDto);
  }

  @Get()
  findAll(@Query('page') page: number, @Query('limit') limit: number) {
    return this.reportService.findAll(+page, +limit);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.reportService.findOne(+id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateReportDto: UpdateReportDto) {
    return this.reportService.update(+id, updateReportDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.reportService.remove(+id);
  }
}

```

### src/report/report.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from '../common/base.repository';
import { Report, Prisma } from '@prisma/client';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class ReportRepository extends BaseRepository<
  Report,
  Prisma.ReportWhereInput,
  Prisma.ReportCreateInput,
  Prisma.ReportUpdateInput,
  Prisma.ReportOrderByWithRelationInput,
  Prisma.ReportInclude
> {
  protected readonly modelName = 'Report' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/report/report.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { CreateReportDto } from './dto/create-report.dto';
import { UpdateReportDto } from './dto/update-report.dto';
import { ReportRepository } from './report.repository';

@Injectable()
export class ReportService {
  constructor(private readonly reportRepository: ReportRepository) {}
  create(createReportDto: CreateReportDto) {
    return this.reportRepository.create({
      content: createReportDto.content,
      type: createReportDto.type,
      campaign: { connect: { id: createReportDto.campaignId } },
    });
  }

  findAll(page: number, limit: number) {
    return this.reportRepository.paginate(page, limit, {
      include: {
        campaign: true,
        user: true,
      },
    });
  }

  findOne(id: number) {
    return this.reportRepository.findOne(id);
  }

  update(id: number, updateReportDto: UpdateReportDto) {
    return this.reportRepository.update(id, updateReportDto);
  }

  remove(id: number) {
    return this.reportRepository.delete(id);
  }
}

```

### src/report/entities/report.entity.ts
```ts
export class Report {}

```

### src/report/dto/create-report.dto.ts
```ts
import { ReportType } from '@prisma/client';
import { IsEnum, IsNotEmpty, IsNumber, IsString } from 'class-validator';

export class CreateReportDto {
  @IsString()
  @IsNotEmpty()
  content: string;

  @IsEnum(ReportType)
  @IsNotEmpty()
  type: ReportType;

  @IsNumber()
  @IsNotEmpty()
  campaignId: number;
}

```

### src/report/dto/update-report.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateReportDto } from './create-report.dto';

export class UpdateReportDto extends PartialType(CreateReportDto) {}

```

### src/image/image.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { ImageService } from './image.service';
import { CreateImageDto } from './dto/create-image.dto';
import { UpdateImageDto } from './dto/update-image.dto';

@Controller('image')
export class ImageController {
  constructor(private readonly imageService: ImageService) {}

  @Post()
  create(@Body() createImageDto: CreateImageDto) {
    return this.imageService.create(createImageDto);
  }

  @Get()
  findAll() {
    return this.imageService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.imageService.findOne(+id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateImageDto: UpdateImageDto) {
    return this.imageService.update(+id, updateImageDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.imageService.remove(+id);
  }
}

```

### src/image/image.module.ts
```ts
import { Module } from '@nestjs/common';
import { ImageService } from './image.service';
import { ImageController } from './image.controller';
import { ImageRepo } from './image.repository';

@Module({
  controllers: [ImageController],
  providers: [ImageService, ImageRepo],
})
export class ImageModule {}

```

### src/image/image.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Image, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class ImageRepo extends BaseRepository<
  Image,
  Prisma.ImageWhereInput,
  Prisma.ImageCreateInput,
  Prisma.ImageUpdateInput,
  Prisma.ImageOrderByWithRelationInput,
  Prisma.ImageInclude
> {
  protected readonly modelName = 'Image' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/image/image.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { CreateImageDto } from './dto/create-image.dto';
import { UpdateImageDto } from './dto/update-image.dto';
import { ImageRepo } from './image.repository';

@Injectable()
export class ImageService {
  constructor(private readonly imageRepo: ImageRepo) {}
  create(createImageDto: CreateImageDto) {
    return this.imageRepo.create(createImageDto);
  }

  findAll() {
    return this.imageRepo.findAll();
  }

  findOne(id: number) {
    return this.imageRepo.findOne(id);
  }

  update(id: number, updateImageDto: UpdateImageDto) {
    return this.imageRepo.update(id, updateImageDto);
  }

  remove(id: number) {
    return this.imageRepo.delete(id);
  }
}

```

### src/image/entities/image.entity.ts
```ts
export class Image {}

```

### src/image/dto/update-image.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateImageDto } from './create-image.dto';

export class UpdateImageDto extends PartialType(CreateImageDto) {}

```

### src/image/dto/create-image.dto.ts
```ts
import { ImageType } from '@prisma/client';
import {
  IsEnum,
  IsInt,
  IsNotEmpty,
  IsOptional,
  IsString,
  IsUrl,
} from 'class-validator';

export class CreateImageDto {
  @IsNotEmpty()
  @IsString()
  @IsUrl({}, { message: 'URL must be a valid URL' })
  url: string;

  @IsOptional()
  @IsInt({ message: 'Campaign ID must be an integer' })
  campaignId?: number;

  @IsOptional()
  @IsEnum(ImageType, { message: 'Type must be either IMAGE or VIDEO' })
  type?: ImageType;
}

```

### src/campaign/campaign.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Campaign, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class CampaignRepo extends BaseRepository<
  Campaign,
  Prisma.CampaignWhereInput,
  Prisma.CampaignCreateInput,
  Prisma.CampaignUpdateInput,
  Prisma.CampaignOrderByWithRelationInput,
  Prisma.CampaignInclude
> {
  protected readonly modelName = 'Campaign' as Prisma.ModelName;

  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/campaign/campaign.controller.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-return */
import {
  Body,
  Controller,
  Delete,
  Get,
  Param,
  Patch,
  Post,
  Query,
  UseGuards,
} from '@nestjs/common';
import { CampaignStatus } from '@prisma/client';
import { GetUser, UserExtract } from 'src/auth/decorators/auth.decorators';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { CampaignService } from './campaign.service';
import { CreateCampaignDto } from './dto/create-campaign.dto';
import { UpdateCampaignDto } from './dto/update-campaign.dto';
import { CreateCampaignProgressDto } from './dto/create-campaign-progress.dto';

@Controller('campaigns')
export class CampaignController {
  constructor(private readonly campaignService: CampaignService) {}

  @Post()
  @UseGuards(JwtAuthGuard)
  async create(
    @Body() createCampaignDto: CreateCampaignDto,
    @GetUser() user: UserExtract,
  ) {
    const campaign = await this.campaignService.create({
      ...createCampaignDto,
      userId: user.id,
      email: user.email,
    });
    return campaign;
  }

  @Get()
  findAll(
    @Query('userId') userId: number,
    @Query('email') email: string,
    @Query('status') status: CampaignStatus,
    @Query('page') page: number,
    @Query('limit') limit: number,
    @Query('search') search: string,
    @Query('sort') sort: 'asc' | 'desc',
    @Query('sortBy') sortBy: string,
    @Query('categoryId') categoryId: number,
    @Query('fundraiseTypeId') fundraiseTypeId: number,
    @Query('countryId') countryId: number,
  ) {
    return this.campaignService.findAll(
      userId,
      email,
      status,
      page,
      limit,
      search,
      sort,
      sortBy,
      categoryId,
      fundraiseTypeId,
      countryId,
    );
  }

  @Get('valid')
  async findCampaignValid(
    @Query('userId') userId: number,
    @Query('email') email: string,
    @Query('page') page: number,
    @Query('limit') limit: number,
    @Query('search') search: string,
    @Query('sort') sort: 'asc' | 'desc',
    @Query('sortBy') sortBy: string,
    @Query('categoryId') categoryId: number,
    @Query('fundraiseTypeId') fundraiseTypeId: number,
    @Query('countryId') countryId: number,
  ) {
    return this.campaignService.findAllValid(
      userId,
      email,
      page,
      limit,
      search,
      sort,
      sortBy,
      categoryId,
      fundraiseTypeId,
      countryId,
    );
  }

  @Get('my-campaigns')
  @UseGuards(JwtAuthGuard)
  async findMyCampaigns(
    @GetUser() user: UserExtract,
    @Query('page') page: number,
    @Query('limit') limit: number,
    @Query('status') status: CampaignStatus,
  ) {
    const campaigns = await this.campaignService.findMyCampaigns(
      user.id,
      page,
      limit,
      status,
    );

    return campaigns;
  }

  @Get('calculate-eth-goal')
  calculateEthGoal(@Query('vndAmount') vndAmount: number) {
    return this.campaignService.calculateEthGoal(vndAmount);
  }

  @Get('calculate-goal')
  calculateGoal(
    @Query('vndAmount') vndAmount: number,
    @Query('token') token: string,
  ) {
    return this.campaignService.calculateGoal(vndAmount, token);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.campaignService.findOne(+id);
  }

  @Patch(':id')
  async update(
    @Param('id') id: string,
    @Body() updateCampaignDto: UpdateCampaignDto,
  ) {
    const campaign = await this.campaignService.update(+id, updateCampaignDto);
    return campaign;
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.campaignService.remove(+id);
  }

  @Get(':id/donation-history')
  async getDonationHistory(
    @Param('id') id: string,
    @Query('startDate') startDate?: string,
    @Query('endDate') endDate?: string,
    @Query('groupBy') groupBy: 'day' | 'week' | 'month' = 'day',
  ) {
    return this.campaignService.getDonationHistory(
      +id,
      startDate ? new Date(startDate) : undefined,
      endDate ? new Date(endDate) : undefined,
      groupBy,
    );
  }

  @Post(':id/progress')
  @UseGuards(JwtAuthGuard)
  async addProgress(
    @Param('id') id: string,
    @Body() createProgressDto: CreateCampaignProgressDto,
  ) {
    return this.campaignService.addProgress(+id, createProgressDto);
  }

  @Get(':id/progress')
  async getProgressHistory(@Param('id') id: string) {
    return this.campaignService.getProgressHistory(+id);
  }
}

```

### src/campaign/campaign.service.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-argument */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { Injectable, NotFoundException } from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { CampaignStatus, Prisma } from '@prisma/client';
import { AiService } from 'src/ai/ai.service';
import { DonationService } from 'src/donation/donation.service';
import { CampaignEmailService } from 'src/email/campaign-email.service';
import { PrismaService } from 'src/prisma/prisma.service';
import { MailerService } from '../mailer/mailer.service';
import { CampaignRepo } from './campaign.repository';
import { CreateCampaignDto } from './dto/create-campaign.dto';
import { UpdateCampaignDto } from './dto/update-campaign.dto';
import { CampaignCreatedEvent } from './events/campaign-created.event';
import { CreateCampaignProgressDto } from './dto/create-campaign-progress.dto';

interface CampaignWithRelations {
  id: number;
  title: string;
  description: string;
  status: string;
  name: string;
  user: {
    id: number;
    name: string;
    email: string;
  };
  category?: any;
  country?: any;
  cover?: any;
  images?: any[];
  donations?: any[];
}

@Injectable()
export class CampaignService {
  constructor(
    private readonly campaignRepo: CampaignRepo,
    private readonly mailerService: MailerService,
    private readonly aiService: AiService,
    private readonly donationService: DonationService,
    private readonly eventEmitter: EventEmitter2,
    private readonly prisma: PrismaService,
    private readonly campaignEmailService: CampaignEmailService,
  ) {}

  async create(
    createCampaignDto: CreateCampaignDto & { userId: number; email: string },
  ) {
    try {
      const {
        images,
        userId,
        categoryId,
        countryId,
        coverId,
        fundraiseTypeId,
        email,
        ...rest
      } = createCampaignDto;

      const ethGoal = await this.calculateEthGoal(rest.goal);

      const campaign = await this.campaignRepo.create(
        {
          ...rest,
          user: { connect: { id: userId } },
          category: { connect: { id: categoryId } },
          images: {
            create: images.map((url) => ({ url, type: 'IMAGE' })),
          },
          country: { connect: { id: countryId } },
          cover: { connect: { id: coverId } },
          fundraiseType: { connect: { id: fundraiseTypeId } },
          deadline: new Date(rest.deadline),
          ethGoal,
        },
        {
          user: true,
        },
      );

      this.eventEmitter.emit(
        'campaign.created',
        new CampaignCreatedEvent(campaign.title, email, campaign.id),
      );

      return campaign;
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  findAll(
    userId?: number,
    email?: string,
    status?: CampaignStatus,
    page: number = 1,
    limit: number = 10,
    search?: string,
    sort: 'asc' | 'desc' = 'desc',
    sortBy: string = 'createdAt',
    categoryId?: number,
    fundraiseTypeId?: number,
    countryId?: number,
  ) {
    const where: Prisma.CampaignWhereInput = {
      ...(userId && { userId: Number(userId) }),
      ...(email && { user: { email } }),
      ...(status && { status: status }),
      ...(categoryId && { categoryId: Number(categoryId) }),
      ...(fundraiseTypeId && { fundraiseTypeId: Number(fundraiseTypeId) }),
      ...(countryId && { countryId: Number(countryId) }),
      ...(search && {
        OR: [
          {
            title: {
              contains: search,
              mode: Prisma.QueryMode.insensitive,
            },
          },
          {
            description: {
              contains: search,
              mode: Prisma.QueryMode.insensitive,
            },
          },
        ],
      }),
    };

    const orderBy = {
      [sortBy]: sort,
    };

    return this.campaignRepo.paginate(page, limit, {
      where,
      orderBy,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            image: true,
            address: true,
          },
        },
        category: true,
        country: true,
        cover: true,
        images: true,
        fundraiseType: true,
        // donations: {}
        _count: {
          select: {
            donations: true,
          },
        },
      },
    });
  }

  findAllValid(
    userId?: number,
    email?: string,
    page: number = 1,
    limit: number = 10,
    search?: string,
    sort: 'asc' | 'desc' = 'desc',
    sortBy: string = 'createdAt',
    categoryId?: number,
    fundraiseTypeId?: number,
    countryId?: number,
  ) {
    const where: Prisma.CampaignWhereInput = {
      ...(userId && { userId: Number(userId) }),
      ...(email && { user: { email } }),
      ...{ status: { in: ['ACTIVE', 'FINISHED'] } },
      ...(categoryId && { categoryId: Number(categoryId) }),
      ...(fundraiseTypeId && { fundraiseTypeId: Number(fundraiseTypeId) }),
      ...(countryId && { countryId: Number(countryId) }),
      ...(search && {
        OR: [
          {
            title: {
              contains: search,
              mode: Prisma.QueryMode.insensitive,
            },
          },
          {
            description: {
              contains: search,
              mode: Prisma.QueryMode.insensitive,
            },
          },
        ],
      }),
    };

    const orderBy = {
      [sortBy]: sort,
    };

    return this.campaignRepo.paginate(page, limit, {
      where,
      orderBy,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            image: true,
            address: true,
          },
        },
        category: true,
        country: true,
        cover: true,
        images: true,
        fundraiseType: true,
        // donations: {}
        _count: {
          select: {
            donations: true,
          },
        },
      },
    });
  }

  findMyCampaigns(
    userId: number,
    page: number = 1,
    limit: number = 10,
    status: CampaignStatus,
  ) {
    return this.campaignRepo.paginate(page, limit, {
      where: { userId, ...(status && { status }) },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            image: true,
            address: true,
          },
        },
        category: true,
        country: true,
        cover: true,
        images: true,
        fundraiseType: true,
      },
    });
  }
  findOne(id: number) {
    return this.campaignRepo.findOne(id, {
      category: true,
      country: true,
      cover: true,
      images: true,
      user: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
      donations: {
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
              image: true,
              address: true,
            },
          },
        },
      },
    });
  }

  async update(id: number, updateCampaignDto: UpdateCampaignDto) {
    const { images, ...rest } = updateCampaignDto;

    const data: Prisma.CampaignUpdateInput = {
      ...rest,
      ...(images && images.length > 0
        ? {
            images: {
              connect: images.map((id) => ({ id: Number(id) })),
            },
          }
        : {}),
    };

    if (updateCampaignDto.status === 'FINISHED') {
      const campaign = await this.campaignRepo.findOne(id);
      if (!campaign) {
        throw new Error('Campaign not found');
      }
      const donations =
        await this.donationService.findAllUserDonationByCampaignId(id);
      if (donations.length === 0) {
        throw new Error('No donations found');
      }
      const aiContent = await this.aiService.generateThankYouLetter(
        campaign.title,
      );
      await Promise.all(
        donations.map(async (donation) => {
          if (donation.user?.name || donation.user?.email) {
            try {
              if (
                donation.user.email &&
                aiContent.subject &&
                aiContent.content
              ) {
                await this.mailerService.sendCustomThankYouEmail(
                  donation.user.email,
                  aiContent.subject,
                  aiContent.content,
                );
              }
            } catch (error) {
              console.error('Failed to generate thank you letter:', error);
            }
          }
        }),
      );
    }

    return this.campaignRepo.update(id, data);
  }

  remove(id: number) {
    return this.campaignRepo.delete(id);
  }

  async calculateEthGoal(vndAmount: number): Promise<number> {
    const ethPrice = await this.getEthPrice();
    return vndAmount / ethPrice;
  }

  async calculateGoal(vndAmount: number, token: string): Promise<number> {
    const tokenPrice = await this.getTokenPrice(token);
    return vndAmount / tokenPrice;
  }

  async getEthPrice(): Promise<number> {
    try {
      const response = await fetch(
        'https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=vnd',
      );
      const data = await response.json();

      return data.ethereum.vnd;
    } catch (error) {
      console.error('Failed to fetch ETH price:', error);
      throw new Error('Could not fetch ETH price');
    }
  }

  async getTokenPrice(token: string): Promise<number> {
    try {
      const response = await fetch(
        `https://api.coingecko.com/api/v3/simple/price?ids=${token}&vs_currencies=vnd`,
      );
      const data = await response.json();
      if (!data[token] || !data[token].vnd) {
        throw new Error(`Token ${token} not found`);
      }
      return data[token].vnd;
    } catch (error) {
      console.error(`Failed to fetch ${token} price:`, error);
      throw new Error(`Could not fetch ${token} price`);
    }
  }

  async getDonationHistory(
    campaignId: number,
    startDate?: Date,
    endDate?: Date,
    groupBy: 'day' | 'week' | 'month' = 'day',
  ) {
    let grouping;
    switch (groupBy) {
      case 'week':
        grouping = `date_trunc('week', "donatedAt")`;
        break;
      case 'month':
        grouping = `date_trunc('month', "donatedAt")`;
        break;
      default: // day
        grouping = `date_trunc('day', "donatedAt")`;
    }

    const donationHistory = await this.prisma.$queryRaw<
      { date: string; count: number; total_amount: number }[]
    >`
      SELECT 
        ${Prisma.raw(grouping)} as date,
        COUNT(*)::int as count,
        SUM(amount)::float as total_amount
      FROM "Donation"
      WHERE "campaignId" = ${campaignId}
        ${startDate ? Prisma.sql`AND "donatedAt" >= ${startDate}` : Prisma.empty}
        ${endDate ? Prisma.sql`AND "donatedAt" <= ${endDate}` : Prisma.empty}
      GROUP BY ${Prisma.raw(grouping)}
      ORDER BY ${Prisma.raw(grouping)} ASC
    `;

    // Xử lý kết quả để điền các ngày thiếu
    const result = this.fillMissingDates(
      donationHistory,
      startDate || new Date(donationHistory[0]?.date),
      endDate || new Date(),
      groupBy,
    );

    return {
      data: result,
      summary: {
        totalDonations: result.reduce((sum, item) => sum + item.count, 0),
        totalAmount: result.reduce((sum, item) => sum + item.total_amount, 0),
        averageAmount:
          result.reduce((sum, item) => sum + item.total_amount, 0) /
            result.reduce((sum, item) => sum + item.count, 0) || 0,
      },
    };
  }

  private fillMissingDates(
    data: any[],
    startDate: Date,
    endDate: Date,
    groupBy: 'day' | 'week' | 'month',
  ) {
    const result: { date: Date; count: number; total_amount: number }[] = [];
    const current = new Date(startDate);
    const dataMap = new Map(
      data.map((item) => [new Date(item.date).getTime(), item]),
    );

    while (current <= endDate) {
      const time = current.getTime();
      const existingData = dataMap.get(time);

      result.push({
        date: new Date(time),
        count: existingData?.count || 0,
        total_amount: existingData?.total_amount || 0,
      });

      switch (groupBy) {
        case 'week':
          current.setDate(current.getDate() + 7);
          break;
        case 'month':
          current.setMonth(current.getMonth() + 1);
          break;
        default: // day
          current.setDate(current.getDate() + 1);
      }
    }

    return result;
  }

  async approveCampaign(campaignId: number) {
    const campaign = (await this.findOne(
      campaignId,
    )) as unknown as CampaignWithRelations;
    if (!campaign) {
      throw new Error('Campaign not found');
    }
    if (!campaign) {
      throw new Error('Campaign not found');
    }
    campaign.status = 'APPROVED';
    await this.campaignRepo.update(campaignId, {
      status: 'APPROVED',
    });

    await this.campaignEmailService.sendCampaignApprovalEmail(
      campaign.user.email,
      campaign.name,
    );

    return campaign;
  }

  async rejectCampaign(campaignId: number, reason?: string) {
    const campaign = (await this.findOne(
      campaignId,
    )) as unknown as CampaignWithRelations;
    if (!campaign) {
      throw new Error('Campaign not found');
    }

    campaign.status = 'REJECTED';
    await this.campaignRepo.update(campaignId, {
      status: 'REJECTED',
    });

    if (!campaign.user?.email) {
      throw new Error('Campaign user email not found');
    }

    await this.campaignEmailService.sendCampaignRejectionEmail(
      campaign.user.email,
      campaign.name,
      reason,
    );

    return campaign;
  }

  async addProgress(
    campaignId: number,
    createProgressDto: CreateCampaignProgressDto,
  ) {
    // Check if campaign exists
    const campaign = await this.findOne(campaignId);
    if (!campaign) {
      throw new NotFoundException('Campaign not found');
    }

    // Create progress entry
    const progress = await this.prisma.campaignProgress.create({
      data: {
        ...createProgressDto,
        campaign: {
          connect: { id: campaignId },
        },
      },
      include: {
        campaign: {
          include: {
            user: true,
          },
        },
      },
    });

    // Get all donors for notification
    const donors =
      await this.donationService.findAllUserDonationByCampaignId(campaignId);

    // Notify all donors about the update
    await Promise.all(
      donors.map(async (donation) => {
        if (donation.user?.email) {
          await this.mailerService.sendMail(
            donation.user.email,
            `Cập nhật mới từ chiến dịch: ${campaign.title}`,
            'campaign-progress-update',
            {
              campaignTitle: campaign.title,
              progressTitle: progress.title,
              progressDescription: progress.description,
              images: progress.images,
              documents: progress.documents,
              date: progress.createdAt,
            },
          );
        }
      }),
    );

    return progress;
  }

  async getProgressHistory(campaignId: number) {
    const progresses = await this.prisma.campaignProgress.findMany({
      where: {
        campaignId,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return progresses;
  }
}

```

### src/campaign/campaign.module.ts
```ts
import { Module, forwardRef } from '@nestjs/common';
import { EventEmitterModule } from '@nestjs/event-emitter';
import { CampaignController } from './campaign.controller';
import { CampaignService } from './campaign.service';
import { CampaignRepo } from './campaign.repository';
import { MailerModule } from '../mailer/mailer.module';
import { AiModule } from '../ai/ai.module';
import { DonationModule } from '../donation/donation.module';
import { UsersModule } from '../users/users.module';
import { CampaignCreatedListener } from './listeners/campaign-created.listener';
import { CampaignEmailService } from 'src/email/campaign-email.service';

@Module({
  imports: [
    EventEmitterModule.forRoot(),
    MailerModule,
    forwardRef(() => AiModule), // Add forwardRef here
    UsersModule,
    forwardRef(() => DonationModule),
  ],
  controllers: [CampaignController],
  providers: [
    CampaignService,
    CampaignRepo,
    CampaignCreatedListener,
    CampaignEmailService,
  ],
  exports: [CampaignService],
})
export class CampaignModule {}

```

### src/campaign/entities/campaign.entity.ts
```ts
export class Campaign {
  id: number;
  title: string;
  description?: string;
  startDate?: Date;
  endDate?: Date;
  status?: string;
}

```

### src/campaign/listeners/campaign-created.listener.ts
```ts
import { Injectable } from '@nestjs/common';
import { OnEvent } from '@nestjs/event-emitter';
import { MailerService } from '../../mailer/mailer.service';
import { UsersService } from '../../users/users.service';
import { CampaignCreatedEvent } from '../events/campaign-created.event';

@Injectable()
export class CampaignCreatedListener {
  constructor(
    private readonly mailerService: MailerService,
    private readonly userService: UsersService,
  ) {}

  @OnEvent('campaign.created', { async: true })
  async handleCampaignCreatedEvent(event: CampaignCreatedEvent) {
    try {
      await this.mailerService.sendCampaignCreated(
        event.userEmail,
        event.campaignTitle,
        event.campaignId,
      );

      const admins = await this.userService.findAllByRole(1);
      await Promise.all(
        admins.map((admin) =>
          this.mailerService.sendToAdminCampaignCreated(
            admin.email,
            event.campaignTitle,
          ),
        ),
      );
    } catch (error) {
      console.error('Failed to send campaign created emails:', error);
    }
  }
}

```

### src/campaign/events/campaign-created.event.ts
```ts
export class CampaignCreatedEvent {
  constructor(
    public readonly campaignTitle: string,
    public readonly userEmail: string,
    public readonly campaignId: number,
  ) {}
}

export class CampaignCreatedSuccessEvent {
  constructor(
    public readonly campaignTitle: string,
    public readonly userEmail: string,
    public readonly campaignId: number,
  ) {}
}

```

### src/campaign/dto/update-campaign.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateCampaignDto } from './create-campaign.dto';

export class UpdateCampaignDto extends PartialType(CreateCampaignDto) {}

```

### src/campaign/dto/create-campaign.dto.ts
```ts
// src/campaign/dto/create-campaign.dto.ts
import { CampaignStatus } from '@prisma/client';
import {
  IsArray,
  IsBoolean,
  IsDateString,
  IsEnum,
  IsInt,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
} from 'class-validator';

export class CreateCampaignDto {
  @IsString()
  @IsNotEmpty()
  title: string;

  @IsString()
  description: string;

  @IsNumber()
  @IsNotEmpty()
  goal: number;

  @IsDateString()
  @IsNotEmpty()
  deadline: string;

  @IsNumber()
  @IsOptional()
  totalDonated: number;

  @IsBoolean()
  @IsOptional()
  isClosed: boolean;

  @IsBoolean()
  @IsOptional()
  isNoLimit: boolean;

  @IsInt()
  @IsNotEmpty()
  categoryId: number;

  @IsInt()
  @IsNotEmpty()
  countryId: number;

  @IsArray()
  @IsNotEmpty()
  images: string[];

  @IsOptional()
  @IsEnum(CampaignStatus)
  status?: CampaignStatus;

  @IsInt()
  @IsNotEmpty()
  fundraiseTypeId: number;

  @IsInt()
  @IsNotEmpty()
  coverId: number;

  @IsInt()
  @IsOptional()
  chainCampaignId: number;

  @IsString()
  @IsOptional()
  txHash: string;

  @IsString()
  @IsOptional()
  creatorAddress: string;

  @IsString()
  @IsOptional()
  tokenAddress: string;

  @IsString()
  @IsOptional()
  tokenGoal: string;

  @IsString()
  @IsOptional()
  tokenSymbol: string;

  @IsInt()
  @IsOptional()
  tokenDecimals: number;
}

```

### src/campaign/dto/create-campaign-progress.dto.ts
```ts
import { IsString, IsNotEmpty, IsArray, IsOptional } from 'class-validator';

export class CreateCampaignProgressDto {
  @IsString()
  @IsNotEmpty()
  title: string;

  @IsString()
  @IsNotEmpty()
  description: string;

  @IsArray()
  @IsNotEmpty()
  images: string[];

  @IsArray()
  @IsOptional()
  documents?: string[];
}

```

### src/campaign/use-cases/create-campaign-with-images.use-case.ts
```ts
import { Injectable } from '@nestjs/common';
import { CampaignService } from '../campaign.service';
import { ImageService } from 'src/image/image.service';
import { CreateCampaignDto } from '../dto/create-campaign.dto';

@Injectable()
export class CreateCampaignWithImagesUseCase {
  constructor(
    private readonly campaignService: CampaignService,
    private readonly imageService: ImageService,
  ) {}

  async execute(dto: CreateCampaignDto) {
    // const campaign = await this.campaignService.create(dto);
    // const imageCreatePromises = dto.images.map((url) =>
    //   this.imageService.create({
    //     url,
    //     campaignId: campaign.id,
    //     type: 'IMAGE',
    //   }),
    // );
    // await Promise.all(imageCreatePromises);
    // return campaign;
  }
}

```

### test/app.e2e-spec.ts
```ts
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { App } from 'supertest/types';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication<App>;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});

```
