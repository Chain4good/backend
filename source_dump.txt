# ==================================================
# Path: /home/tommy/Documents/charity/backend
# Detected tech: angular, docker, gitlab_ci, javascript, python, react, typescript
# ==================================================

## DIRECTORY STRUCTURE
```
backend/
├── .git/
├── .github/
├── .vscode/
├── dist/
├── node_modules/
├── prisma/
│   ├── migrations/
│   │   ├── 20250418033523_init/
│   │   │   └── migration.sql
│   │   ├── 20250523044952_change_name_fundraise/
│   │   │   └── migration.sql
│   │   ├── 20250526081123_add_table_report_and_status_campain_col/
│   │   │   └── migration.sql
│   │   ├── 20250526102518_update_name_enum/
│   │   │   └── migration.sql
│   │   ├── 20250528024446_update_goal_col/
│   │   │   └── migration.sql
│   │   ├── 20250528152051_add_new_col_campaign_model/
│   │   │   └── migration.sql
│   │   ├── 20250528152543_add_new_col_campaign_model/
│   │   │   └── migration.sql
│   │   ├── 20250530031841_add_new_col_for_donation_model/
│   │   │   └── migration.sql
│   │   ├── 20250530084947_add_comment_system/
│   │   │   └── migration.sql
│   │   ├── 20250530110832_add_refresh_tokens/
│   │   │   └── migration.sql
│   │   ├── 20250530120806_add_cover_col_user/
│   │   │   └── migration.sql
│   │   └── migration_lock.toml
│   └── schema.prisma
├── src/
│   ├── ai/
│   │   ├── dto/
│   │   │   └── analyze-campaign.dto.ts
│   │   ├── ai.controller.ts
│   │   ├── ai.module.ts
│   │   └── ai.service.ts
│   ├── auth/
│   │   ├── decorators/
│   │   │   └── auth.decorators.ts
│   │   ├── dtos/
│   │   │   ├── user-login.dto.ts
│   │   │   └── user-register.dto.ts
│   │   ├── guards/
│   │   │   ├── jwt-auth.guard.ts
│   │   │   └── local-auth.guard.ts
│   │   ├── strategies/
│   │   │   ├── jwt.strategy.ts
│   │   │   └── local.strategy.ts
│   │   ├── auth.controller.ts
│   │   ├── auth.module.ts
│   │   ├── auth.service.ts
│   │   └── refresh-token.service.ts
│   ├── campaign/
│   │   ├── dto/
│   │   │   ├── create-campaign.dto.ts
│   │   │   └── update-campaign.dto.ts
│   │   ├── entities/
│   │   │   └── campaign.entity.ts
│   │   ├── use-cases/
│   │   │   └── create-campaign-with-images.use-case.ts
│   │   ├── campaign.controller.ts
│   │   ├── campaign.module.ts
│   │   ├── campaign.repository.ts
│   │   └── campaign.service.ts
│   ├── category/
│   │   ├── dto/
│   │   │   ├── create-category.dto.ts
│   │   │   └── update-category.dto.ts
│   │   ├── entities/
│   │   │   └── category.entity.ts
│   │   ├── category.controller.ts
│   │   ├── category.module.ts
│   │   ├── category.repository.ts
│   │   └── category.service.ts
│   ├── comment/
│   │   ├── dto/
│   │   │   └── create-comment.dto.ts
│   │   ├── comment.controller.ts
│   │   ├── comment.module.ts
│   │   ├── comment.repository.ts
│   │   └── comment.service.ts
│   ├── common/
│   │   ├── filters/
│   │   │   └── all-exceptions.filter.ts
│   │   └── base.repository.ts
│   ├── config/
│   │   └── mailer.config.ts
│   ├── country/
│   │   ├── dto/
│   │   │   ├── create-country.dto.ts
│   │   │   └── update-country.dto.ts
│   │   ├── entities/
│   │   │   └── country.entity.ts
│   │   ├── country.controller.ts
│   │   ├── country.module.ts
│   │   ├── country.repository.ts
│   │   └── country.service.ts
│   ├── cover/
│   │   ├── dto/
│   │   │   ├── create-cover.dto.ts
│   │   │   └── update-cover.dto.ts
│   │   ├── entities/
│   │   │   └── cover.entity.ts
│   │   ├── cover.controller.ts
│   │   ├── cover.module.ts
│   │   ├── cover.repository.ts
│   │   └── cover.service.ts
│   ├── donation/
│   │   ├── dto/
│   │   │   ├── create-donation.dto.ts
│   │   │   └── update-donation.dto.ts
│   │   ├── entities/
│   │   │   └── donation.entity.ts
│   │   ├── donation.controller.ts
│   │   ├── donation.module.ts
│   │   ├── donation.repository.ts
│   │   └── donation.service.ts
│   ├── fundraise-type/
│   │   ├── dto/
│   │   │   ├── create-fundraise-type.dto.ts
│   │   │   └── update-fundraise-type.dto.ts
│   │   ├── entities/
│   │   │   └── fundraise-type.entity.ts
│   │   ├── fundraise-type.controller.ts
│   │   ├── fundraise-type.module.ts
│   │   ├── fundraise-type.repository.ts
│   │   └── fundraise-type.service.ts
│   ├── image/
│   │   ├── dto/
│   │   │   ├── create-image.dto.ts
│   │   │   └── update-image.dto.ts
│   │   ├── entities/
│   │   │   └── image.entity.ts
│   │   ├── image.controller.ts
│   │   ├── image.module.ts
│   │   ├── image.repository.ts
│   │   └── image.service.ts
│   ├── mailer/
│   │   ├── mailer.module.ts
│   │   └── mailer.service.ts
│   ├── prisma/
│   │   ├── prisma.module.ts
│   │   └── prisma.service.ts
│   ├── providers/
│   ├── templates/
│   │   └── campaign-created.hbs
│   ├── upload/
│   │   ├── cloudinary.provider.ts
│   │   ├── upload.controller.ts
│   │   ├── upload.module.ts
│   │   └── upload.service.ts
│   ├── users/
│   │   ├── dto/
│   │   │   └── update-user.dto.ts
│   │   ├── users.controller.ts
│   │   ├── users.module.ts
│   │   └── users.service.ts
│   ├── utils/
│   │   └── string.ts
│   ├── app.controller.spec.ts
│   ├── app.controller.ts
│   ├── app.module.ts
│   ├── app.service.ts
│   └── main.ts
├── test/
│   ├── app.e2e-spec.ts
│   └── jest-e2e.json
├── uploads/
├── .dockerignore
├── .env
├── .gitignore
├── .prettierrc
├── Dockerfile
├── README.md
├── docker-compose.yml
├── eslint.config.mjs
├── nest-cli.json
├── package-lock.json
├── package.json
├── source_dump.txt
├── tsconfig.build.json
└── tsconfig.json
```

## FILE CONTENTS

### docker-compose.yml
```yml
version: '3.8'

services:
  api:
    container_name: charity-api
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - '3000:3000'
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${DATABASE_URL}
      # Add other environment variables
    restart: always
    networks:
      - charity-network

networks:
  charity-network:
    driver: bridge

```

### eslint.config.mjs
```mjs
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'warn',
      '@typescript-eslint/no-unsafe-argument': 'warn'
    },
  },
);
```

### src/app.controller.ts
```ts
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

```

### src/app.module.ts
```ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PrismaModule } from './prisma/prisma.module';
import { UsersModule } from './users/users.module';
import { AuthModule } from './auth/auth.module';
import { CampaignModule } from './campaign/campaign.module';
import { CountryModule } from './country/country.module';
import { FundraiseTypeModule } from './fundraise-type/fundraise-type.module';
import { CoverModule } from './cover/cover.module';
import { ImageModule } from './image/image.module';
import { UploadModule } from './upload/upload.module';
import { CategoryModule } from './category/category.module';
import { MailerModule } from './mailer/mailer.module';
import { DonationModule } from './donation/donation.module';
import { CommentModule } from './comment/comment.module';
import { AiModule } from './ai/ai.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    PrismaModule,
    UsersModule,
    AuthModule,
    CampaignModule,
    FundraiseTypeModule,
    CoverModule,
    ImageModule,
    UploadModule,
    CategoryModule,
    CountryModule,
    MailerModule,
    DonationModule,
    CommentModule,
    AiModule,
    AiModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

```

### src/app.service.ts
```ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

```

### src/app.controller.spec.ts
```ts
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});

```

### src/main.ts
```ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { AllExceptionsFilter } from './common/filters/all-exceptions.filter';
import * as cookieParser from 'cookie-parser';
import { ValidationPipe } from '@nestjs/common';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());
  app.useGlobalFilters(new AllExceptionsFilter());

  app.enableCors({
    origin: [
      'http://localhost:5173',
      'http://127.0.0.1:5173',
      'http://192.168.1.26:5173',
      'http://185.200.65.252',
      // Add your production domain when deploying
    ],
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
  });

  // eslint-disable-next-line @typescript-eslint/no-unsafe-call
  app.use(cookieParser());
  await app.listen(process.env.PORT ?? 3000, '0.0.0.0'); // Listen on all network interfaces
}
void bootstrap();

```

### src/auth/auth.controller.ts
```ts
import {
  Body,
  Controller,
  Get,
  Post,
  Res,
  UseGuards,
  Req,
  UnauthorizedException,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { GetUser } from './decorators/auth.decorators';
import { JwtAuthGuard } from './guards/jwt-auth.guard';
import { LocalAuthGuard } from './guards/local-auth.guard';
import { UserRegisterDTO } from './dtos/user-register.dto';
import { Response, Request } from 'express';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @UseGuards(LocalAuthGuard)
  @Post('login')
  async login(
    @GetUser() userReq: { email: string; id: number },
    @Res({ passthrough: true }) res: Response,
  ) {
    const { user, access_token, refresh_token } =
      await this.authService.login(userReq);

    // Set access token in HTTP-only cookie
    res.cookie('access_token', access_token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      path: '/',
      // maxAge: 1 * 60 * 60 * 1000, // 1 hour
      maxAge: 30 * 1000, // 30 second
    });

    res.cookie('refresh_token', refresh_token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      path: '/',
      maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
    });

    return user;
  }

  @Post('refresh')
  async refresh(
    @Req() req: Request,
    @Res({ passthrough: true }) res: Response,
  ) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
    const refreshToken = req.cookies['refresh_token'];
    if (!refreshToken) {
      throw new UnauthorizedException('Refresh token not found');
    }

    const { access_token } =
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      await this.authService.refreshAccessToken(refreshToken);

    res.cookie('access_token', access_token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      path: '/',
      maxAge: 1 * 60 * 60 * 1000, // 1 hour
    });

    return { message: 'Token refreshed successfully' };
  }

  @UseGuards(JwtAuthGuard)
  @Post('logout')
  async logout(@Req() req: Request, @Res({ passthrough: true }) res: Response) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
    const refreshToken = req.cookies['refresh_token'];
    if (refreshToken) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      await this.authService.logout(refreshToken);
    }

    res.clearCookie('access_token');
    res.clearCookie('refresh_token');

    return { message: 'Logged out successfully' };
  }

  @Post('register')
  async register(
    @Body()
    userRegisterDto: UserRegisterDTO,
  ) {
    return this.authService.register(userRegisterDto);
  }

  @UseGuards(JwtAuthGuard)
  @Get('profile')
  getProfile(@GetUser() user: { id: number; email: string }) {
    const existingUser = this.authService.getMe(user.id);
    return existingUser;
  }
}

```

### src/auth/auth.module.ts
```ts
import { Module } from '@nestjs/common';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { JwtStrategy } from './strategies/jwt.strategy';
import { LocalStrategy } from './strategies/local.strategy';
import { UsersModule } from '../users/users.module';
import { RefreshTokenService } from './refresh-token.service';

@Module({
  imports: [
    UsersModule,
    PassportModule,
    JwtModule.register({
      secret: process.env.JWT_SECRET || 'secr3t',
      signOptions: { expiresIn: '1h' }, // Access token expires in 1 hour
    }),
  ],
  providers: [AuthService, LocalStrategy, JwtStrategy, RefreshTokenService],
  controllers: [AuthController],
  exports: [AuthService],
})
export class AuthModule {}

```

### src/auth/refresh-token.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class RefreshTokenService {
  constructor(private prisma: PrismaService) {}

  async createRefreshToken(userId: number): Promise<string> {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call
    const token = uuidv4();
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 7); // Token expires in 7 days

    await this.prisma.refreshToken.create({
      data: {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        token,
        userId,
        expiresAt,
      },
    });

    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return token;
  }

  async validateRefreshToken(token: string) {
    const refreshToken = await this.prisma.refreshToken.findUnique({
      where: { token },
      include: { user: true },
    });

    if (!refreshToken) return null;
    if (new Date() > refreshToken.expiresAt) {
      await this.prisma.refreshToken.delete({ where: { id: refreshToken.id } });
      return null;
    }

    return refreshToken.user;
  }

  async deleteRefreshToken(token: string) {
    await this.prisma.refreshToken.delete({ where: { token } });
  }
}

```

### src/auth/auth.service.ts
```ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import * as bcrypt from 'bcrypt';
import { UsersService } from '../users/users.service';
import { UserRegisterDTO } from './dtos/user-register.dto';
import { RefreshTokenService } from './refresh-token.service';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService,
    private refreshTokenService: RefreshTokenService,
  ) {}

  async validateUser(email: string, password: string): Promise<any> {
    const user = await this.usersService.findByEmail(email);
    if (user && (await bcrypt.compare(password, user.password))) {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const { password, ...result } = user;
      return result;
    }
    return null;
  }

  async login(user: { email: string; id: number }) {
    const payload = { email: user.email, sub: user.id };
    const accessToken = this.jwtService.sign(payload);

    const refreshToken = await this.refreshTokenService.createRefreshToken(
      user.id,
    );

    return {
      user,
      access_token: accessToken,
      refresh_token: refreshToken,
    };
  }

  async refreshAccessToken(refreshToken: string) {
    const user =
      await this.refreshTokenService.validateRefreshToken(refreshToken);
    if (!user) {
      throw new UnauthorizedException('Invalid refresh token');
    }

    const payload = { email: user.email, sub: user.id };
    const accessToken = this.jwtService.sign(payload);

    return {
      access_token: accessToken,
    };
  }

  async logout(refreshToken: string) {
    await this.refreshTokenService.deleteRefreshToken(refreshToken);
  }

  async register(data: UserRegisterDTO) {
    const hashedPassword = await bcrypt.hash(data.password, 10);
    const user = await this.usersService.create({
      ...data,
      password: hashedPassword,
    });
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { password: _, ...result } = user;
    return result;
  }

  async getMe(id: number) {
    const user = await this.usersService.findById(id);
    if (!user) {
      throw new Error('User not found');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { password, ...result } = user;
    return result;
  }
}

```

### src/auth/dtos/user-register.dto.ts
```ts
import { IsEmail, IsNotEmpty, IsOptional, IsString } from 'class-validator';

export class UserRegisterDTO {
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @IsString()
  @IsNotEmpty()
  password: string;

  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsNotEmpty()
  address: string;

  @IsString()
  @IsOptional()
  cover?: string;

  @IsString()
  @IsOptional()
  image?: string;

  @IsString()
  @IsOptional()
  bio?: string;

  @IsString()
  @IsOptional()
  phoneNumber?: string;
}

```

### src/auth/dtos/user-login.dto.ts
```ts
import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class UserLoginDto {
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @IsString()
  @IsNotEmpty()
  password: string;
}

```

### src/auth/decorators/auth.decorators.ts
```ts
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { Request } from 'express';

export interface UserExtract {
  id: number;
  email: string;
}

export const GetUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request: Request = ctx.switchToHttp().getRequest();
    return request.user as UserExtract;
  },
);

```

### src/auth/strategies/jwt.strategy.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/require-await */
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';
import { Request } from 'express';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromExtractors([
        (request: Request) => {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          return request?.cookies?.access_token;
        },
      ]),
      ignoreExpiration: false,
      secretOrKey: process.env.JWT_SECRET || 'secr3t',
    });
  }

  async validate(payload: any) {
    return { id: payload.sub, email: payload.email };
  }
}

```

### src/auth/strategies/local.strategy.ts
```ts
import { Strategy } from 'passport-local';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { AuthService } from '../auth.service';
import { User } from '@prisma/client';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super({ usernameField: 'email' });
  }

  async validate(email: string, password: string): Promise<any> {
    const user = await this.authService.validateUser(email, password);
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }
    return user;
  }
}

```

### src/auth/guards/jwt-auth.guard.ts
```ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}

```

### src/auth/guards/local-auth.guard.ts
```ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {}

```

### src/donation/donation.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Donation, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class DonationRepo extends BaseRepository<
  Donation,
  Prisma.DonationWhereInput,
  Prisma.DonationCreateInput,
  Prisma.DonationUpdateInput,
  Prisma.DonationOrderByWithRelationInput,
  Prisma.DonationInclude
> {
  protected readonly modelName = 'Donation' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/donation/donation.module.ts
```ts
import { Module } from '@nestjs/common';
import { DonationService } from './donation.service';
import { DonationController } from './donation.controller';
import { DonationRepo } from './donation.repository';

@Module({
  controllers: [DonationController],
  providers: [DonationService, DonationRepo],
})
export class DonationModule {}

```

### src/donation/donation.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
} from '@nestjs/common';
import { DonationService } from './donation.service';
import { CreateDonationDto } from './dto/create-donation.dto';
import { UpdateDonationDto } from './dto/update-donation.dto';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { GetUser, UserExtract } from 'src/auth/decorators/auth.decorators';

@Controller('donations')
export class DonationController {
  constructor(private readonly donationService: DonationService) {}

  @Post()
  @UseGuards(JwtAuthGuard)
  create(
    @Body() createDonationDto: CreateDonationDto,
    @GetUser() user: UserExtract,
  ) {
    return this.donationService.create({
      ...createDonationDto,
      userId: user.id,
    });
  }

  @Get()
  findAll() {
    return this.donationService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.donationService.findOne(+id);
  }

  @Patch(':id')
  update(
    @Param('id') id: string,
    @Body() updateDonationDto: UpdateDonationDto,
  ) {
    return this.donationService.update(+id, updateDonationDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.donationService.remove(+id);
  }
}

```

### src/donation/donation.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { CreateDonationDto } from './dto/create-donation.dto';
import { UpdateDonationDto } from './dto/update-donation.dto';
import { DonationRepo } from './donation.repository';

@Injectable()
export class DonationService {
  constructor(private readonly donationRepo: DonationRepo) {}

  create(createDonationDto: CreateDonationDto & { userId: number }) {
    const { userId, campaignId, ...rest } = createDonationDto;

    return this.donationRepo.create({
      ...rest,
      user: {
        connect: { id: userId },
      },
      campaign: {
        connect: { id: campaignId },
      },
    });
  }

  findAll() {
    return this.donationRepo.findAll();
  }

  findOne(id: number) {
    return this.donationRepo.findOne(id);
  }

  update(id: number, updateDonationDto: UpdateDonationDto) {
    return this.donationRepo.update(id, updateDonationDto);
  }

  remove(id: number) {
    return this.donationRepo.delete(id);
  }
}

```

### src/donation/entities/donation.entity.ts
```ts
export class Donation {}

```

### src/donation/dto/update-donation.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateDonationDto } from './create-donation.dto';

export class UpdateDonationDto extends PartialType(CreateDonationDto) {}

```

### src/donation/dto/create-donation.dto.ts
```ts
import {
  IsInt,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
} from 'class-validator';

export class CreateDonationDto {
  @IsNumber()
  @IsNotEmpty()
  amount: number;

  @IsInt()
  @IsNotEmpty()
  campaignId: number;

  @IsInt()
  @IsOptional()
  onChainDonatedId?: number;

  @IsString()
  @IsOptional()
  txHash?: string;

  @IsString()
  @IsOptional()
  address?: string;
}

```

### src/comment/comment.module.ts
```ts
import { Module } from '@nestjs/common';
import { CommentService } from './comment.service';
import { CommentController } from './comment.controller';
import { CommentRepo } from './comment.repository';

@Module({
  controllers: [CommentController],
  providers: [CommentService, CommentRepo],
})
export class CommentModule {}

```

### src/comment/comment.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Comment, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class CommentRepo extends BaseRepository<
  Comment,
  Prisma.CommentWhereInput,
  Prisma.CommentCreateInput,
  Prisma.CommentUpdateInput,
  Prisma.CommentOrderByWithRelationInput,
  Prisma.CommentInclude
> {
  protected readonly modelName = 'Comment' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/comment/comment.controller.ts
```ts
import {
  Body,
  Controller,
  Get,
  Param,
  ParseIntPipe,
  Post,
  UseGuards,
} from '@nestjs/common';
import { CommentService } from './comment.service';
import { CreateCommentDto } from './dto/create-comment.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { GetUser } from '../auth/decorators/auth.decorators';

@Controller('comments')
export class CommentController {
  constructor(private readonly commentService: CommentService) {}

  @UseGuards(JwtAuthGuard)
  @Post()
  create(
    @Body() createCommentDto: CreateCommentDto,
    @GetUser() user: { id: number },
  ) {
    return this.commentService.create({
      ...createCommentDto,
      userId: user.id,
    });
  }

  @Get('campaign/:campaignId')
  findByCampaign(@Param('campaignId', ParseIntPipe) campaignId: number) {
    return this.commentService.findByCampaign(campaignId);
  }

  @UseGuards(JwtAuthGuard)
  @Post(':id/like')
  toggleLike(
    @Param('id', ParseIntPipe) id: number,
    @GetUser() user: { id: number },
  ) {
    return this.commentService.toggleLike(id, user.id);
  }
}

```

### src/comment/comment.service.ts
```ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { CommentRepo } from './comment.repository';
import { CreateCommentDto } from './dto/create-comment.dto';

@Injectable()
export class CommentService {
  constructor(private readonly commentRepo: CommentRepo) {}

  async create(createCommentDto: CreateCommentDto & { userId: number }) {
    const { userId, campaignId, parentId, ...rest } = createCommentDto;

    if (parentId) {
      const parentComment = await this.commentRepo.findOne(parentId);
      if (!parentComment) {
        throw new NotFoundException('Parent comment not found');
      }
    }

    return this.commentRepo.create({
      ...rest,
      user: { connect: { id: userId } },
      campaign: { connect: { id: campaignId } },
      ...(parentId && { parent: { connect: { id: parentId } } }),
    });
  }

  async findByCampaign(campaignId: number) {
    return this.commentRepo.findBy(
      { campaignId },
      {
        user: {
          select: {
            id: true,
            name: true,
            image: true,
          },
        },
        replies: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                image: true,
              },
            },
            Like: {
              select: {
                userId: true,
              },
            },
            _count: {
              select: {
                Like: true,
              },
            },
          },
        },
        Like: {
          select: {
            userId: true,
          },
        },
        _count: {
          select: {
            Like: true,
          },
        },
      },
    );
  }

  async toggleLike(commentId: number, userId: number) {
    // const existingLike = await this.commentRepo.prisma.like.findUnique({
    //   where: {
    //     userId_commentId: {
    //       userId,
    //       commentId,
    //     },
    //   },
    // });
    // if (existingLike) {
    //   // Unlike
    //   await this.commentRepo.prisma.like.delete({
    //     where: {
    //       userId_commentId: {
    //         userId,
    //         commentId,
    //       },
    //     },
    //   });
    //   return { liked: false };
    // } else {
    //   // Like
    //   await this.commentRepo.prisma.like.create({
    //     data: {
    //       user: { connect: { id: userId } },
    //       comment: { connect: { id: commentId } },
    //     },
    //   });
    //   return { liked: true };
    // }
  }
}

```

### src/comment/dto/create-comment.dto.ts
```ts
import { IsNotEmpty, IsNumber, IsOptional, IsString } from 'class-validator';

export class CreateCommentDto {
  @IsString()
  @IsNotEmpty()
  content: string;

  @IsNumber()
  @IsNotEmpty()
  campaignId: number;

  @IsNumber()
  @IsOptional()
  parentId?: number;
}

```

### src/cover/cover.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { CoverService } from './cover.service';
import { CreateCoverDto } from './dto/create-cover.dto';
import { UpdateCoverDto } from './dto/update-cover.dto';

@Controller('covers')
export class CoverController {
  constructor(private readonly coverService: CoverService) {}

  @Post()
  create(@Body() createCoverDto: CreateCoverDto) {
    return this.coverService.create(createCoverDto);
  }

  @Get()
  findAll() {
    return this.coverService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.coverService.findOne(+id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCoverDto: UpdateCoverDto) {
    return this.coverService.update(+id, updateCoverDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.coverService.remove(+id);
  }
}

```

### src/cover/cover.module.ts
```ts
import { Module } from '@nestjs/common';
import { CoverService } from './cover.service';
import { CoverController } from './cover.controller';
import { CoverRepo } from './cover.repository';

@Module({
  controllers: [CoverController],
  providers: [CoverService, CoverRepo],
})
export class CoverModule {}

```

### src/cover/cover.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { CreateCoverDto } from './dto/create-cover.dto';
import { UpdateCoverDto } from './dto/update-cover.dto';
import { CoverRepo } from './cover.repository';

@Injectable()
export class CoverService {
  constructor(private readonly coverRepo: CoverRepo) {}
  create(createCoverDto: CreateCoverDto) {
    return this.coverRepo.create(createCoverDto);
  }

  findAll() {
    return this.coverRepo.findAll();
  }

  findOne(id: number) {
    return this.coverRepo.findOne(id);
  }

  update(id: number, updateCoverDto: UpdateCoverDto) {
    return this.coverRepo.update(id, updateCoverDto);
  }

  remove(id: number) {
    return this.coverRepo.delete(id);
  }
}

```

### src/cover/cover.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Cover, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class CoverRepo extends BaseRepository<
  Cover,
  Prisma.CoverWhereInput,
  Prisma.CoverCreateInput,
  Prisma.CoverUpdateInput,
  Prisma.CoverOrderByWithRelationInput,
  Prisma.CoverInclude
> {
  protected readonly modelName = 'Cover' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/cover/entities/cover.entity.ts
```ts
export class Cover {}

```

### src/cover/dto/create-cover.dto.ts
```ts
import { IsEnum, IsNotEmpty, IsString } from 'class-validator';
import { ImageType } from '@prisma/client';

export class CreateCoverDto {
  @IsNotEmpty()
  @IsString()
  url: string;

  @IsEnum(ImageType)
  type?: ImageType;
}

```

### src/cover/dto/update-cover.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateCoverDto } from './create-cover.dto';

export class UpdateCoverDto extends PartialType(CreateCoverDto) {}

```

### src/config/mailer.config.ts
```ts
import { MailerOptions } from '@nestjs-modules/mailer';
import { HandlebarsAdapter } from '@nestjs-modules/mailer/dist/adapters/handlebars.adapter';
import { join } from 'path';

export const mailerConfig: MailerOptions = {
  transport: {
    host: process.env.MAIL_HOST,
    port: Number(process.env.MAIL_PORT),
    secure: false, // Set to false for TLS
    requireTLS: true, // Require TLS
    auth: {
      user: process.env.MAIL_USER,
      pass: process.env.MAIL_PASSWORD,
    },
    tls: {
      ciphers: 'SSLv3',
      rejectUnauthorized: false,
    },
  },
  defaults: {
    from: '"No Reply" <chain4good@gmail.com>',
  },
  template: {
    dir: join(__dirname, '..', 'templates'),
    adapter: new HandlebarsAdapter(),
    options: {
      strict: true,
    },
  },
};

```

### src/common/base.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';
import { toCamelCase } from 'src/utils/string';

@Injectable()
export abstract class BaseRepository<
  T,
  TWhereInput,
  TCreateInput,
  TUpdateInput,
  TOrderByInput,
  TInclude,
> {
  protected abstract readonly prisma: PrismaService;
  protected abstract readonly modelName: Prisma.ModelName;

  protected get model() {
    return this.prisma[
      toCamelCase(this.modelName) as keyof PrismaService
    ] as unknown as {
      findMany: (args?: {
        where?: TWhereInput;
        orderBy?: TOrderByInput;
        skip?: number;
        take?: number;
        include?: TInclude;
      }) => Promise<T[]>;
      findUnique: (args: {
        where: { id: number };
        include?: TInclude;
      }) => Promise<T | null>;
      findFirst: (args: {
        where: TWhereInput;
        include?: TInclude;
      }) => Promise<T | null>;
      create: (args: { data: TCreateInput; include?: TInclude }) => Promise<T>;
      update: (args: {
        where: { id: number };
        data: TUpdateInput;
        include?: TInclude;
      }) => Promise<T>;
      delete: (args: { where: { id: number } }) => Promise<T>;
      count: (args?: { where?: TWhereInput }) => Promise<number>;
    };
  }

  async findAll(args?: {
    where?: TWhereInput;
    orderBy?: TOrderByInput;
    include?: TInclude;
  }): Promise<T[]> {
    return this.model.findMany(args);
  }

  async findOne(id: number, include?: TInclude): Promise<T | null> {
    return this.model.findUnique({
      where: { id },
      include,
    });
  }

  async findBy(where: TWhereInput, include?: TInclude): Promise<T[]> {
    return this.model.findMany({
      where,
      include,
    });
  }

  async findOneBy(where: TWhereInput, include?: TInclude): Promise<T | null> {
    return this.model.findFirst({
      where,
      include,
    });
  }

  async create(data: TCreateInput, include?: TInclude): Promise<T> {
    return this.model.create({
      data,
      include,
    });
  }

  async update(id: number, data: TUpdateInput, include?: TInclude): Promise<T> {
    return this.model.update({
      where: { id },
      data,
      include,
    });
  }

  async delete(id: number): Promise<T> {
    return this.model.delete({
      where: { id },
    });
  }

  async count(where?: TWhereInput): Promise<number> {
    return this.model.count({
      where,
    });
  }

  async paginate(
    page: number = 1,
    limit: number = 10,
    options?: {
      where?: TWhereInput;
      orderBy?: TOrderByInput;
      include?: TInclude;
    },
  ): Promise<{
    data: T[];
    meta: {
      total: number;
      page: number;
      limit: number;
    };
  }> {
    const skip = (page - 1) * limit;
    const { where, orderBy, include } = options || {};

    const [data, total] = await Promise.all([
      this.model.findMany({
        where,
        orderBy,
        skip: Number(skip),
        take: Number(limit),
        include,
      }),
      this.model.count({ where }),
    ]);

    return {
      data,
      meta: {
        total,
        page: Number(page),
        limit: Number(limit),
      },
    };
  }
}

```

### src/common/filters/all-exceptions.filter.ts
```ts
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { Response } from 'express';

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    const status =
      exception instanceof HttpException
        ? exception.getStatus()
        : HttpStatus.INTERNAL_SERVER_ERROR;

    const message =
      exception instanceof HttpException
        ? exception.getResponse()
        : typeof exception === 'object' &&
            exception !== null &&
            'message' in exception
          ? (exception as { message: string }).message
          : 'Internal server error';

    const stack =
      typeof exception === 'object' &&
      exception !== null &&
      'stack' in exception
        ? (exception as { stack: string }).stack
        : undefined;

    response.status(status).json({
      statusCode: status,
      message,
      timestamp: new Date().toISOString(),
      path: request.url,
      // Optional: send stack trace
      stack,
    });
  }
}

```

### src/country/country.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { CountryService } from './country.service';
import { CreateCountryDto } from './dto/create-country.dto';
import { UpdateCountryDto } from './dto/update-country.dto';

@Controller('countries')
export class CountryController {
  constructor(private readonly countryService: CountryService) {}

  @Post()
  create(@Body() createCountryDto: CreateCountryDto) {
    return this.countryService.create(createCountryDto);
  }

  @Get()
  findAll() {
    return this.countryService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.countryService.findOne(+id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCountryDto: UpdateCountryDto) {
    return this.countryService.update(+id, updateCountryDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.countryService.remove(+id);
  }
}

```

### src/country/country.module.ts
```ts
import { Module } from '@nestjs/common';
import { CountryService } from './country.service';
import { CountryController } from './country.controller';
import { CountryRepo } from './country.repository';

@Module({
  controllers: [CountryController],
  providers: [CountryService, CountryRepo],
})
export class CountryModule {}

```

### src/country/country.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { CreateCountryDto } from './dto/create-country.dto';
import { UpdateCountryDto } from './dto/update-country.dto';
import { CountryRepo } from './country.repository';

@Injectable()
export class CountryService {
  constructor(private readonly countryRepo: CountryRepo) {}
  create(createCountryDto: CreateCountryDto) {
    return this.countryRepo.create(createCountryDto);
  }

  findAll() {
    return this.countryRepo.findAll();
  }

  findOne(id: number) {
    return this.countryRepo.findOne(id);
  }

  update(id: number, updateCountryDto: UpdateCountryDto) {
    return this.countryRepo.update(id, updateCountryDto);
  }

  remove(id: number) {
    return this.countryRepo.delete(id);
  }
}

```

### src/country/country.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Country, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class CountryRepo extends BaseRepository<
  Country,
  Prisma.CountryWhereInput,
  Prisma.CountryCreateInput,
  Prisma.CountryUpdateInput,
  Prisma.CountryOrderByWithRelationInput,
  Prisma.CountryInclude
> {
  protected readonly modelName = 'Country' as Prisma.ModelName;

  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/country/entities/country.entity.ts
```ts
export class Country {}

```

### src/country/dto/create-country.dto.ts
```ts
import { IsNotEmpty, IsString } from 'class-validator';
export class CreateCountryDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsNotEmpty()
  code: string;

  @IsString()
  @IsNotEmpty()
  phoneCode: string;
}

```

### src/country/dto/update-country.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateCountryDto } from './create-country.dto';

export class UpdateCountryDto extends PartialType(CreateCountryDto) {}

```

### src/category/category.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Category, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class CategoryRepo extends BaseRepository<
  Category,
  Prisma.CategoryWhereInput,
  Prisma.CategoryCreateInput,
  Prisma.CategoryUpdateInput,
  Prisma.CategoryOrderByWithRelationInput,
  Prisma.CategoryInclude
> {
  protected readonly modelName = 'Category' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/category/category.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { CategoryService } from './category.service';
import { CreateCategoryDto } from './dto/create-category.dto';
import { UpdateCategoryDto } from './dto/update-category.dto';

@Controller('categories')
export class CategoryController {
  constructor(private readonly categoryService: CategoryService) {}

  @Post()
  create(@Body() createCategoryDto: CreateCategoryDto) {
    return this.categoryService.create(createCategoryDto);
  }

  @Get()
  findAll() {
    return this.categoryService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.categoryService.findOne(+id);
  }

  @Patch(':id')
  update(
    @Param('id') id: string,
    @Body() updateCategoryDto: UpdateCategoryDto,
  ) {
    return this.categoryService.update(+id, updateCategoryDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.categoryService.remove(+id);
  }
}

```

### src/category/category.module.ts
```ts
import { Module } from '@nestjs/common';
import { CategoryService } from './category.service';
import { CategoryController } from './category.controller';
import { CategoryRepo } from './category.repository';

@Module({
  controllers: [CategoryController],
  providers: [CategoryService, CategoryRepo],
})
export class CategoryModule {}

```

### src/category/category.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { CreateCategoryDto } from './dto/create-category.dto';
import { UpdateCategoryDto } from './dto/update-category.dto';
import { CategoryRepo } from './category.repository';

@Injectable()
export class CategoryService {
  constructor(private readonly categoryRepo: CategoryRepo) {}

  create(createCategoryDto: CreateCategoryDto) {
    return this.categoryRepo.create(createCategoryDto);
  }

  findAll() {
    return this.categoryRepo.findAll();
  }

  findOne(id: number) {
    return this.categoryRepo.findOne(id);
  }

  update(id: number, updateCategoryDto: UpdateCategoryDto) {
    return this.categoryRepo.update(id, updateCategoryDto);
  }

  remove(id: number) {
    return this.categoryRepo.delete(id);
  }
}

```

### src/category/entities/category.entity.ts
```ts
export class Category {}

```

### src/category/dto/update-category.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateCategoryDto } from './create-category.dto';

export class UpdateCategoryDto extends PartialType(CreateCategoryDto) {}

```

### src/category/dto/create-category.dto.ts
```ts
import { IsNotEmpty, IsOptional, IsString } from 'class-validator';

export class CreateCategoryDto {
  @IsString()
  @IsNotEmpty({ message: 'Name is required' })
  name: string;

  @IsString()
  @IsOptional()
  icon?: string;

  @IsString()
  @IsOptional()
  description?: string;
}

```

### src/ai/ai.module.ts
```ts
import { Module } from '@nestjs/common';
import { AiService } from './ai.service';
import { AiController } from './ai.controller';

@Module({
  providers: [AiService],
  controllers: [AiController],
})
export class AiModule {}

```

### src/ai/ai.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import OpenAI from 'openai';

@Injectable()
export class AiService {
  private openai: OpenAI;

  constructor(private configService: ConfigService) {
    this.openai = new OpenAI({
      apiKey: this.configService.get('OPENAI_API_KEY'),
    });
  }

  async analyzeCampaign(title: string, description: string) {
    const prompt = `
            Phân tích và tóm tắt chiến dịch từ thiện sau:
            Tiêu đề: ${title}
            Mô tả: ${description}
            Trả về JSON với 2 field:
            - summary: tóm tắt ngắn gọn chiến dịch
            - analysis: phân tích ngắn gọn về mức độ thuyết phục, tính nhân văn, khả năng kêu gọi.
            `;

    const response = await this.openai.chat.completions.create({
      model: 'gpt-3.5-turbo-0125',
      messages: [{ role: 'user', content: prompt }],
    });

    const content = response.choices[0].message?.content;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return JSON.parse(content || '{}');
  }
}

```

### src/ai/ai.controller.ts
```ts
import { Body, Controller, Post } from '@nestjs/common';
import { AiService } from './ai.service';
import { AnalyzeCampaignDto } from './dto/analyze-campaign.dto';

@Controller('ai')
export class AiController {
  constructor(private readonly aiService: AiService) {}

  @Post('analyze-campaign')
  async analyze(@Body() dto: AnalyzeCampaignDto) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return this.aiService.analyzeCampaign(dto.title, dto.description);
  }
}

```

### src/ai/dto/analyze-campaign.dto.ts
```ts
import { IsString } from 'class-validator';

export class AnalyzeCampaignDto {
  @IsString()
  title: string;

  @IsString()
  description: string;
}

```

### src/prisma/prisma.module.ts
```ts
import { Module, Global } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global()
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}

```

### src/prisma/prisma.service.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-call */
// src/prisma/prisma.service.ts

import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService
  extends PrismaClient
  implements OnModuleInit, OnModuleDestroy
{
  async onModuleInit() {
    await this.$connect();
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}

```

### src/fundraise-type/fundraise-type.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { FundraiseType, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class FundraiseTypeRepo extends BaseRepository<
  FundraiseType,
  Prisma.FundraiseTypeWhereInput,
  Prisma.FundraiseTypeCreateInput,
  Prisma.FundraiseTypeUpdateInput,
  Prisma.FundraiseTypeOrderByWithRelationInput,
  Prisma.FundraiseTypeInclude
> {
  protected readonly modelName = 'FundraiseType' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/fundraise-type/fundraise-type.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { CreateFundraiseTypeDto } from './dto/create-fundraise-type.dto';
import { UpdateFundraiseTypeDto } from './dto/update-fundraise-type.dto';
import { FundraiseTypeRepo } from './fundraise-type.repository';

@Injectable()
export class FundraiseTypeService {
  constructor(private readonly fundraiseTypeRepo: FundraiseTypeRepo) {}

  create(createFundraiseTypeDto: CreateFundraiseTypeDto) {
    return this.fundraiseTypeRepo.create(createFundraiseTypeDto);
  }

  findAll() {
    return this.fundraiseTypeRepo.findAll();
  }

  findOne(id: number) {
    return this.fundraiseTypeRepo.findOne(id);
  }

  update(id: number, updateFundraiseTypeDto: UpdateFundraiseTypeDto) {
    return this.fundraiseTypeRepo.update(id, updateFundraiseTypeDto);
  }

  remove(id: number) {
    return this.fundraiseTypeRepo.delete(id);
  }
}

```

### src/fundraise-type/fundraise-type.module.ts
```ts
import { Module } from '@nestjs/common';
import { FundraiseTypeService } from './fundraise-type.service';
import { FundraiseTypeController } from './fundraise-type.controller';
import { FundraiseTypeRepo } from './fundraise-type.repository';

@Module({
  controllers: [FundraiseTypeController],
  providers: [FundraiseTypeService, FundraiseTypeRepo],
})
export class FundraiseTypeModule {}

```

### src/fundraise-type/fundraise-type.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  ParseIntPipe,
} from '@nestjs/common';
import { FundraiseTypeService } from './fundraise-type.service';
import { CreateFundraiseTypeDto } from './dto/create-fundraise-type.dto';
import { UpdateFundraiseTypeDto } from './dto/update-fundraise-type.dto';

@Controller('fundraise-types')
export class FundraiseTypeController {
  constructor(private readonly fundraiseTypeService: FundraiseTypeService) {}

  @Post()
  create(@Body() createFundraiseTypeDto: CreateFundraiseTypeDto) {
    return this.fundraiseTypeService.create(createFundraiseTypeDto);
  }

  @Get()
  findAll() {
    return this.fundraiseTypeService.findAll();
  }

  @Get(':id')
  findOne(@Param('id', ParseIntPipe) id: number) {
    return this.fundraiseTypeService.findOne(id);
  }

  @Patch(':id')
  update(
    @Param('id', ParseIntPipe) id: number,
    @Body() updateFundraiseTypeDto: UpdateFundraiseTypeDto,
  ) {
    return this.fundraiseTypeService.update(id, updateFundraiseTypeDto);
  }

  @Delete(':id')
  remove(@Param('id', ParseIntPipe) id: number) {
    return this.fundraiseTypeService.remove(id);
  }
}

```

### src/fundraise-type/entities/fundraise-type.entity.ts
```ts
export class FundraiseType {
  id: number;
  name: string;
  description: string;
}

```

### src/fundraise-type/dto/update-fundraise-type.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateFundraiseTypeDto } from './create-fundraise-type.dto';

export class UpdateFundraiseTypeDto extends PartialType(
  CreateFundraiseTypeDto,
) {}

```

### src/fundraise-type/dto/create-fundraise-type.dto.ts
```ts
import { IsString, IsNotEmpty } from 'class-validator';

export class CreateFundraiseTypeDto {
  @IsString()
  @IsNotEmpty()
  name: string;
  @IsString()
  @IsNotEmpty()
  description: string;
}

```

### src/utils/string.ts
```ts
export function toCamelCase(name: string) {
  return name.charAt(0).toLowerCase() + name.slice(1);
}

```

### src/users/users.module.ts
```ts
import { Module } from '@nestjs/common';
import { UsersService } from './users.service';
import { PrismaModule } from '../prisma/prisma.module';
import { UserController } from './users.controller';

@Module({
  controllers: [UserController],
  imports: [PrismaModule],
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}

```

### src/users/users.service.ts
```ts
import { ConflictException, Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Prisma, User } from '@prisma/client';
import { UserRegisterDTO } from 'src/auth/dtos/user-register.dto';
import { UpdateUserDto } from './dto/update-user.dto';

@Injectable()
export class UsersService {
  constructor(private prisma: PrismaService) {}

  async findByEmail(email: string): Promise<User | null> {
    return this.prisma.user.findUnique({
      where: { email },
    });
  }

  async findById(id: number): Promise<User | null> {
    return this.prisma.user.findUnique({
      where: { id },
    });
  }

  async create(userRegisterDto: UserRegisterDTO): Promise<User> {
    const { email, password, name, address } = userRegisterDto;
    try {
      return await this.prisma.user.create({
        data: {
          email,
          password,
          name,
          address,
          roleId: 2,
        },
      });
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
          throw new ConflictException(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Unique constraint failed on the fields: (${error?.meta?.target})`,
          );
        }
      }
      throw error;
    }
  }
  async update(id: number, data: UpdateUserDto) {
    return this.prisma.user.update({
      where: { id },
      data,
    });
  }
}

```

### src/users/users.controller.ts
```ts
import { Body, Controller, Param, Patch } from '@nestjs/common';
import { UsersService } from './users.service';
import { UpdateUserDto } from './dto/update-user.dto';

@Controller('users')
export class UserController {
  constructor(private readonly userService: UsersService) {}
  @Patch(':id')
  update(@Body() updateUserDto: UpdateUserDto, @Param('id') id: string) {
    return this.userService.update(+id, updateUserDto);
  }
}

```

### src/users/dto/update-user.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { UserRegisterDTO } from 'src/auth/dtos/user-register.dto';

export class UpdateUserDto extends PartialType(UserRegisterDTO) {}

```

### src/mailer/mailer.module.ts
```ts
import { Module } from '@nestjs/common';
import { MailerModule as NestMailerModule } from '@nestjs-modules/mailer';
import { mailerConfig } from '../config/mailer.config';
import { MailerService } from './mailer.service';

@Module({
  imports: [NestMailerModule.forRoot(mailerConfig)],
  providers: [MailerService],
  exports: [MailerService],
})
export class MailerModule {}

```

### src/mailer/mailer.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { MailerService as NestMailerService } from '@nestjs-modules/mailer';

@Injectable()
export class MailerService {
  constructor(private readonly mailerService: NestMailerService) {}

  async sendCampaignCreated(email: string, campaignName: string) {
    await this.mailerService.sendMail({
      to: email,
      subject: 'Campaign Created Successfully',
      template: 'campaign-created', // tên của template trong thư mục templates
      context: {
        campaignName,
      },
    });
  }

  async sendDonationConfirmation(
    email: string,
    data: {
      campaignName: string;
      amount: number;
      donorName: string;
    },
  ) {
    await this.mailerService.sendMail({
      to: email,
      subject: 'Thank You for Your Donation',
      template: 'donation-confirmation',
      context: {
        ...data,
      },
    });
  }

  async sendCampaignStatusUpdate(
    email: string,
    data: {
      campaignName: string;
      status: string;
    },
  ) {
    await this.mailerService.sendMail({
      to: email,
      subject: 'Campaign Status Updated',
      template: 'campaign-status-update',
      context: {
        ...data,
      },
    });
  }
}

```

### src/upload/upload.module.ts
```ts
import { Module } from '@nestjs/common';
import { UploadController } from './upload.controller';
import { UploadService } from './upload.service';
import { CloudinaryProvider } from './cloudinary.provider';
import { mkdir } from 'fs/promises';

@Module({
  controllers: [UploadController],
  providers: [
    UploadService,
    CloudinaryProvider,
    {
      provide: 'UPLOAD_INIT',
      useFactory: async () => {
        try {
          await mkdir('./uploads', { recursive: true });
        } catch (error) {
          // Ignore error if directory already exists
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          if (error.code !== 'EEXIST') {
            throw error;
          }
        }
      },
    },
  ],
})
export class UploadModule {}

```

### src/upload/cloudinary.provider.ts
```ts
import { v2 as cloudinary } from 'cloudinary';

export const CloudinaryProvider = {
  provide: 'CLOUDINARY',
  useFactory: () => {
    return cloudinary.config({
      cloud_name: process.env.CLOUDINARY_NAME,
      api_key: process.env.CLOUDINARY_API_KEY,
      api_secret: process.env.CLOUDINARY_API_SECRET,
      secure: true,
    });
  },
};

```

### src/upload/upload.service.ts
```ts
/* eslint-disable @typescript-eslint/prefer-promise-reject-errors */
import { Injectable, OnModuleInit } from '@nestjs/common';
import { v2 as cloudinary } from 'cloudinary';
import { createReadStream } from 'fs';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class UploadService implements OnModuleInit {
  constructor(private configService: ConfigService) {}

  onModuleInit() {
    const cloudName: string | undefined = this.configService.get(
      'CLOUDINARY_CLOUD_NAME',
    );
    const apiKey: string | undefined =
      this.configService.get('CLOUDINARY_API_KEY');
    const apiSecret: string | undefined = this.configService.get(
      'CLOUDINARY_API_SECRET',
    );

    console.log(cloudName, apiKey, apiSecret);

    if (!cloudName || !apiKey || !apiSecret) {
      throw new Error('Missing required Cloudinary configuration');
    }

    cloudinary.config({
      cloud_name: cloudName,
      api_key: apiKey,
      api_secret: apiSecret,
    });
  }

  async uploadImage(file: Express.Multer.File) {
    return new Promise((resolve, reject) => {
      const uploadStream = cloudinary.uploader.upload_stream(
        {
          folder: 'charity',
          resource_type: 'auto',
        },
        (error, result) => {
          if (error) return reject(error);
          resolve(result);
        },
      );
      createReadStream(file.path).pipe(uploadStream);
    });
  }
}

```

### src/upload/upload.controller.ts
```ts
import {
  Controller,
  Post,
  UploadedFile,
  UseInterceptors,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { UploadService } from './upload.service';
import { diskStorage } from 'multer';
import { unlink } from 'fs/promises';

@Controller('uploads')
export class UploadController {
  constructor(private readonly uploadService: UploadService) {}

  @Post()
  @UseInterceptors(
    FileInterceptor('file', {
      storage: diskStorage({
        destination: './uploads',
        filename: (req, file, cb) => {
          const uniqueName = `${Date.now()}-${file.originalname}`;
          cb(null, uniqueName);
        },
      }),
    }),
  )
  async uploadFile(@UploadedFile() file: Express.Multer.File) {
    try {
      const result = await this.uploadService.uploadImage(file);

      await unlink(file.path);

      return { url: (result as { secure_url: string }).secure_url };
    } catch (error) {
      await unlink(file.path);
      throw error;
    }
  }
}

```

### src/image/image.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { ImageService } from './image.service';
import { CreateImageDto } from './dto/create-image.dto';
import { UpdateImageDto } from './dto/update-image.dto';

@Controller('image')
export class ImageController {
  constructor(private readonly imageService: ImageService) {}

  @Post()
  create(@Body() createImageDto: CreateImageDto) {
    return this.imageService.create(createImageDto);
  }

  @Get()
  findAll() {
    return this.imageService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.imageService.findOne(+id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateImageDto: UpdateImageDto) {
    return this.imageService.update(+id, updateImageDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.imageService.remove(+id);
  }
}

```

### src/image/image.module.ts
```ts
import { Module } from '@nestjs/common';
import { ImageService } from './image.service';
import { ImageController } from './image.controller';
import { ImageRepo } from './image.repository';

@Module({
  controllers: [ImageController],
  providers: [ImageService, ImageRepo],
})
export class ImageModule {}

```

### src/image/image.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Image, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class ImageRepo extends BaseRepository<
  Image,
  Prisma.ImageWhereInput,
  Prisma.ImageCreateInput,
  Prisma.ImageUpdateInput,
  Prisma.ImageOrderByWithRelationInput,
  Prisma.ImageInclude
> {
  protected readonly modelName = 'Image' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/image/image.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { CreateImageDto } from './dto/create-image.dto';
import { UpdateImageDto } from './dto/update-image.dto';
import { ImageRepo } from './image.repository';

@Injectable()
export class ImageService {
  constructor(private readonly imageRepo: ImageRepo) {}
  create(createImageDto: CreateImageDto) {
    return this.imageRepo.create(createImageDto);
  }

  findAll() {
    return this.imageRepo.findAll();
  }

  findOne(id: number) {
    return this.imageRepo.findOne(id);
  }

  update(id: number, updateImageDto: UpdateImageDto) {
    return this.imageRepo.update(id, updateImageDto);
  }

  remove(id: number) {
    return this.imageRepo.delete(id);
  }
}

```

### src/image/entities/image.entity.ts
```ts
export class Image {}

```

### src/image/dto/update-image.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateImageDto } from './create-image.dto';

export class UpdateImageDto extends PartialType(CreateImageDto) {}

```

### src/image/dto/create-image.dto.ts
```ts
import { ImageType } from '@prisma/client';
import {
  IsEnum,
  IsInt,
  IsNotEmpty,
  IsOptional,
  IsString,
  IsUrl,
} from 'class-validator';

export class CreateImageDto {
  @IsNotEmpty()
  @IsString()
  @IsUrl({}, { message: 'URL must be a valid URL' })
  url: string;

  @IsOptional()
  @IsInt({ message: 'Campaign ID must be an integer' })
  campaignId?: number;

  @IsOptional()
  @IsEnum(ImageType, { message: 'Type must be either IMAGE or VIDEO' })
  type?: ImageType;
}

```

### src/campaign/campaign.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Campaign, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class CampaignRepo extends BaseRepository<
  Campaign,
  Prisma.CampaignWhereInput,
  Prisma.CampaignCreateInput,
  Prisma.CampaignUpdateInput,
  Prisma.CampaignOrderByWithRelationInput,
  Prisma.CampaignInclude
> {
  protected readonly modelName = 'Campaign' as Prisma.ModelName;

  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/campaign/campaign.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
  Query,
} from '@nestjs/common';
import { CampaignService } from './campaign.service';
import { CreateCampaignDto } from './dto/create-campaign.dto';
import { UpdateCampaignDto } from './dto/update-campaign.dto';
import { GetUser, UserExtract } from 'src/auth/decorators/auth.decorators';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { CampaignStatus } from '@prisma/client';

@Controller('campaigns')
export class CampaignController {
  constructor(private readonly campaignService: CampaignService) {}

  @Post()
  @UseGuards(JwtAuthGuard)
  create(
    @Body() createCampaignDto: CreateCampaignDto,
    @GetUser() user: UserExtract,
  ) {
    const campaign = this.campaignService.create({
      ...createCampaignDto,
      userId: user.id,
      email: user.email,
    });
    return campaign;
  }

  @Get()
  findAll(
    @Query('userId') userId: number,
    @Query('email') email: string,
    @Query('status') status: CampaignStatus,
    @Query('page') page: number,
    @Query('limit') limit: number,
    @Query('search') search: string,
    @Query('sort') sort: 'asc' | 'desc',
    @Query('sortBy') sortBy: string,
    @Query('categoryId') categoryId: number,
    @Query('fundraiseTypeId') fundraiseTypeId: number,
  ) {
    return this.campaignService.findAll(
      userId,
      email,
      status,
      page,
      limit,
      search,
      sort,
      sortBy,
      categoryId,
      fundraiseTypeId,
    );
  }

  @Get('my-campaigns')
  @UseGuards(JwtAuthGuard)
  findMyCampaigns(
    @GetUser() user: UserExtract,
    @Query('page') page: number,
    @Query('limit') limit: number,
  ) {
    return this.campaignService.findMyCampaigns(user.id, page, limit);
  }

  @Get('calculate-eth-goal')
  calculateEthGoal(@Query('vndAmount') vndAmount: number) {
    return this.campaignService.calculateEthGoal(vndAmount);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.campaignService.findOne(+id);
  }

  @Patch(':id')
  update(
    @Param('id') id: string,
    @Body() updateCampaignDto: UpdateCampaignDto,
  ) {
    console.log(updateCampaignDto);

    return this.campaignService.update(+id, updateCampaignDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.campaignService.remove(+id);
  }
}

```

### src/campaign/campaign.service.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { Injectable } from '@nestjs/common';
import { CreateCampaignDto } from './dto/create-campaign.dto';
import { UpdateCampaignDto } from './dto/update-campaign.dto';
import { CampaignRepo } from './campaign.repository';
import { MailerService } from '../mailer/mailer.service';
import { CampaignStatus, Prisma } from '@prisma/client';

@Injectable()
export class CampaignService {
  constructor(
    private readonly campaignRepo: CampaignRepo,
    private readonly mailerService: MailerService,
  ) {}

  async create(
    createCampaignDto: CreateCampaignDto & { userId: number; email: string },
  ) {
    try {
      const {
        images,
        userId,
        categoryId,
        countryId,
        coverId,
        fundraiseTypeId,
        email,
        ...rest
      } = createCampaignDto;
      const campaign = await this.campaignRepo.create(
        {
          ...rest,
          user: { connect: { id: userId } },
          category: { connect: { id: categoryId } },
          images: {
            create: images.map((url) => ({ url, type: 'IMAGE' })),
          },
          country: { connect: { id: countryId } },
          cover: { connect: { id: coverId } },
          fundraiseType: { connect: { id: fundraiseTypeId } },
          deadline: new Date(rest.deadline),
        },
        {
          user: true,
        },
      );
      await this.mailerService.sendCampaignCreated(email, campaign.title);

      return campaign;
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  findAll(
    userId?: number,
    email?: string,
    status?: CampaignStatus,
    page: number = 1,
    limit: number = 10,
    search?: string,
    sort: 'asc' | 'desc' = 'desc',
    sortBy: string = 'createdAt',
    categoryId?: number,
    fundraiseTypeId?: number,
  ) {
    const where: Prisma.CampaignWhereInput = {
      ...(userId && { userId: Number(userId) }),
      ...(email && { user: { email } }),
      ...(status && { status: status }),
      ...(categoryId && { categoryId: Number(categoryId) }),
      ...(fundraiseTypeId && { fundraiseTypeId: Number(fundraiseTypeId) }),
      ...(search && {
        OR: [
          {
            title: {
              contains: search,
              mode: Prisma.QueryMode.insensitive,
            },
          },
          {
            description: {
              contains: search,
              mode: Prisma.QueryMode.insensitive,
            },
          },
        ],
      }),
    };

    const orderBy = {
      [sortBy]: sort,
    };

    return this.campaignRepo.paginate(page, limit, {
      where,
      orderBy,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            image: true,
            address: true,
          },
        },
        category: true,
        country: true,
        cover: true,
        images: true,
        fundraiseType: true,
      },
    });
  }

  findMyCampaigns(userId: number, page: number = 1, limit: number = 10) {
    return this.campaignRepo.paginate(page, limit, {
      where: { userId },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            image: true,
            address: true,
          },
        },
        category: true,
        country: true,
        cover: true,
        images: true,
        fundraiseType: true,
      },
    });
  }

  findOne(id: number) {
    return this.campaignRepo.findOne(id, {
      category: true,
      country: true,
      cover: true,
      images: true,
      user: {
        select: {
          id: true,
          name: true,
          email: true,
          image: true,
          address: true,
        },
      },
      donations: {
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
              image: true,
              address: true,
            },
          },
        },
      },
    });
  }

  async update(id: number, updateCampaignDto: UpdateCampaignDto) {
    const { images, ...rest } = updateCampaignDto;

    const data: any = { ...rest };

    if (images && images.length > 0) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      data.images = {
        connect: images.map((id) => ({ id: Number(id) })),
      };
    }

    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    return this.campaignRepo.update(id, data);
  }

  remove(id: number) {
    return this.campaignRepo.delete(id);
  }

  async calculateEthGoal(vndAmount: number): Promise<number> {
    const ethPrice = await this.getEthPrice(); // VND / ETH
    return vndAmount / ethPrice;
  }

  private async getEthPrice(): Promise<number> {
    try {
      const response = await fetch(
        'https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=vnd',
      );
      const data = await response.json();
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      return data.ethereum.vnd;
    } catch (error) {
      console.error('Failed to fetch ETH price:', error);
      throw new Error('Could not fetch ETH price');
    }
  }
}

```

### src/campaign/campaign.module.ts
```ts
import { Module } from '@nestjs/common';
import { CampaignService } from './campaign.service';
import { CampaignController } from './campaign.controller';
import { CampaignRepo } from './campaign.repository';
import { MailerModule } from '../mailer/mailer.module';

@Module({
  imports: [MailerModule],
  controllers: [CampaignController],
  providers: [CampaignService, CampaignRepo],
})
export class CampaignModule {}

```

### src/campaign/entities/campaign.entity.ts
```ts
export class Campaign {
  id: number;
  title: string;
  description?: string;
  startDate?: Date;
  endDate?: Date;
  status?: string;
}

```

### src/campaign/dto/update-campaign.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateCampaignDto } from './create-campaign.dto';

export class UpdateCampaignDto extends PartialType(CreateCampaignDto) {}

```

### src/campaign/dto/create-campaign.dto.ts
```ts
// src/campaign/dto/create-campaign.dto.ts
import { CampaignStatus } from '@prisma/client';
import {
  IsNotEmpty,
  IsString,
  IsOptional,
  IsDateString,
  IsNumber,
  IsInt,
  IsBoolean,
  IsArray,
} from 'class-validator';

export class CreateCampaignDto {
  @IsString()
  @IsNotEmpty()
  title: string;

  @IsString()
  description: string;

  @IsNumber()
  @IsNotEmpty()
  goal: number;

  @IsDateString()
  @IsNotEmpty()
  deadline: string;

  @IsNumber()
  @IsOptional()
  totalDonated: number;

  @IsBoolean()
  @IsOptional()
  isClosed: boolean;

  @IsBoolean()
  @IsOptional()
  isNoLimit: boolean;

  @IsString()
  @IsOptional()
  status: CampaignStatus;

  @IsInt()
  @IsNotEmpty()
  categoryId: number;

  @IsInt()
  @IsNotEmpty()
  countryId: number;

  @IsArray()
  @IsNotEmpty()
  images: string[];

  @IsInt()
  @IsNotEmpty()
  fundraiseTypeId: number;

  @IsInt()
  @IsNotEmpty()
  coverId: number;

  @IsInt()
  @IsOptional()
  chainCampaignId: number;

  @IsString()
  @IsOptional()
  txHash: string;

  @IsString()
  @IsOptional()
  creatorAddress: string;

  @IsString()
  @IsOptional()
  tokenAddress: string;
}

```

### src/campaign/use-cases/create-campaign-with-images.use-case.ts
```ts
import { Injectable } from '@nestjs/common';
import { CampaignService } from '../campaign.service';
import { ImageService } from 'src/image/image.service';
import { CreateCampaignDto } from '../dto/create-campaign.dto';

@Injectable()
export class CreateCampaignWithImagesUseCase {
  constructor(
    private readonly campaignService: CampaignService,
    private readonly imageService: ImageService,
  ) {}

  async execute(dto: CreateCampaignDto) {
    // const campaign = await this.campaignService.create(dto);
    // const imageCreatePromises = dto.images.map((url) =>
    //   this.imageService.create({
    //     url,
    //     campaignId: campaign.id,
    //     type: 'IMAGE',
    //   }),
    // );
    // await Promise.all(imageCreatePromises);
    // return campaign;
  }
}

```

### test/app.e2e-spec.ts
```ts
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { App } from 'supertest/types';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication<App>;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});

```
