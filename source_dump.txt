# ==================================================
# Path: /home/tommy/Documents/charity/backend
# Detected tech: angular, docker, gitlab_ci, javascript, python, react, typescript
# ==================================================

## DIRECTORY STRUCTURE
```
backend/
├── .git/
├── .github/
├── .vscode/
├── audio/
│   ├── output-1750086291112.wav
│   ├── output-1750086933244.wav
│   ├── output-1750088126575.wav
│   └── output-1750088646821.wav
├── dist/
├── node_modules/
├── prisma/
│   ├── migrations/
│   │   ├── 20250418033523_init/
│   │   │   └── migration.sql
│   │   ├── 20250523044952_change_name_fundraise/
│   │   │   └── migration.sql
│   │   ├── 20250526081123_add_table_report_and_status_campain_col/
│   │   │   └── migration.sql
│   │   ├── 20250526102518_update_name_enum/
│   │   │   └── migration.sql
│   │   ├── 20250528024446_update_goal_col/
│   │   │   └── migration.sql
│   │   ├── 20250528152051_add_new_col_campaign_model/
│   │   │   └── migration.sql
│   │   ├── 20250528152543_add_new_col_campaign_model/
│   │   │   └── migration.sql
│   │   ├── 20250530031841_add_new_col_for_donation_model/
│   │   │   └── migration.sql
│   │   ├── 20250530084947_add_comment_system/
│   │   │   └── migration.sql
│   │   ├── 20250530110832_add_refresh_tokens/
│   │   │   └── migration.sql
│   │   ├── 20250530120806_add_cover_col_user/
│   │   │   └── migration.sql
│   │   ├── 20250531085325_remove_unique_constraint_donation/
│   │   │   └── migration.sql
│   │   ├── 20250531090050_add_col_goal_eth_campaign_model/
│   │   │   └── migration.sql
│   │   ├── 20250531090754_remove_col_campaign/
│   │   │   └── migration.sql
│   │   ├── 20250531091250_update_col_total_donated/
│   │   │   └── migration.sql
│   │   ├── 20250531163344_add_notifications/
│   │   │   └── migration.sql
│   │   ├── 20250601083337_add_campaign_approval_status/
│   │   │   └── migration.sql
│   │   ├── 20250603103308_add_token_col_donation/
│   │   │   └── migration.sql
│   │   ├── 20250603122112_update_type_amount_donation/
│   │   │   └── migration.sql
│   │   ├── 20250603153326_add_post_and_topic/
│   │   │   └── migration.sql
│   │   ├── 20250605040557_add_verify_mail_system/
│   │   │   └── migration.sql
│   │   ├── 20250605074827_add_new_col_user_model/
│   │   │   └── migration.sql
│   │   ├── 20250606035831_add_badge_system/
│   │   │   └── migration.sql
│   │   ├── 20250607115215_add_progress_campaign/
│   │   │   └── migration.sql
│   │   ├── 20250611084237_add_new_col_campaign/
│   │   │   └── migration.sql
│   │   ├── 20250616114847_add_type_to_badge/
│   │   │   └── migration.sql
│   │   ├── 20250616154615_add_col_audio_campaign/
│   │   │   └── migration.sql
│   │   └── migration_lock.toml
│   └── schema.prisma
├── src/
│   ├── ai/
│   │   ├── dto/
│   │   │   └── analyze-campaign.dto.ts
│   │   ├── types/
│   │   │   ├── analyze-campaign.type.ts
│   │   │   ├── campaign-optimization.type.ts
│   │   │   ├── campaign-recommendations.type.ts
│   │   │   ├── thank-you-letter.type.ts
│   │   │   └── trust-analyze.type.ts
│   │   ├── ai.controller.ts
│   │   ├── ai.module.ts
│   │   └── ai.service.ts
│   ├── auth/
│   │   ├── decorators/
│   │   │   ├── auth.decorators.ts
│   │   │   └── roles.decorator.ts
│   │   ├── dtos/
│   │   │   ├── user-login.dto.ts
│   │   │   ├── user-register.dto.ts
│   │   │   └── verify-otp.dto.ts
│   │   ├── guards/
│   │   │   ├── jwt-auth.guard.ts
│   │   │   ├── local-auth.guard.ts
│   │   │   └── roles.guard.ts
│   │   ├── strategies/
│   │   │   ├── jwt.strategy.ts
│   │   │   └── local.strategy.ts
│   │   ├── auth.controller.ts
│   │   ├── auth.module.ts
│   │   ├── auth.service.ts
│   │   └── refresh-token.service.ts
│   ├── badge/
│   │   ├── dto/
│   │   │   └── create-badge.dto.ts
│   │   ├── enum/
│   │   │   └── badge-type.enum.ts
│   │   ├── interfaces/
│   │   │   └── badge-condition.interface.ts
│   │   ├── badge-rules.service.ts
│   │   ├── badge.controller.ts
│   │   ├── badge.module.ts
│   │   ├── badge.repository.ts
│   │   ├── badge.service.ts
│   │   └── user-badge.repository.ts
│   ├── campaign/
│   │   ├── dto/
│   │   │   ├── create-campaign-progress.dto.ts
│   │   │   ├── create-campaign.dto.ts
│   │   │   └── update-campaign.dto.ts
│   │   ├── entities/
│   │   │   └── campaign.entity.ts
│   │   ├── events/
│   │   │   └── campaign-created.event.ts
│   │   ├── listeners/
│   │   │   └── campaign-created.listener.ts
│   │   ├── use-cases/
│   │   │   └── create-campaign-with-images.use-case.ts
│   │   ├── campaign.controller.ts
│   │   ├── campaign.module.ts
│   │   ├── campaign.repository.ts
│   │   └── campaign.service.ts
│   ├── category/
│   │   ├── dto/
│   │   │   ├── create-category.dto.ts
│   │   │   └── update-category.dto.ts
│   │   ├── entities/
│   │   │   └── category.entity.ts
│   │   ├── category.controller.ts
│   │   ├── category.module.ts
│   │   ├── category.repository.ts
│   │   └── category.service.ts
│   ├── comment/
│   │   ├── dto/
│   │   │   └── create-comment.dto.ts
│   │   ├── comment.controller.ts
│   │   ├── comment.module.ts
│   │   ├── comment.repository.ts
│   │   ├── comment.service.ts
│   │   └── like.repository.ts
│   ├── common/
│   │   ├── filters/
│   │   │   └── all-exceptions.filter.ts
│   │   └── base.repository.ts
│   ├── config/
│   │   ├── mailer.config.ts
│   │   └── redis.config.ts
│   ├── country/
│   │   ├── dto/
│   │   │   ├── create-country.dto.ts
│   │   │   └── update-country.dto.ts
│   │   ├── entities/
│   │   │   └── country.entity.ts
│   │   ├── country.controller.ts
│   │   ├── country.module.ts
│   │   ├── country.repository.ts
│   │   └── country.service.ts
│   ├── cover/
│   │   ├── dto/
│   │   │   ├── create-cover.dto.ts
│   │   │   └── update-cover.dto.ts
│   │   ├── entities/
│   │   │   └── cover.entity.ts
│   │   ├── cover.controller.ts
│   │   ├── cover.module.ts
│   │   ├── cover.repository.ts
│   │   └── cover.service.ts
│   ├── dashboard/
│   │   ├── dashboard.controller.ts
│   │   ├── dashboard.module.ts
│   │   └── dashboard.service.ts
│   ├── donation/
│   │   ├── dto/
│   │   │   ├── create-donation.dto.ts
│   │   │   └── update-donation.dto.ts
│   │   ├── entities/
│   │   │   └── donation.entity.ts
│   │   ├── use-cases/
│   │   │   └── create-donation.use-case.ts
│   │   ├── donation.controller.ts
│   │   ├── donation.module.ts
│   │   ├── donation.repository.ts
│   │   └── donation.service.ts
│   ├── email/
│   │   └── campaign-email.service.ts
│   ├── fundraise-type/
│   │   ├── dto/
│   │   │   ├── create-fundraise-type.dto.ts
│   │   │   └── update-fundraise-type.dto.ts
│   │   ├── entities/
│   │   │   └── fundraise-type.entity.ts
│   │   ├── fundraise-type.controller.ts
│   │   ├── fundraise-type.module.ts
│   │   ├── fundraise-type.repository.ts
│   │   └── fundraise-type.service.ts
│   ├── gemini/
│   │   ├── interfaces/
│   │   │   └── wav-config.interface.ts
│   │   ├── gemini.module.ts
│   │   └── gemini.service.ts
│   ├── image/
│   │   ├── dto/
│   │   │   ├── create-image.dto.ts
│   │   │   └── update-image.dto.ts
│   │   ├── entities/
│   │   │   └── image.entity.ts
│   │   ├── image.controller.ts
│   │   ├── image.module.ts
│   │   ├── image.repository.ts
│   │   └── image.service.ts
│   ├── mailer/
│   │   ├── mailer.module.ts
│   │   └── mailer.service.ts
│   ├── notification/
│   │   ├── dto/
│   │   │   ├── create-notification.dto.ts
│   │   │   └── update-notification.dto.ts
│   │   ├── mappers/
│   │   │   └── notification.mapper.ts
│   │   ├── types/
│   │   │   └── notification.types.ts
│   │   ├── notification.controller.ts
│   │   ├── notification.gateway.ts
│   │   ├── notification.module.ts
│   │   ├── notification.repository.ts
│   │   └── notification.service.ts
│   ├── otp/
│   │   └── otp.service.ts
│   ├── post/
│   │   ├── dto/
│   │   │   ├── create-post.dto.ts
│   │   │   └── update-post.dto.ts
│   │   ├── post.controller.ts
│   │   ├── post.module.ts
│   │   ├── post.repository.ts
│   │   └── post.service.ts
│   ├── prisma/
│   │   ├── prisma.module.ts
│   │   └── prisma.service.ts
│   ├── providers/
│   ├── report/
│   │   ├── dto/
│   │   │   ├── create-report.dto.ts
│   │   │   └── update-report.dto.ts
│   │   ├── entities/
│   │   │   └── report.entity.ts
│   │   ├── report.controller.ts
│   │   ├── report.module.ts
│   │   ├── report.repository.ts
│   │   └── report.service.ts
│   ├── role/
│   │   ├── dto/
│   │   │   ├── create-role.dto.ts
│   │   │   └── update-role.dto.ts
│   │   ├── role.controller.ts
│   │   ├── role.module.ts
│   │   ├── role.repository.ts
│   │   └── role.service.ts
│   ├── templates/
│   │   ├── campaign-created-admin.hbs
│   │   ├── campaign-created.hbs
│   │   ├── campaign-progress-update.hbs
│   │   └── verify-email.hbs
│   ├── topic/
│   │   ├── dto/
│   │   │   ├── create-topic.dto.ts
│   │   │   └── update-topic.dto.ts
│   │   ├── topic.controller.ts
│   │   ├── topic.module.ts
│   │   ├── topic.repository.ts
│   │   └── topic.service.ts
│   ├── types/
│   │   └── express.d.ts
│   ├── upload/
│   │   ├── cloudinary.provider.ts
│   │   ├── upload.controller.ts
│   │   ├── upload.module.ts
│   │   └── upload.service.ts
│   ├── users/
│   │   ├── dto/
│   │   │   └── update-user.dto.ts
│   │   ├── user.repository.ts
│   │   ├── users.controller.ts
│   │   ├── users.module.ts
│   │   └── users.service.ts
│   ├── utils/
│   │   └── string.ts
│   ├── app.controller.ts
│   ├── app.module.ts
│   ├── app.service.ts
│   └── main.ts
├── test/
│   ├── app.e2e-spec.ts
│   └── jest-e2e.json
├── uploads/
├── .dockerignore
├── .env
├── .gitignore
├── .prettierrc
├── Dockerfile
├── README.md
├── contract.txt
├── docker-compose.yml
├── eslint.config.mjs
├── nest-cli.json
├── out.wav
├── package-lock.json
├── package.json
├── source_dump__BE.txt
├── tsconfig.build.json
└── tsconfig.json
```

## FILE CONTENTS

### docker-compose.yml
```yml
version: '3.8'

services:
  api:
    container_name: charity-api
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - '3000:3000'
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${DATABASE_URL}
      # Add other environment variables
    restart: always
    networks:
      - charity-network

networks:
  charity-network:
    driver: bridge

```

### eslint.config.mjs
```mjs
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'warn',
      '@typescript-eslint/no-unsafe-argument': 'warn'
    },
  },
);
```

### src/app.controller.ts
```ts
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

```

### src/app.module.ts
```ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PrismaModule } from './prisma/prisma.module';
import { UsersModule } from './users/users.module';
import { AuthModule } from './auth/auth.module';
import { CampaignModule } from './campaign/campaign.module';
import { CountryModule } from './country/country.module';
import { FundraiseTypeModule } from './fundraise-type/fundraise-type.module';
import { CoverModule } from './cover/cover.module';
import { ImageModule } from './image/image.module';
import { UploadModule } from './upload/upload.module';
import { CategoryModule } from './category/category.module';
import { MailerModule } from './mailer/mailer.module';
import { DonationModule } from './donation/donation.module';
import { CommentModule } from './comment/comment.module';
import { AiModule } from './ai/ai.module';
import { NotificationModule } from './notification/notification.module';
import { DashboardModule } from './dashboard/dashboard.module';
import { TopicModule } from './topic/topic.module';
import { PostModule } from './post/post.module';
import { GeminiModule } from './gemini/gemini.module';
import { ReportModule } from './report/report.module';
import { RoleModule } from './role/role.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true, // Makes config available globally
      envFilePath: '.env',
    }),
    PrismaModule,
    UsersModule,
    AuthModule,
    CampaignModule,
    FundraiseTypeModule,
    CoverModule,
    ImageModule,
    UploadModule,
    CategoryModule,
    CountryModule,
    MailerModule,
    DonationModule,
    CommentModule,
    AiModule,
    NotificationModule,
    DashboardModule,
    TopicModule,
    PostModule,
    GeminiModule,
    ReportModule,
    RoleModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

```

### src/app.service.ts
```ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

```

### src/main.ts
```ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { AllExceptionsFilter } from './common/filters/all-exceptions.filter';
import * as cookieParser from 'cookie-parser';
import { ValidationPipe } from '@nestjs/common';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());
  app.useGlobalFilters(new AllExceptionsFilter());

  app.enableCors({
    origin: [
      'http://localhost:5173',
      'http://127.0.0.1:5173',
      'http://localhost:8080',
      'http://127.0.0.1:8080',
      'http://192.168.1.26:5173',
      'http://185.200.65.252',
      'http://chain4good.io.vn',
      'https://chain4good.io.vn',
      'https://admin.chain4good.io.vn',
      // Add your production domain when deploying
    ],
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
  });

  // eslint-disable-next-line @typescript-eslint/no-unsafe-call
  app.use(cookieParser());
  await app.listen(process.env.PORT ?? 3000, '0.0.0.0'); // Listen on all network interfaces
}
void bootstrap();

```

### src/auth/auth.controller.ts
```ts
import {
  Body,
  Controller,
  Get,
  Post,
  Res,
  UseGuards,
  Req,
  UnauthorizedException,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { GetUser } from './decorators/auth.decorators';
import { JwtAuthGuard } from './guards/jwt-auth.guard';
import { LocalAuthGuard } from './guards/local-auth.guard';
import { UserRegisterDTO } from './dtos/user-register.dto';
import { Response, Request } from 'express';
import { VerifyOTPDto } from './dtos/verify-otp.dto';
import { OTPService } from 'src/otp/otp.service';

@Controller('auth')
export class AuthController {
  constructor(
    private authService: AuthService,
    private otpService: OTPService,
  ) {}

  @UseGuards(LocalAuthGuard)
  @Post('login')
  async login(
    @GetUser() userReq: { email: string; id: number },
    @Res({ passthrough: true }) res: Response,
  ) {
    try {
      const { user, access_token, refresh_token } =
        await this.authService.login(userReq);

      res.cookie('access_token', access_token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        path: '/',
        maxAge: 1 * 60 * 60 * 1000, // 1 hour
      });

      res.cookie('refresh_token', refresh_token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        path: '/',
        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
      });

      return user;
    } catch (error) {
      console.log('Login error:', error);
      throw error;
    }
  }

  @Post('refresh')
  async refresh(
    @Req() req: Request,
    @Res({ passthrough: true }) res: Response,
  ) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
    const refreshToken = req.cookies['refresh_token'];
    if (!refreshToken) {
      throw new UnauthorizedException('Refresh token not found');
    }

    const { access_token } =
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      await this.authService.refreshAccessToken(refreshToken);

    res.cookie('access_token', access_token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      path: '/',
      maxAge: 1 * 60 * 60 * 1000, // 1 hour
    });

    return { message: 'Token refreshed successfully' };
  }

  @UseGuards(JwtAuthGuard)
  @Post('logout')
  async logout(@Req() req: Request, @Res({ passthrough: true }) res: Response) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
    const refreshToken = req.cookies['refresh_token'];
    if (refreshToken) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      await this.authService.logout(refreshToken);
    }

    res.clearCookie('access_token');
    res.clearCookie('refresh_token');

    return { message: 'Logged out successfully' };
  }

  @Post('register')
  async register(@Body() userRegisterDto: UserRegisterDTO) {
    return this.authService.register(userRegisterDto);
  }

  @Post('verify-email')
  async verifyEmail(
    @Body() verifyOTPDto: VerifyOTPDto,
    @Body('userData') userData: UserRegisterDTO,
  ) {
    return this.authService.verifyEmailAndCreateUser(verifyOTPDto, userData);
  }

  @Post('resend-otp')
  async resendOTP(@Body('email') email: string) {
    await this.otpService.generateOTP(email);
    return { message: 'OTP resent successfully' };
  }

  @UseGuards(JwtAuthGuard)
  @Get('profile')
  getProfile(@GetUser() user: { id: number; email: string }) {
    const existingUser = this.authService.getMe(user.id);
    return existingUser;
  }
}

```

### src/auth/auth.module.ts
```ts
import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { UsersService } from '../users/users.service';
import { JwtModule } from '@nestjs/jwt';
import { OTPService } from '../otp/otp.service';
import { RefreshTokenService } from './refresh-token.service';
import { RoleModule } from '../role/role.module';
import { UserRepository } from 'src/users/user.repository';
import { MailerService } from 'src/mailer/mailer.service';
import { AuthController } from './auth.controller';
import { PassportModule } from '@nestjs/passport';
import { LocalStrategy } from './strategies/local.strategy';
import { JwtStrategy } from './strategies/jwt.strategy';
import { ConfigModule, ConfigService } from '@nestjs/config';

@Module({
  imports: [
    PassportModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'),
        signOptions: {
          expiresIn: configService.get<string>('JWT_EXPIRES_IN', '1h'),
        },
      }),
      inject: [ConfigService],
    }),
    RoleModule,
  ],
  providers: [
    AuthService,
    UsersService,
    OTPService,
    RefreshTokenService,
    UserRepository,
    MailerService,
    LocalStrategy,
    JwtStrategy,
  ],
  controllers: [AuthController],
  exports: [AuthService],
})
export class AuthModule {}

```

### src/auth/refresh-token.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class RefreshTokenService {
  constructor(private prisma: PrismaService) {}

  async createRefreshToken(userId: number): Promise<string> {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call
    const token = uuidv4();
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 7); // Token expires in 7 days

    await this.prisma.refreshToken.create({
      data: {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        token,
        userId,
        expiresAt,
      },
    });

    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return token;
  }

  async validateRefreshToken(token: string) {
    const refreshToken = await this.prisma.refreshToken.findUnique({
      where: { token },
      include: { user: true },
    });

    if (!refreshToken) return null;
    if (new Date() > refreshToken.expiresAt) {
      await this.prisma.refreshToken.delete({ where: { id: refreshToken.id } });
      return null;
    }

    return refreshToken.user;
  }

  async deleteRefreshToken(token: string) {
    await this.prisma.refreshToken.delete({ where: { token } });
  }
}

```

### src/auth/auth.service.ts
```ts
import {
  Injectable,
  UnauthorizedException,
  ConflictException,
  InternalServerErrorException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import * as bcrypt from 'bcrypt';
import { UsersService } from '../users/users.service';
import { UserRegisterDTO } from './dtos/user-register.dto';
import { RefreshTokenService } from './refresh-token.service';
import { VerifyOTPDto } from './dtos/verify-otp.dto';
import { OTPService } from 'src/otp/otp.service';
import { RoleService } from 'src/role/role.service';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService,
    private otpService: OTPService,
    private refreshTokenService: RefreshTokenService,
    private roleService: RoleService, // Ensure RoleService is injected
  ) {}

  async validateUser(email: string, password: string): Promise<any> {
    const user = await this.usersService.findByEmail(email);
    if (user && (await bcrypt.compare(password, user.password))) {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const { password, ...result } = user;
      return result;
    }
    return null;
  }

  async login(user: { email: string; id: number }) {
    const userRecord = await this.usersService.findByEmail(user.email);
    if (!userRecord) {
      throw new UnauthorizedException('Invalid email or password');
    }
    if (!userRecord.isVerified) {
      throw new UnauthorizedException('Email not verified');
    }
    if (!userRecord.isActive) {
      throw new UnauthorizedException('User is blocked');
    }
    const role = await this.roleService.findOneBy({ id: userRecord.roleId });
    if (!role) {
      throw new InternalServerErrorException('Role not found');
    }
    if (role.name !== 'USER' && role.name !== 'ADMIN') {
      throw new UnauthorizedException('Unauthorized role');
    }
    const payload = {
      email: user.email,
      sub: user.id,
      role: role.name,
    };
    const accessToken = this.jwtService.sign(payload);

    const refreshToken = await this.refreshTokenService.createRefreshToken(
      user.id,
    );

    return {
      user: { ...user, role: role.name },
      access_token: accessToken,
      refresh_token: refreshToken,
    };
  }

  async refreshAccessToken(refreshToken: string) {
    const user =
      await this.refreshTokenService.validateRefreshToken(refreshToken);
    if (!user) {
      throw new UnauthorizedException('Invalid refresh token');
    }
    const role = await this.roleService.findOneBy({ id: user.roleId });
    if (!role) {
      throw new InternalServerErrorException('Role not found');
    }
    if (role.name !== 'USER' && role.name !== 'ADMIN') {
      throw new UnauthorizedException('Unauthorized role');
    }
    if (!user.isActive) {
      throw new UnauthorizedException('User is blocked');
    }
    if (!user.isVerified) {
      throw new UnauthorizedException('Email not verified');
    }

    const payload = { email: user.email, sub: user.id, role: role.name };
    const accessToken = this.jwtService.sign(payload);

    return {
      access_token: accessToken,
    };
  }

  async logout(refreshToken: string) {
    await this.refreshTokenService.deleteRefreshToken(refreshToken);
  }

  async register(data: UserRegisterDTO) {
    const existingUser = await this.usersService.findByEmail(data.email);
    if (existingUser) {
      throw new ConflictException('Email already exists');
    }

    // Generate and send OTP
    await this.otpService.generateOTP(data.email);

    // Store user data temporarily (you may want to use Redis here)
    // For now, we'll hash the password but not create the user yet
    const hashedPassword = await bcrypt.hash(data.password, 10);
    return {
      message: 'OTP sent to your email',
      data: {
        ...data,
        password: hashedPassword,
      },
    };
  }

  async verifyEmailAndCreateUser(
    verifyOTPDto: VerifyOTPDto,
    userData: UserRegisterDTO,
  ) {
    const isValid = await this.otpService.verifyOTP(
      verifyOTPDto.email,
      verifyOTPDto.code,
    );

    if (!isValid) {
      throw new UnauthorizedException('Invalid or expired OTP');
    }

    const defaultRole = await this.roleService.findOneBy({ name: 'USER' });

    if (!defaultRole) {
      throw new InternalServerErrorException('Default role "USER" not found');
    }

    const user = await this.usersService.create({
      ...userData,
      isVerified: true,
      roleId: defaultRole.id,
    });

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { password: _, ...result } = user;
    return result;
  }

  async getMe(id: number) {
    const user = await this.usersService.findById(id);
    if (!user) {
      throw new Error('User not found');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { password, ...result } = user;
    return result;
  }
}

```

### src/auth/dtos/user-register.dto.ts
```ts
import {
  IsBoolean,
  IsEmail,
  IsNotEmpty,
  IsOptional,
  IsString,
} from 'class-validator';

export class UserRegisterDTO {
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @IsString()
  @IsNotEmpty()
  password: string;

  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsNotEmpty()
  address: string;

  @IsString()
  @IsOptional()
  cover?: string;

  @IsString()
  @IsOptional()
  image?: string;

  @IsString()
  @IsOptional()
  bio?: string;

  @IsBoolean()
  @IsOptional()
  isVerified?: boolean;

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;

  @IsString()
  @IsOptional()
  phoneNumber?: string;

  @IsOptional()
  roleId?: number;
}

```

### src/auth/dtos/verify-otp.dto.ts
```ts
import { IsEmail, IsString, IsNotEmpty } from 'class-validator';

export class VerifyOTPDto {
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @IsString()
  @IsNotEmpty()
  code: string;
}

```

### src/auth/dtos/user-login.dto.ts
```ts
import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class UserLoginDto {
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @IsString()
  @IsNotEmpty()
  password: string;
}

```

### src/auth/decorators/auth.decorators.ts
```ts
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { Request } from 'express';

import { Role } from '@prisma/client';

export interface UserExtract {
  id: number;
  email: string;
  role?: Role;
}

export const GetUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request: Request = ctx.switchToHttp().getRequest();
    return request.user as UserExtract;
  },
);

```

### src/auth/decorators/roles.decorator.ts
```ts
import { SetMetadata } from '@nestjs/common';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);

```

### src/auth/strategies/jwt.strategy.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/require-await */
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';
import { Request } from 'express';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromExtractors([
        (request: Request) => {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          return request?.cookies?.access_token;
        },
      ]),
      ignoreExpiration: false,
      secretOrKey: process.env.JWT_SECRET || 'secr3t',
    });
  }

  async validate(payload: { sub: string; email: string; role: string }) {
    return { id: payload.sub, email: payload.email, role: payload.role };
  }
}

```

### src/auth/strategies/local.strategy.ts
```ts
import { Strategy } from 'passport-local';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { AuthService } from '../auth.service';
import { User } from '@prisma/client';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super({
      usernameField: 'email',
      passwordField: 'password',
    });
  }

  async validate(email: string, password: string): Promise<User> {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const user: User = await this.authService.validateUser(email, password);
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }
    return user;
  }
}

```

### src/auth/guards/roles.guard.ts
```ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ROLES_KEY } from '../decorators/roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<string[]>(
      ROLES_KEY,
      [context.getHandler(), context.getClass()],
    );

    if (!requiredRoles) {
      return true;
    }
    const request = context
      .switchToHttp()
      .getRequest<{ user: { role?: string } }>();
    const { user } = request;
    return requiredRoles.some((role) => user.role === role);
  }
}

```

### src/auth/guards/jwt-auth.guard.ts
```ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}

```

### src/auth/guards/local-auth.guard.ts
```ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {}

```

### src/donation/donation.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Donation, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class DonationRepo extends BaseRepository<
  Donation,
  Prisma.DonationWhereInput,
  Prisma.DonationCreateInput,
  Prisma.DonationUpdateInput,
  Prisma.DonationOrderByWithRelationInput,
  Prisma.DonationInclude
> {
  protected readonly modelName = 'Donation' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
  findAll<T extends Prisma.DonationInclude>(params: {
    where?: Prisma.DonationWhereInput;
    include?: T;
  }) {
    return this.prisma.donation.findMany({
      where: params.where,
      include: params.include,
    }) as Promise<Prisma.DonationGetPayload<{ include: T }>[]>;
  }

  async findAllByUserId(userId: number) {
    return this.prisma.donation.findMany({
      where: { userId },
      include: {
        campaign: {
          select: {
            id: true,
            title: true,
            categoryId: true,
            countryId: true,
          },
        },
      },
      orderBy: { donatedAt: 'desc' },
    });
  }
  async aggregateDonationsByUser(userId: number) {
    return this.prisma.donation.aggregate({
      _sum: { amount: true },
      where: { userId },
    });
  }
}

```

### src/donation/donation.module.ts
```ts
import { Module, forwardRef } from '@nestjs/common';
import { CampaignModule } from '../campaign/campaign.module';
import { DonationRepo } from './donation.repository';
import { DonationService } from './donation.service';
import { DonationController } from './donation.controller';
import { CreateDonationUseCase } from './use-cases/create-donation.use-case';
import { UsersModule } from '../users/users.module';
import { NotificationModule } from '../notification/notification.module';
import { BadgeModule } from '../badge/badge.module';

@Module({
  imports: [
    forwardRef(() => CampaignModule),
    UsersModule,
    NotificationModule,
    BadgeModule,
  ],
  controllers: [DonationController],
  providers: [DonationService, DonationRepo, CreateDonationUseCase],
  exports: [DonationService],
})
export class DonationModule {}

```

### src/donation/donation.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
} from '@nestjs/common';
import { DonationService } from './donation.service';
import { CreateDonationDto } from './dto/create-donation.dto';
import { UpdateDonationDto } from './dto/update-donation.dto';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { GetUser, UserExtract } from 'src/auth/decorators/auth.decorators';

@Controller('donations')
export class DonationController {
  constructor(private readonly donationService: DonationService) {}

  @Post()
  @UseGuards(JwtAuthGuard)
  create(
    @Body() createDonationDto: CreateDonationDto & { tokenName?: string },
    @GetUser() user: UserExtract,
  ) {
    return this.donationService.create({
      ...createDonationDto,
      userId: user.id,
      tokenName: createDonationDto.tokenName,
    });
  }

  @Get()
  findAll() {
    return this.donationService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.donationService.findOne(+id);
  }

  @Patch(':id')
  update(
    @Param('id') id: string,
    @Body() updateDonationDto: UpdateDonationDto,
  ) {
    return this.donationService.update(+id, updateDonationDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.donationService.remove(+id);
  }
}

```

### src/donation/donation.service.ts
```ts
import { Inject, Injectable, forwardRef } from '@nestjs/common';
import { Prisma } from '@prisma/client';
import { BadgeService } from 'src/badge/badge.service';
import { CampaignService } from 'src/campaign/campaign.service';
import { UsersService } from 'src/users/users.service';
import { DonationRepo } from './donation.repository';
import { CreateDonationDto } from './dto/create-donation.dto';
import { UpdateDonationDto } from './dto/update-donation.dto';
import { CreateDonationUseCase } from './use-cases/create-donation.use-case';

type DonationWithUser = Prisma.DonationGetPayload<{
  include: {
    user: {
      select: {
        id: true;
        name: true;
        email: true;
      };
    };
  };
}>;

@Injectable()
export class DonationService {
  constructor(
    private readonly donationRepo: DonationRepo,
    private readonly createDonationUseCase: CreateDonationUseCase,
    @Inject(forwardRef(() => CampaignService))
    private readonly campaignService: CampaignService,
    private readonly userService: UsersService,
    private readonly badgeService: BadgeService,
  ) {}

  async create(
    createDonationDto: CreateDonationDto & {
      userId: number;
      tokenName?: string;
    },
  ) {
    const donation =
      await this.createDonationUseCase.execute(createDonationDto);

    await this.badgeService.checkDonationBadges(
      createDonationDto.userId,
      createDonationDto.amount,
      this.donationRepo,
      createDonationDto.tokenName,
    );

    return donation;
  }

  findAll() {
    return this.donationRepo.findAll({});
  }

  findOne(id: number) {
    return this.donationRepo.findOne(id);
  }

  update(id: number, updateDonationDto: UpdateDonationDto) {
    return this.donationRepo.update(id, updateDonationDto);
  }

  remove(id: number) {
    return this.donationRepo.delete(id);
  }

  async findAllUserDonationByCampaignId(
    campaignId: number,
  ): Promise<DonationWithUser[]> {
    return this.donationRepo.findAll({
      where: {
        campaignId,
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    });
  }

  async findAllByUserId(userId: number) {
    return this.donationRepo.findAllByUserId(userId);
  }
}

```

### src/donation/entities/donation.entity.ts
```ts
export class Donation {}

```

### src/donation/dto/update-donation.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateDonationDto } from './create-donation.dto';

export class UpdateDonationDto extends PartialType(CreateDonationDto) {}

```

### src/donation/dto/create-donation.dto.ts
```ts
import {
  IsInt,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
} from 'class-validator';

export class CreateDonationDto {
  @IsNumber()
  @IsNotEmpty()
  amount: number;

  @IsInt()
  @IsNotEmpty()
  campaignId: number;

  @IsInt()
  @IsOptional()
  onChainDonatedId?: number;

  @IsString()
  @IsOptional()
  txHash?: string;

  @IsString()
  @IsOptional()
  token?: string;

  @IsString()
  @IsOptional()
  address?: string;
}

```

### src/donation/use-cases/create-donation.use-case.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-argument */
import {
  Injectable,
  Inject,
  forwardRef,
  ConflictException,
} from '@nestjs/common';
import { DonationRepo } from '../donation.repository';
import { CampaignService } from '../../campaign/campaign.service';
import { CreateDonationDto } from '../dto/create-donation.dto';
import { Prisma } from '@prisma/client';

@Injectable()
export class CreateDonationUseCase {
  constructor(
    private readonly donationRepo: DonationRepo,
    @Inject(forwardRef(() => CampaignService))
    private readonly campaignService: CampaignService,
  ) {}

  async execute(
    createDonationDto: CreateDonationDto & {
      userId: number;
      tokenName?: string;
    },
  ) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { userId, campaignId, tokenName, ...rest } = createDonationDto;

    const donation = await this.donationRepo.create({
      ...rest,
      user: {
        connect: { id: userId },
      },
      campaign: {
        connect: { id: campaignId },
      },
    });

    await this.campaignService.update(campaignId, {
      totalDonated: {
        increment: rest.amount,
      },
    } as any);

    return donation;
  }
}

```

### src/comment/comment.module.ts
```ts
import { Module } from '@nestjs/common';
import { CommentService } from './comment.service';
import { CommentController } from './comment.controller';
import { CommentRepo } from './comment.repository';
import { LikeRepo } from './like.repository';
import { CampaignModule } from 'src/campaign/campaign.module';
import { NotificationModule } from 'src/notification/notification.module';
import { UsersModule } from 'src/users/users.module';

@Module({
  imports: [CampaignModule, NotificationModule, UsersModule],
  controllers: [CommentController],
  providers: [CommentService, CommentRepo, LikeRepo],
})
export class CommentModule {}

```

### src/comment/comment.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Comment, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class CommentRepo extends BaseRepository<
  Comment,
  Prisma.CommentWhereInput,
  Prisma.CommentCreateInput,
  Prisma.CommentUpdateInput,
  Prisma.CommentOrderByWithRelationInput,
  Prisma.CommentInclude
> {
  protected readonly modelName = 'Comment' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/comment/like.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Like, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class LikeRepo extends BaseRepository<
  Like,
  Prisma.LikeWhereInput,
  Prisma.LikeCreateInput,
  Prisma.LikeUpdateInput,
  Prisma.LikeOrderByWithRelationInput,
  Prisma.LikeInclude
> {
  protected readonly modelName = 'Like' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/comment/comment.controller.ts
```ts
import {
  Body,
  Controller,
  Get,
  Param,
  ParseIntPipe,
  Post,
  UseGuards,
} from '@nestjs/common';
import { CommentService } from './comment.service';
import { CreateCommentDto } from './dto/create-comment.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { GetUser } from '../auth/decorators/auth.decorators';

@Controller('comments')
export class CommentController {
  constructor(private readonly commentService: CommentService) {}

  @UseGuards(JwtAuthGuard)
  @Post()
  create(
    @Body() createCommentDto: CreateCommentDto,
    @GetUser() user: { id: number },
  ) {
    return this.commentService.create({
      ...createCommentDto,
      userId: user.id,
    });
  }

  @Get('campaign/:campaignId')
  findByCampaign(@Param('campaignId', ParseIntPipe) campaignId: number) {
    return this.commentService.findByCampaign(campaignId);
  }

  @UseGuards(JwtAuthGuard)
  @Post(':id/like')
  async toggleLike(
    @Param('id', ParseIntPipe) id: number,
    @GetUser() user: { id: number },
  ) {
    return await this.commentService.toggleLike(id, user.id);
  }
}

```

### src/comment/comment.service.ts
```ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { CampaignService } from 'src/campaign/campaign.service';
import { NotificationService } from 'src/notification/notification.service';
import { NotificationType } from 'src/notification/types/notification.types';
import { CommentRepo } from './comment.repository';
import { LikeRepo } from './like.repository';
import { CreateCommentDto } from './dto/create-comment.dto';
import { UsersService } from 'src/users/users.service';

@Injectable()
export class CommentService {
  constructor(
    private readonly commentRepo: CommentRepo,
    private readonly likeRepo: LikeRepo,
    private readonly notificationService: NotificationService,
    private readonly campaignService: CampaignService,
    private readonly userService: UsersService,
  ) {}

  async create(createCommentDto: CreateCommentDto & { userId: number }) {
    const { userId, campaignId, parentId, ...rest } = createCommentDto;

    if (parentId) {
      const parentComment = await this.commentRepo.findOne(parentId);
      if (!parentComment) {
        throw new NotFoundException('Parent comment not found');
      }
    }

    const comment = await this.commentRepo.create({
      ...rest,
      user: { connect: { id: userId } },
      campaign: { connect: { id: campaignId } },
      ...(parentId && { parent: { connect: { id: parentId } } }),
    });

    const campaign = await this.campaignService.findOne(campaignId);
    if (!campaign) throw new Error('Campaign not found');

    if (parentId) {
      const parentComment = await this.commentRepo.findOne(parentId, {
        user: true,
      });
      if (!parentComment) {
        throw new NotFoundException('Parent comment not found');
      }
      const user = await this.userService.findById(parentComment?.userId);
      if (!user) throw new Error('User not found');
      if (parentComment && parentComment.userId !== userId) {
        await this.notificationService.createAndSendNotification({
          userId: parentComment.userId,
          type: NotificationType.COMMENT_REPLY,
          content: `<p><strong>${user.name}</strong> đã trả lời bình luận của bạn</p>`,
          metadata: {
            campaignTitle: campaign.title,
            commentId: comment.id,
            campaignId,
            parentCommentId: parentId,
            replierName: comment.userId,
          },
        });
      }
    } else {
      if (campaign.userId !== userId) {
        await this.notificationService.createAndSendNotification({
          userId: campaign.userId,
          type: NotificationType.COMMENT,
          content: 'Có bình luận mới trong chiến dịch của bạn',
          metadata: {
            campaignTitle: campaign.title,
            commentId: comment.id,
            campaignId,
            commenterName: comment.userId,
          },
        });
      }
    }

    return comment;
  }

  async findByCampaign(campaignId: number) {
    return this.commentRepo.findBy(
      { campaignId },
      {
        user: {
          select: {
            id: true,
            name: true,
            image: true,
            UserBadge: {
              select: {
                badge: {
                  select: {
                    id: true,
                    name: true,
                    iconUrl: true,
                  },
                },
              },
            },
          },
        },
        replies: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                image: true,
              },
            },
            Like: {
              select: {
                userId: true,
              },
            },
            _count: {
              select: {
                Like: true,
              },
            },
          },
        },
        Like: {
          select: {
            userId: true,
          },
        },
        _count: {
          select: {
            Like: true,
          },
        },
      },
    );
  }

  async toggleLike(commentId: number, userId: number) {
    const existingLike = await this.likeRepo.findOneBy({
      userId,
      commentId,
    });

    if (existingLike) {
      await this.likeRepo.delete(existingLike.id);
      return { liked: false };
    }

    await this.likeRepo.create({
      user: { connect: { id: userId } },
      comment: { connect: { id: commentId } },
    });

    return { liked: true };
  }
}

```

### src/comment/dto/create-comment.dto.ts
```ts
import { IsNotEmpty, IsNumber, IsOptional, IsString } from 'class-validator';

export class CreateCommentDto {
  @IsString()
  @IsNotEmpty()
  content: string;

  @IsNumber()
  @IsNotEmpty()
  campaignId: number;

  @IsNumber()
  @IsOptional()
  parentId?: number;
}

```

### src/email/campaign-email.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { MailerService } from '@nestjs-modules/mailer';

@Injectable()
export class CampaignEmailService {
  constructor(private readonly mailerService: MailerService) {}

  async sendCampaignApprovalEmail(userEmail: string, campaignName: string) {
    await this.mailerService.sendMail({
      to: userEmail,
      subject: 'Campaign Approved',
      template: 'campaign-approval',
      context: {
        campaignName,
        status: 'approved',
      },
    });
  }

  async sendCampaignRejectionEmail(
    userEmail: string,
    campaignName: string,
    reason?: string,
  ) {
    await this.mailerService.sendMail({
      to: userEmail,
      subject: 'Campaign Rejected',
      template: 'campaign-rejection',
      context: {
        campaignName,
        status: 'rejected',
        reason: reason || 'No specific reason provided',
      },
    });
  }
}

```

### src/notification/notification.controller.ts
```ts
import {
  Body,
  Controller,
  Get,
  Param,
  ParseIntPipe,
  Patch,
  Post,
  Query,
  UseGuards,
} from '@nestjs/common';
import { GetUser, UserExtract } from '../auth/decorators/auth.decorators';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { NotificationService } from './notification.service';
import {
  NotificationEntity,
  NotificationResponse,
} from './types/notification.types';
import { CreateNotificationDto } from './dto/create-notification.dto';

@Controller('notifications')
@UseGuards(JwtAuthGuard)
export class NotificationController {
  constructor(private readonly notificationService: NotificationService) {}
  @Post('')
  create(@Body() createNotificationDto: CreateNotificationDto) {
    return this.notificationService.createAndSendNotification(
      createNotificationDto,
    );
  }
  @Get()
  async getUserNotifications(
    @GetUser() user: UserExtract,
    @Query('page') page: number = 1,
    @Query('limit') limit: number = 10,
  ): Promise<NotificationResponse> {
    return this.notificationService.getUserNotifications(user.id, page, limit);
  }

  @Patch(':id/read')
  async markAsRead(
    @Param('id', ParseIntPipe) id: number,
  ): Promise<NotificationEntity> {
    return this.notificationService.markAsRead(id);
  }

  @Patch('mark-all-read')
  async markAllAsRead(@GetUser() user: UserExtract) {
    return this.notificationService.markAllAsRead(user.id);
  }

  @Get('unread-count')
  async getUnreadCount(@GetUser() user: UserExtract) {
    return this.notificationService.getUnreadCount(user.id);
  }
}

```

### src/notification/notification.gateway.ts
```ts
import {
  WebSocketGateway,
  WebSocketServer,
  OnGatewayConnection,
  OnGatewayDisconnect,
  SubscribeMessage,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Injectable } from '@nestjs/common';
import { NotificationEntity } from './types/notification.types';

@Injectable()
@WebSocketGateway({
  cors: {
    origin: '*',
  },
})
export class NotificationGateway
  implements OnGatewayConnection, OnGatewayDisconnect
{
  @WebSocketServer()
  server: Server;

  private userSockets: Map<number, string[]> = new Map();

  handleConnection(client: Socket): void {
    // console.log(`Client connected: ${client.id}`);
  }

  @SubscribeMessage('join')
  handleJoinRoom(
    client: Socket,
    userId: number,
  ): { status: string; message: string } {
    this.handleUserConnection(userId, client.id);
    return { status: 'ok', message: 'Joined successfully' };
  }

  handleDisconnect(client: Socket): void {
    this.removeSocket(client.id);
  }

  private removeSocket(socketId: string): void {
    this.userSockets.forEach((sockets, userId) => {
      const index = sockets.indexOf(socketId);
      if (index !== -1) {
        sockets.splice(index, 1);
        if (sockets.length === 0) {
          this.userSockets.delete(userId);
        }
      }
    });
  }

  handleUserConnection(userId: number, socketId: string): void {
    if (!this.userSockets.has(userId)) {
      this.userSockets.set(userId, []);
    }
    const sockets = this.userSockets.get(userId);
    if (sockets && !sockets.includes(socketId)) {
      sockets.push(socketId);
    }
  }

  sendNotificationToUser(
    userId: number,
    notification: NotificationEntity,
  ): void {
    const userSocketIds = this.userSockets.get(userId);
    if (userSocketIds?.length) {
      userSocketIds.forEach((socketId) => {
        this.server.to(socketId).emit('notification', notification);
      });
    }
  }
}

```

### src/notification/notification.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Notification, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class NotificationRepository extends BaseRepository<
  Notification,
  Prisma.NotificationWhereInput,
  Prisma.NotificationCreateInput,
  Prisma.NotificationUpdateInput,
  Prisma.NotificationOrderByWithRelationInput,
  Prisma.NotificationInclude
> {
  protected readonly modelName = 'Notification' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/notification/notification.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { NotificationRepository } from './notification.repository';
import { NotificationMapper } from './mappers/notification.mapper';
import { NotificationGateway } from './notification.gateway';
import { CreateNotificationDto } from './dto/create-notification.dto';
import {
  NotificationResponse,
  NotificationEntity,
} from './types/notification.types';
import { Prisma } from '@prisma/client';

@Injectable()
export class NotificationService {
  constructor(
    private readonly notificationRepo: NotificationRepository,
    private readonly notificationGateway: NotificationGateway,
  ) {}

  async createAndSendNotification(
    createNotificationDto: CreateNotificationDto,
  ): Promise<NotificationEntity> {
    const notification = await this.notificationRepo.create({
      user: {
        connect: {
          id: createNotificationDto.userId,
        },
      },
      type: createNotificationDto.type,
      content: createNotificationDto.content,
      metadata: createNotificationDto.metadata ?? Prisma.DbNull,
      isRead: false,
    });

    const notificationEntity = NotificationMapper.toEntity(notification);

    this.notificationGateway.sendNotificationToUser(
      createNotificationDto.userId,
      notificationEntity,
    );

    return notificationEntity;
  }

  async getUserNotifications(
    userId: number,
    page: number,
    limit: number,
  ): Promise<NotificationResponse> {
    const result = await this.notificationRepo.paginate(page, limit, {
      where: { userId },
      orderBy: { createdAt: 'desc' },
    });

    return {
      data: NotificationMapper.toEntities(result.data),
      meta: result.meta,
    };
  }
  async markAsRead(id: number): Promise<NotificationEntity> {
    const updatedNotification = await this.notificationRepo.update(id, {
      isRead: true,
    });
    return NotificationMapper.toEntity(updatedNotification);
  }

  async markAllAsRead(userId: number) {
    return this.notificationRepo.updateMany({ userId }, { isRead: true });
  }

  async getUnreadCount(userId: number): Promise<number> {
    return this.notificationRepo.count({
      userId,
      isRead: false,
    });
  }
}

```

### src/notification/notification.module.ts
```ts
import { Module } from '@nestjs/common';
import { NotificationService } from './notification.service';
import { NotificationController } from './notification.controller';
import { NotificationRepository } from './notification.repository';
import { NotificationGateway } from './notification.gateway';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [NotificationController],
  providers: [NotificationService, NotificationRepository, NotificationGateway],
  exports: [NotificationService],
})
export class NotificationModule {}

```

### src/notification/types/notification.types.ts
```ts
export enum NotificationType {
  DONATION = 'DONATION',
  COMMENT_REPLY = 'COMMENT_REPLY',
  COMMENT = 'COMMENT',
  CAMPAIGN_UPDATE = 'CAMPAIGN_UPDATE',
  CAMPAIGN_STATUS = 'CAMPAIGN_STATUS',
}

export interface NotificationMetadata {
  campaignId?: number;
  donationId?: number;
  commentId?: number;
  amount?: number;
  donorName?: string;
  replierName?: string;
  status?: string;
  [key: string]: any;
}

export interface NotificationEntity {
  id: number;
  type: NotificationType;
  content: string;
  metadata: NotificationMetadata | null;
  isRead: boolean;
  createdAt: Date;
  userId: number;
}

export type NotificationResponse = {
  data: NotificationEntity[];
  meta: {
    total: number;
    page: number;
    limit: number;
  };
};

```

### src/notification/dto/update-notification.dto.ts
```ts
export class UpdateNotificationDto {}

```

### src/notification/dto/create-notification.dto.ts
```ts
import {
  IsNotEmpty,
  IsNumber,
  IsString,
  IsEnum,
  IsObject,
  IsOptional,
} from 'class-validator';
import { NotificationType } from '../types/notification.types';

export class CreateNotificationDto {
  @IsNumber()
  @IsNotEmpty()
  userId: number;

  @IsEnum(NotificationType)
  @IsNotEmpty()
  type: NotificationType;

  @IsString()
  @IsNotEmpty()
  content: string;

  @IsObject()
  @IsOptional()
  metadata?: Record<string, any>;
}

```

### src/notification/mappers/notification.mapper.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { Notification } from '@prisma/client';
import {
  NotificationEntity,
  NotificationMetadata,
  NotificationType,
} from '../types/notification.types';

export class NotificationMapper {
  static toEntity(notification: Notification): NotificationEntity {
    return {
      id: notification.id,
      type: notification.type as NotificationType,
      content: notification.content,
      metadata: notification.metadata as NotificationMetadata | null,
      isRead: notification.isRead,
      createdAt: notification.createdAt,
      userId: notification.userId,
    };
  }

  static toEntities(notifications: Notification[]): NotificationEntity[] {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    return notifications.map(this.toEntity);
  }
}

```

### src/cover/cover.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { CoverService } from './cover.service';
import { CreateCoverDto } from './dto/create-cover.dto';
import { UpdateCoverDto } from './dto/update-cover.dto';

@Controller('covers')
export class CoverController {
  constructor(private readonly coverService: CoverService) {}

  @Post()
  create(@Body() createCoverDto: CreateCoverDto) {
    return this.coverService.create(createCoverDto);
  }

  @Get()
  findAll() {
    return this.coverService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.coverService.findOne(+id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCoverDto: UpdateCoverDto) {
    return this.coverService.update(+id, updateCoverDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.coverService.remove(+id);
  }
}

```

### src/cover/cover.module.ts
```ts
import { Module } from '@nestjs/common';
import { CoverService } from './cover.service';
import { CoverController } from './cover.controller';
import { CoverRepo } from './cover.repository';

@Module({
  controllers: [CoverController],
  providers: [CoverService, CoverRepo],
})
export class CoverModule {}

```

### src/cover/cover.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { CreateCoverDto } from './dto/create-cover.dto';
import { UpdateCoverDto } from './dto/update-cover.dto';
import { CoverRepo } from './cover.repository';

@Injectable()
export class CoverService {
  constructor(private readonly coverRepo: CoverRepo) {}
  create(createCoverDto: CreateCoverDto) {
    return this.coverRepo.create(createCoverDto);
  }

  findAll() {
    return this.coverRepo.findAll();
  }

  findOne(id: number) {
    return this.coverRepo.findOne(id);
  }

  update(id: number, updateCoverDto: UpdateCoverDto) {
    return this.coverRepo.update(id, updateCoverDto);
  }

  remove(id: number) {
    return this.coverRepo.delete(id);
  }
}

```

### src/cover/cover.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Cover, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class CoverRepo extends BaseRepository<
  Cover,
  Prisma.CoverWhereInput,
  Prisma.CoverCreateInput,
  Prisma.CoverUpdateInput,
  Prisma.CoverOrderByWithRelationInput,
  Prisma.CoverInclude
> {
  protected readonly modelName = 'Cover' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/cover/entities/cover.entity.ts
```ts
export class Cover {}

```

### src/cover/dto/create-cover.dto.ts
```ts
import { IsEnum, IsNotEmpty, IsString } from 'class-validator';
import { ImageType } from '@prisma/client';

export class CreateCoverDto {
  @IsNotEmpty()
  @IsString()
  url: string;

  @IsEnum(ImageType)
  type?: ImageType;
}

```

### src/cover/dto/update-cover.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateCoverDto } from './create-cover.dto';

export class UpdateCoverDto extends PartialType(CreateCoverDto) {}

```

### src/topic/topic.module.ts
```ts
import { Module } from '@nestjs/common';
import { TopicController } from './topic.controller';
import { TopicService } from './topic.service';
import { TopicRepository } from './topic.repository';

@Module({
  controllers: [TopicController],
  providers: [TopicService, TopicRepository],
  exports: [TopicService],
})
export class TopicModule {}

```

### src/topic/topic.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { TopicRepository } from './topic.repository';
import { CreateTopicDto } from './dto/create-topic.dto';
import { UpdateTopicDto } from './dto/update-topic.dto';

@Injectable()
export class TopicService {
  constructor(private readonly topicRepo: TopicRepository) {}

  create(createTopicDto: CreateTopicDto) {
    return this.topicRepo.create(createTopicDto);
  }

  findAll() {
    return this.topicRepo.findAll({
      include: {
        _count: {
          select: {
            posts: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });
  }

  findOne(id: number) {
    return this.topicRepo.findOne(id, {
      posts: {
        where: {
          published: true,
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              image: true,
            },
          },
        },
        orderBy: {
          createdAt: 'desc',
        },
      },
      _count: {
        select: {
          posts: true,
        },
      },
    });
  }

  update(id: number, updateTopicDto: UpdateTopicDto) {
    return this.topicRepo.update(id, updateTopicDto);
  }

  remove(id: number) {
    return this.topicRepo.delete(id);
  }

  async findPopularTopics(limit: number = 5) {
    return this.topicRepo.paginate(1, limit, {
      include: {
        _count: {
          select: {
            posts: true,
          },
        },
      },
      orderBy: {
        posts: {
          _count: 'desc',
        },
      },
    });
  }

  async searchTopics(search: string) {
    return this.topicRepo.findBy({
      OR: [
        {
          name: {
            contains: search,
            mode: 'insensitive',
          },
        },
        {
          description: {
            contains: search,
            mode: 'insensitive',
          },
        },
      ],
    });
  }
}

```

### src/topic/topic.controller.ts
```ts
import {
  Body,
  Controller,
  Delete,
  Get,
  Param,
  Patch,
  Post,
  UseGuards,
} from '@nestjs/common';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { CreateTopicDto } from './dto/create-topic.dto';
import { TopicService } from './topic.service';
import { UpdateTopicDto } from './dto/update-topic.dto';
import { RolesGuard } from 'src/auth/guards/roles.guard';
import { Roles } from 'src/auth/decorators/roles.decorator';

@Controller('topics')
export class TopicController {
  constructor(private readonly topicService: TopicService) {}

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  create(@Body() createTopicDto: CreateTopicDto) {
    return this.topicService.create(createTopicDto);
  }

  @Get()
  findAll() {
    return this.topicService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.topicService.findOne(+id);
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  update(@Param('id') id: string, @Body() updateTopicDto: UpdateTopicDto) {
    return this.topicService.update(+id, updateTopicDto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  remove(@Param('id') id: string) {
    return this.topicService.remove(+id);
  }
}

```

### src/topic/topic.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from '../common/base.repository';
import { Topic, Prisma } from '@prisma/client';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class TopicRepository extends BaseRepository<
  Topic,
  Prisma.TopicWhereInput,
  Prisma.TopicCreateInput,
  Prisma.TopicUpdateInput,
  Prisma.TopicOrderByWithRelationInput,
  Prisma.TopicInclude
> {
  protected readonly modelName = 'Topic' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/topic/dto/update-topic.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateTopicDto } from './create-topic.dto';

export class UpdateTopicDto extends PartialType(CreateTopicDto) {}

```

### src/topic/dto/create-topic.dto.ts
```ts
import { IsNotEmpty, IsOptional, IsString } from 'class-validator';

export class CreateTopicDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsString()
  @IsOptional()
  icon?: string;
}

```

### src/config/redis.config.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { CacheModule } from '@nestjs/cache-manager';
import { Global, Module, OnModuleInit } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import * as redisStore from 'cache-manager-redis-store';
import { Cache } from 'cache-manager';
import { Inject } from '@nestjs/common';
import { CACHE_MANAGER } from '@nestjs/cache-manager';

@Global()
@Module({
  imports: [
    CacheModule.registerAsync({
      imports: [ConfigModule],
      // eslint-disable-next-line @typescript-eslint/require-await
      useFactory: async (configService: ConfigService) => ({
        store: redisStore,
        host: configService.get('REDIS_HOST'),
        port: configService.get('REDIS_PORT'),
        password: configService.get('REDIS_PASSWORD'),
        ttl: configService.get('REDIS_TTL'),
        max: 100,
        isGlobal: true,
      }),
      inject: [ConfigService],
    }),
  ],
  exports: [CacheModule],
})
export class RedisCacheModule implements OnModuleInit {
  constructor(
    @Inject(CACHE_MANAGER) private cacheManager: Cache,
    private configService: ConfigService,
  ) {}

  async onModuleInit() {
    try {
      // Test connection with detailed monitoring
      const testKey = 'test-connection';
      const startTime = Date.now();

      // Test write operation
      console.log('Testing Redis write operation...');
      await this.cacheManager.set(
        testKey,
        { test: true, timestamp: startTime },
        60,
      );

      // Test read operation
      console.log('Testing Redis read operation...');
      const testValue = await this.cacheManager.get(testKey);
      const latency = Date.now() - startTime;

      // Test delete operation
      console.log('Testing Redis delete operation...');
      await this.cacheManager.del(testKey);

      // Log detailed connection status
      console.log('Redis Connection Status:', {
        success: (testValue as { test: boolean })?.test === true,
        host: this.configService.get('REDIS_HOST'),
        port: this.configService.get('REDIS_PORT'),
        latency: `${latency}ms`,
        ttl: this.configService.get('REDIS_TTL'),
        maxConnections: 100,
        operations: {
          write: 'OK',
          read: !!testValue,
          delete: 'OK',
        },
        connectionDetails: {
          secured: !!this.configService.get('REDIS_PASSWORD'),
          globalCache: true,
          defaultTTL: this.configService.get('REDIS_TTL'),
        },
      });
    } catch (error) {
      console.error('Redis Connection Failed:', {
        error: error.message,
        host: this.configService.get('REDIS_HOST'),
        port: this.configService.get('REDIS_PORT'),
        timestamp: new Date().toISOString(),
        details: {
          name: error.name,
          code: error.code,
          stack: error.stack,
        },
      });
      throw error; // Prevent app start on Redis connection failure
    }
  }
}

```

### src/config/mailer.config.ts
```ts
import { MailerOptions } from '@nestjs-modules/mailer';
import { HandlebarsAdapter } from '@nestjs-modules/mailer/dist/adapters/handlebars.adapter';
import { join } from 'path';

export const mailerConfig: MailerOptions = {
  transport: {
    host: process.env.MAIL_HOST,
    port: Number(process.env.MAIL_PORT),
    secure: false, // Set to false for TLS
    requireTLS: true, // Require TLS
    auth: {
      user: process.env.MAIL_USER,
      pass: process.env.MAIL_PASSWORD,
    },
    tls: {
      ciphers: 'SSLv3',
      rejectUnauthorized: false,
    },
  },
  defaults: {
    from: '"Chain4Good" <chain4good@gmail.com>',
  },
  template: {
    dir: join(__dirname, '..', 'templates'),
    adapter: new HandlebarsAdapter(),
    options: {
      strict: true,
    },
  },
};

```

### src/dashboard/dashboard.controller.ts
```ts
import { Controller, Get, Query, UseGuards } from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { DashboardService } from './dashboard.service';
import { RolesGuard } from 'src/auth/guards/roles.guard';
import { Roles } from 'src/auth/decorators/roles.decorator';

@Controller('dashboard')
@UseGuards(JwtAuthGuard, RolesGuard)
@Roles('ADMIN')
export class DashboardController {
  constructor(private readonly dashboardService: DashboardService) {}

  @Get('stats')
  async getStats() {
    return this.dashboardService.getStats();
  }

  @Get('campaigns-stats')
  async getCampaignStats(@Query('days') days: number = 30) {
    return this.dashboardService.getCampaignStats(days);
  }

  @Get('donations-stats')
  async getDonationStats(@Query('days') days: number = 30) {
    return this.dashboardService.getDonationStats(days);
  }

  @Get('recent-activities')
  async getRecentActivities(@Query('limit') limit: number = 10) {
    return this.dashboardService.getRecentActivities(limit);
  }

  @Get('top-campaigns')
  async getTopCampaigns(@Query('limit') limit: number = 5) {
    return this.dashboardService.getTopCampaigns(limit);
  }

  @Get('user-growth')
  async getUserGrowth(@Query('days') days: number = 30) {
    return this.dashboardService.getUserGrowth(days);
  }
}

```

### src/dashboard/dashboard.module.ts
```ts
import { Module } from '@nestjs/common';
import { DashboardController } from './dashboard.controller';
import { DashboardService } from './dashboard.service';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [DashboardController],
  providers: [DashboardService],
})
export class DashboardModule {}

```

### src/dashboard/dashboard.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CampaignStatus } from '@prisma/client';

@Injectable()
export class DashboardService {
  constructor(private prisma: PrismaService) {}

  async getStats() {
    const [
      totalUsers,
      totalCampaigns,
      totalDonations,
      totalAmount,
      activeCampaigns,
    ] = await Promise.all([
      this.prisma.user.count(),
      this.prisma.campaign.count(),
      this.prisma.donation.count(),
      this.prisma.donation.aggregate({
        _sum: {
          amount: true,
        },
      }),
      this.prisma.campaign.count({
        where: {
          status: CampaignStatus.ACTIVE,
        },
      }),
    ]);

    return {
      totalUsers,
      totalCampaigns,
      totalDonations,
      totalAmount: totalAmount._sum.amount || 0,
      activeCampaigns,
    };
  }

  async getCampaignStats(days: number) {
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const campaigns = await this.prisma.campaign.groupBy({
      by: ['status'],
      where: {
        createdAt: {
          gte: startDate,
        },
      },
      _count: true,
    });

    return campaigns;
  }

  async getDonationStats(days: number) {
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const donations = await this.prisma.donation.findMany({
      where: {
        donatedAt: {
          gte: startDate,
        },
      },
      select: {
        amount: true,
        donatedAt: true,
      },
      orderBy: {
        donatedAt: 'asc',
      },
    });

    return donations;
  }

  async getRecentActivities(limit: number) {
    const activities = await this.prisma.donation.findMany({
      take: limit,
      orderBy: {
        donatedAt: 'desc',
      },
      include: {
        user: {
          select: {
            name: true,
            image: true,
          },
        },
        campaign: {
          select: {
            title: true,
          },
        },
      },
    });

    return activities;
  }

  async getTopCampaigns(limit: number) {
    return this.prisma.campaign.findMany({
      take: limit,
      orderBy: {
        totalDonated: 'desc',
      },
      include: {
        _count: {
          select: {
            donations: true,
          },
        },
        user: {
          select: {
            name: true,
          },
        },
      },
    });
  }

  async getUserGrowth(days: number) {
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const users = await this.prisma.user.groupBy({
      by: ['createdAt'],
      where: {
        createdAt: {
          gte: startDate,
        },
      },
      _count: true,
      orderBy: {
        createdAt: 'asc',
      },
    });

    return users;
  }
}

```

### src/common/base.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';
import { toCamelCase } from 'src/utils/string';

@Injectable()
export abstract class BaseRepository<
  T,
  TWhereInput,
  TCreateInput,
  TUpdateInput,
  TOrderByInput,
  TInclude,
> {
  protected abstract readonly prisma: PrismaService;
  protected abstract readonly modelName: Prisma.ModelName;

  protected get model() {
    return this.prisma[
      toCamelCase(this.modelName) as keyof PrismaService
    ] as unknown as {
      findMany: (args?: {
        where?: TWhereInput;
        orderBy?: TOrderByInput;
        skip?: number;
        take?: number;
        include?: TInclude;
      }) => Promise<T[]>;
      findUnique: (args: {
        where: { id: number };
        include?: TInclude;
      }) => Promise<T | null>;
      findFirst: (args: {
        where: TWhereInput;
        include?: TInclude;
      }) => Promise<T | null>;
      create: (args: { data: TCreateInput; include?: TInclude }) => Promise<T>;
      update: (args: {
        where: { id: number };
        data: TUpdateInput;
        include?: TInclude;
      }) => Promise<T>;
      delete: (args: { where: { id: number } }) => Promise<T>;
      count: (args?: { where?: TWhereInput }) => Promise<number>;
      updateMany: (args: {
        where: TWhereInput;
        data: TUpdateInput;
      }) => Promise<T>;
    };
  }

  async findAll(args?: {
    where?: TWhereInput;
    orderBy?: TOrderByInput;
    include?: TInclude;
  }): Promise<T[]> {
    return this.model.findMany(args);
  }

  async findOne(id: number, include?: TInclude): Promise<T | null> {
    return this.model.findUnique({
      where: { id },
      include,
    });
  }

  async findBy(where: TWhereInput, include?: TInclude): Promise<T[]> {
    return this.model.findMany({
      where,
      include,
    });
  }

  async findOneBy(where: TWhereInput, include?: TInclude): Promise<T | null> {
    return this.model.findFirst({
      where,
      include,
    });
  }

  async create(data: TCreateInput, include?: TInclude): Promise<T> {
    return this.model.create({
      data,
      include,
    });
  }

  async update(id: number, data: TUpdateInput, include?: TInclude): Promise<T> {
    return this.model.update({
      where: { id },
      data,
      include,
    });
  }

  async updateMany(where: TWhereInput, data: TUpdateInput): Promise<T> {
    return this.model.updateMany({
      where,
      data,
    });
  }

  async delete(id: number): Promise<T> {
    return this.model.delete({
      where: { id },
    });
  }

  async count(where?: TWhereInput): Promise<number> {
    return this.model.count({
      where,
    });
  }

  async paginate(
    page: number = 1,
    limit: number = 10,
    options?: {
      where?: TWhereInput;
      orderBy?: TOrderByInput;
      include?: TInclude;
    },
  ): Promise<{
    data: T[];
    meta: {
      total: number;
      page: number;
      limit: number;
    };
  }> {
    const skip = (page - 1) * limit;
    const { where, orderBy, include } = options || {};

    const [data, total] = await Promise.all([
      this.model.findMany({
        where,
        orderBy,
        skip: Number(skip),
        take: Number(limit),
        include,
      }),
      this.model.count({ where }),
    ]);

    return {
      data,
      meta: {
        total,
        page: Number(page),
        limit: Number(limit),
      },
    };
  }
}

```

### src/common/filters/all-exceptions.filter.ts
```ts
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { Response } from 'express';

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    const status =
      exception instanceof HttpException
        ? exception.getStatus()
        : HttpStatus.INTERNAL_SERVER_ERROR;

    const message =
      exception instanceof HttpException
        ? exception.getResponse()
        : typeof exception === 'object' &&
            exception !== null &&
            'message' in exception
          ? (exception as { message: string }).message
          : 'Internal server error';

    const stack =
      typeof exception === 'object' &&
      exception !== null &&
      'stack' in exception
        ? (exception as { stack: string }).stack
        : undefined;

    response.status(status).json({
      statusCode: status,
      message,
      timestamp: new Date().toISOString(),
      path: request.url,
      // Optional: send stack trace
      stack,
    });
  }
}

```

### src/country/country.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
} from '@nestjs/common';
import { CountryService } from './country.service';
import { CreateCountryDto } from './dto/create-country.dto';
import { UpdateCountryDto } from './dto/update-country.dto';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { RolesGuard } from 'src/auth/guards/roles.guard';
import { Roles } from 'src/auth/decorators/roles.decorator';

@Controller('countries')
export class CountryController {
  constructor(private readonly countryService: CountryService) {}

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  create(@Body() createCountryDto: CreateCountryDto) {
    return this.countryService.create(createCountryDto);
  }

  @Get()
  findAll() {
    return this.countryService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.countryService.findOne(+id);
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  update(@Param('id') id: string, @Body() updateCountryDto: UpdateCountryDto) {
    return this.countryService.update(+id, updateCountryDto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  remove(@Param('id') id: string) {
    return this.countryService.remove(+id);
  }
}

```

### src/country/country.module.ts
```ts
import { Module } from '@nestjs/common';
import { CountryService } from './country.service';
import { CountryController } from './country.controller';
import { CountryRepo } from './country.repository';

@Module({
  controllers: [CountryController],
  providers: [CountryService, CountryRepo],
})
export class CountryModule {}

```

### src/country/country.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { CreateCountryDto } from './dto/create-country.dto';
import { UpdateCountryDto } from './dto/update-country.dto';
import { CountryRepo } from './country.repository';

@Injectable()
export class CountryService {
  constructor(private readonly countryRepo: CountryRepo) {}
  create(createCountryDto: CreateCountryDto) {
    return this.countryRepo.create(createCountryDto);
  }

  findAll() {
    return this.countryRepo.findAll();
  }

  findOne(id: number) {
    return this.countryRepo.findOne(id);
  }

  update(id: number, updateCountryDto: UpdateCountryDto) {
    return this.countryRepo.update(id, updateCountryDto);
  }

  remove(id: number) {
    return this.countryRepo.delete(id);
  }
}

```

### src/country/country.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Country, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class CountryRepo extends BaseRepository<
  Country,
  Prisma.CountryWhereInput,
  Prisma.CountryCreateInput,
  Prisma.CountryUpdateInput,
  Prisma.CountryOrderByWithRelationInput,
  Prisma.CountryInclude
> {
  protected readonly modelName = 'Country' as Prisma.ModelName;

  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/country/entities/country.entity.ts
```ts
export class Country {}

```

### src/country/dto/create-country.dto.ts
```ts
import { IsNotEmpty, IsString } from 'class-validator';
export class CreateCountryDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsNotEmpty()
  code: string;

  @IsString()
  @IsNotEmpty()
  phoneCode: string;
}

```

### src/country/dto/update-country.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateCountryDto } from './create-country.dto';

export class UpdateCountryDto extends PartialType(CreateCountryDto) {}

```

### src/category/category.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Category, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class CategoryRepo extends BaseRepository<
  Category,
  Prisma.CategoryWhereInput,
  Prisma.CategoryCreateInput,
  Prisma.CategoryUpdateInput,
  Prisma.CategoryOrderByWithRelationInput,
  Prisma.CategoryInclude
> {
  protected readonly modelName = 'Category' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/category/category.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
} from '@nestjs/common';
import { CategoryService } from './category.service';
import { CreateCategoryDto } from './dto/create-category.dto';
import { UpdateCategoryDto } from './dto/update-category.dto';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { RolesGuard } from 'src/auth/guards/roles.guard';
import { Roles } from 'src/auth/decorators/roles.decorator';

@Controller('categories')
export class CategoryController {
  constructor(private readonly categoryService: CategoryService) {}

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  create(@Body() createCategoryDto: CreateCategoryDto) {
    return this.categoryService.create(createCategoryDto);
  }

  @Get()
  findAll() {
    return this.categoryService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.categoryService.findOne(+id);
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  update(
    @Param('id') id: string,
    @Body() updateCategoryDto: UpdateCategoryDto,
  ) {
    return this.categoryService.update(+id, updateCategoryDto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  remove(@Param('id') id: string) {
    return this.categoryService.remove(+id);
  }
}

```

### src/category/category.module.ts
```ts
import { Module } from '@nestjs/common';
import { CategoryService } from './category.service';
import { CategoryController } from './category.controller';
import { CategoryRepo } from './category.repository';

@Module({
  controllers: [CategoryController],
  providers: [CategoryService, CategoryRepo],
})
export class CategoryModule {}

```

### src/category/category.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { CreateCategoryDto } from './dto/create-category.dto';
import { UpdateCategoryDto } from './dto/update-category.dto';
import { CategoryRepo } from './category.repository';

@Injectable()
export class CategoryService {
  constructor(private readonly categoryRepo: CategoryRepo) {}

  create(createCategoryDto: CreateCategoryDto) {
    return this.categoryRepo.create(createCategoryDto);
  }

  findAll() {
    return this.categoryRepo.findAll();
  }

  findOne(id: number) {
    return this.categoryRepo.findOne(id);
  }

  update(id: number, updateCategoryDto: UpdateCategoryDto) {
    return this.categoryRepo.update(id, updateCategoryDto);
  }

  remove(id: number) {
    return this.categoryRepo.delete(id);
  }
}

```

### src/category/entities/category.entity.ts
```ts
export class Category {}

```

### src/category/dto/update-category.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateCategoryDto } from './create-category.dto';

export class UpdateCategoryDto extends PartialType(CreateCategoryDto) {}

```

### src/category/dto/create-category.dto.ts
```ts
import { IsNotEmpty, IsOptional, IsString } from 'class-validator';

export class CreateCategoryDto {
  @IsString()
  @IsNotEmpty({ message: 'Name is required' })
  name: string;

  @IsString()
  @IsOptional()
  icon?: string;

  @IsString()
  @IsOptional()
  description?: string;
}

```

### src/badge/user-badge.repository.ts
```ts
// user-badge.repository.ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { UserBadge, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class UserBadgeRepository extends BaseRepository<
  UserBadge,
  Prisma.UserBadgeWhereInput,
  Prisma.UserBadgeCreateInput,
  Prisma.UserBadgeUpdateInput,
  Prisma.UserBadgeOrderByWithRelationInput,
  Prisma.UserBadgeInclude
> {
  protected readonly modelName = 'UserBadge' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/badge/badge.module.ts
```ts
import { Module } from '@nestjs/common';
import { BadgeRulesService } from './badge-rules.service';
import { BadgeController } from './badge.controller';
import { BadgeRepository } from './badge.repository';
import { BadgeService } from './badge.service';
import { UserBadgeRepository } from './user-badge.repository';

@Module({
  imports: [],
  controllers: [BadgeController],
  providers: [
    BadgeService,
    BadgeRepository,
    UserBadgeRepository,
    BadgeRulesService,
  ],
  exports: [
    BadgeService,
    BadgeRepository,
    UserBadgeRepository,
    BadgeRulesService,
  ],
})
export class BadgeModule {}

```

### src/badge/badge-rules.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { BadgeCondition } from './interfaces/badge-condition.interface';
import { BadgeType } from './enum/badge-type.enum';
import { DonationRepo } from '../donation/donation.repository';
import { BadgeService } from './badge.service';

@Injectable()
export class BadgeRulesService {
  private readonly conditions: BadgeCondition[] = [
    {
      type: BadgeType.FIRST_DONATION,
      badgeId: 1,
      check: async (data: { userId: number; donationRepo: DonationRepo }) => {
        const donations = await data.donationRepo.findAllByUserId(data.userId);
        return donations.length === 1;
      },
    },
    {
      type: BadgeType.DONATION_MILESTONE,
      badgeId: 2,
      check: async (data: {
        userId: number;
        amount: number;
        tokenName: string;
      }) => {
        const tokenPrice = await this.getTokenPrice(data.tokenName);
        const vndAmount = data.amount * tokenPrice;
        console.log(vndAmount >= 1000000);
        // Check if the donation amount in VND is greater than or equal to 1,000,000
        return Promise.resolve(vndAmount >= 1000000);
      },
    },
    {
      type: BadgeType.REGULAR_DONOR,
      badgeId: 3,
      check: async (data: { userId: number; donationRepo: DonationRepo }) => {
        const donations = await data.donationRepo.findAllByUserId(data.userId);
        const monthlyDonations = this.countMonthlyDonations(donations);
        return monthlyDonations >= 3;
      },
    },
    {
      type: BadgeType.CAMPAIGN_CREATED,
      badgeId: 4,
      check: (data: { userId: number; campaign: any }) => {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        return Promise.resolve(data.campaign.createdBy === data.userId);
      },
    },
  ];

  private countMonthlyDonations(donations: any[]): number {
    const monthlyDonationMap = new Map<string, number>();
    donations.forEach((donation) => {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access
      const month = new Date(donation?.donatedAt).toISOString().slice(0, 7); // Extract year-month
      monthlyDonationMap.set(month, (monthlyDonationMap.get(month) || 0) + 1);
    });
    return Array.from(monthlyDonationMap.values()).filter((count) => count > 0)
      .length;
  }

  async checkAndAwardBadges(
    userId: number,
    type: BadgeType,
    data: any,
    badgeService: BadgeService,
  ) {
    const applicableConditions = this.conditions.filter((c) => c.type === type);
    for (const condition of applicableConditions) {
      const shouldAward = await condition.check(data);
      if (shouldAward) {
        await badgeService.awardBadgeToUser(userId, condition.badgeId);
      }
    }
  }
  async getTokenPrice(token: string): Promise<number> {
    try {
      const response = await fetch(
        `https://api.coingecko.com/api/v3/simple/price?ids=${token}&vs_currencies=vnd`,
      );
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      const data = await response.json();
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      if (!data[token] || !data[token].vnd) {
        throw new Error(`Token ${token} not found`);
      }
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access
      return data[token].vnd;
    } catch (error) {
      console.error(`Failed to fetch ${token} price:`, error);
      throw new Error(`Could not fetch ${token} price`);
    }
  }
}

```

### src/badge/badge.controller.ts
```ts
import { Body, Controller, Get, Post, UseGuards } from '@nestjs/common';
import { BadgeService } from './badge.service';
import { CreateBadgeDto } from './dto/create-badge.dto';
import { AuthGuard } from '@nestjs/passport';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { RolesGuard } from 'src/auth/guards/roles.guard';
import { Roles } from 'src/auth/decorators/roles.decorator';

@Controller('badges')
export class BadgeController {
  // This controller will handle badge-related endpoints
  // You can define methods here to handle requests related to badges
  // For example, you might have methods for creating, updating, deleting, and retrieving badges
  constructor(private readonly badgeService: BadgeService) {}

  @Post('')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  async create(@Body() createBadgeDto: CreateBadgeDto) {
    return this.badgeService.createBadge(createBadgeDto);
  }
}

```

### src/badge/badge.repository.ts
```ts
// badge.repository.ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Badge, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class BadgeRepository extends BaseRepository<
  Badge,
  Prisma.BadgeWhereInput,
  Prisma.BadgeCreateInput,
  Prisma.BadgeUpdateInput,
  Prisma.BadgeOrderByWithRelationInput,
  Prisma.BadgeInclude
> {
  protected readonly modelName = 'Badge' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/badge/badge.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { BadgeRepository } from './badge.repository';
import { UserBadgeRepository } from './user-badge.repository';
import { BadgeRulesService } from './badge-rules.service';
import { BadgeType } from './enum/badge-type.enum';
import { DonationRepo } from 'src/donation/donation.repository';
import { CreateBadgeDto } from './dto/create-badge.dto';

@Injectable()
export class BadgeService {
  constructor(
    private readonly badgeRepo: BadgeRepository,
    private readonly userBadgeRepo: UserBadgeRepository,
    private readonly badgeRulesService: BadgeRulesService,
  ) {}

  async getAllBadges() {
    return this.badgeRepo.findAll();
  }

  async getUserBadges(userId: number) {
    return this.userBadgeRepo.findBy({ userId }, { badge: true });
  }

  async awardBadgeToUser(userId: number, badgeId: number) {
    const existing = await this.userBadgeRepo.findBy({ userId, badgeId });
    if (existing.length > 0) return existing[0];

    return this.userBadgeRepo.create({
      user: { connect: { id: userId } },
      badge: { connect: { id: badgeId } },
    });
  }

  async createBadge(createBadgeDto: CreateBadgeDto) {
    return this.badgeRepo.create(createBadgeDto);
  }

  async checkDonationBadges(
    userId: number,
    amount: number,
    donationRepo: DonationRepo,
    tokenName?: string,
  ) {
    await this.badgeRulesService.checkAndAwardBadges(
      userId,
      BadgeType.FIRST_DONATION,
      { userId, donationRepo },
      this,
    );

    await this.badgeRulesService.checkAndAwardBadges(
      userId,
      BadgeType.DONATION_MILESTONE,
      { userId, amount, tokenName },
      this,
    );
  }

  async checkCampaignBadges(userId: number, campaign: any) {
    // Kiểm tra và trao badge cho người tạo chiến dịch
  }
}

```

### src/badge/dto/create-badge.dto.ts
```ts
import { IsEnum, IsNotEmpty, IsOptional, IsString } from 'class-validator';
import { BadgeType } from '../enum/badge-type.enum';

export class CreateBadgeDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsNotEmpty()
  description: string;

  @IsString()
  @IsOptional()
  iconUrl?: string;

  @IsEnum(BadgeType)
  type: BadgeType;
}

```

### src/badge/enum/badge-type.enum.ts
```ts
export enum BadgeType {
  FIRST_DONATION = 'FIRST_DONATION',
  DONATION_MILESTONE = 'DONATION_MILESTONE',
  CAMPAIGN_CREATED = 'CAMPAIGN_CREATED',
  CAMPAIGN_COMPLETED = 'CAMPAIGN_COMPLETED',
  REGULAR_DONOR = 'REGULAR_DONOR',
  TOP_DONOR = 'TOP_DONOR',
}

```

### src/badge/interfaces/badge-condition.interface.ts
```ts
import { BadgeType } from '../enum/badge-type.enum';

export interface BadgeCondition {
  type: BadgeType;
  check: (data: any) => Promise<boolean>;
  badgeId: number;
}

```

### src/ai/ai.module.ts
```ts
import { Module, forwardRef } from '@nestjs/common';
import { AiController } from './ai.controller';
import { AiService } from './ai.service';
import { GeminiModule } from 'src/gemini/gemini.module';
import { CampaignModule } from 'src/campaign/campaign.module';
import { UsersModule } from 'src/users/users.module';
import { DonationModule } from 'src/donation/donation.module';

@Module({
  imports: [
    GeminiModule,
    forwardRef(() => CampaignModule), // Add forwardRef here
    UsersModule,
    DonationModule,
  ],
  controllers: [AiController],
  providers: [AiService],
  exports: [AiService],
})
export class AiModule {}

```

### src/ai/ai.service.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { Injectable, Inject, forwardRef } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import OpenAI from 'openai';
import { ThankYouLetterResponse } from './types/thank-you-letter.type';
import { GeminiService } from 'src/gemini/gemini.service';
import { CampaignAnalysis } from './types/analyze-campaign.type';
import { TrustAnalysis } from './types/trust-analyze.type';
import { CampaignService } from 'src/campaign/campaign.service';
import { CampaignOptimization } from './types/campaign-optimization.type';
import { RecommendationResponse } from './types/campaign-recommendations.type';
import { UsersService } from 'src/users/users.service';
import { DonationService } from 'src/donation/donation.service';

@Injectable()
export class AiService {
  private openai: OpenAI;

  constructor(
    private configService: ConfigService,
    private geminiService: GeminiService,
    @Inject(forwardRef(() => CampaignService))
    private campaignService: CampaignService,
    private userService: UsersService,
    private donationService: DonationService,
  ) {
    this.openai = new OpenAI({
      apiKey: this.configService.get('OPENAI_API_KEY'),
    });
  }

  async analyzeCampaign(title: string, description: string) {
    const prompt = `
            Phân tích và tóm tắt chiến dịch từ thiện sau:
            Tiêu đề: ${title}
            Mô tả: ${description}
            Trả về JSON với 2 field:
            - summary: tóm tắt ngắn gọn chiến dịch
            - analysis: phân tích ngắn gọn về mức độ thuyết phục, tính nhân văn, khả năng kêu gọi.
            `;

    const response = await this.openai.chat.completions.create({
      model: 'gpt-3.5-turbo-0125',
      messages: [{ role: 'user', content: prompt }],
    });

    const content = response.choices[0].message?.content;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return JSON.parse(content || '{}');
  }

  async generateThankYouLetter(
    campaignName: string,
  ): Promise<ThankYouLetterResponse> {
    const prompt = `
      Bạn là một chuyên gia thiết kế email marketing cao cấp. Hãy tạo một email cảm ơn chuyên nghiệp với các yêu cầu sau:

      THÔNG TIN:
      - Tên chiến dịch: "${campaignName}"

      YÊU CẦU THIẾT KẾ:
      - Sử dụng HTML5 và inline CSS
      - Màu sắc: 
        + Màu chủ đạo: #16A34A (xanh lá)
        + Màu phụ: #F0FDF4 (nền nhạt)
        + Màu accent: #166534 (nhấn mạnh)
      - Font: 'Helvetica Neue', Arial, sans-serif
      - Responsive design
      - Có background pattern tinh tế
      - Thêm icon trái tim hoặc bàn tay nắm lại phù hợp

      NỘI DUNG:
      - Độ dài: 100-150 từ
      - Giọng điệu: Chân thành, ấm áp nhưng chuyên nghiệp
      - Nhấn mạnh tác động tích cực của sự đóng góp
      - Tránh klisê và từ ngữ sáo rỗng
      - Kết thúc bằng lời mời tiếp tục đồng hành

      Trả về JSON với định dạng:
      {
        "subject": "Tiêu đề email ngắn gọn, thu hút",
        "content": "HTML template với đầy đủ styling (inline CSS)"
      }
    `;

    const response = await this.openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [{ role: 'user', content: prompt }],
      response_format: { type: 'json_object' },
    });

    try {
      const content = response.choices[0].message?.content;
      if (!content) {
        throw new Error('Empty response from OpenAI');
      }

      // Clean the response string of any control characters
      // eslint-disable-next-line no-control-regex
      const cleanContent = content.replace(/[\x00-\x1F\x7F-\x9F]/g, '');

      return JSON.parse(cleanContent) as ThankYouLetterResponse;
    } catch (error) {
      console.error('Failed to parse AI response:', error);
      return {
        subject: 'Thank You for Your Support',
        content: '<p>Thank you for your generous contribution.</p>',
      };
    }
  }

  async analyzeCampaignWithGemini(
    title: string,
    description: string,
  ): Promise<CampaignAnalysis> {
    const prompt = `
      Hãy phân tích và tóm tắt chiến dịch từ thiện sau.
      Trả về kết quả dưới dạng JSON với định dạng chính xác như sau:
      {
        "summary": "tóm tắt ngắn gọn về chiến dịch",
        "analysis": "phân tích về tính thuyết phục, tính nhân văn và khả năng kêu gọi"
      }

      Thông tin chiến dịch:
      Tiêu đề: ${title}
      Mô tả: ${description}
    `;

    try {
      const result = await this.geminiService.generateContent(prompt);
      const data = JSON.parse(result);
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      return data;
    } catch (error) {
      console.error('Failed to analyze campaign with Gemini:', error);
      return {
        summary: 'Không thể phân tích chiến dịch.',
        analysis: 'Đã xảy ra lỗi trong quá trình phân tích.',
      };
    }
  }

  async analyzeCampaignTrust(campaignId: number): Promise<TrustAnalysis> {
    const campaign = await this.campaignService.findOne(campaignId);
    if (!campaign) {
      throw new Error('Campaign not found');
    }
    const prompt = `
      Đánh giá độ tin cậy và sentiment của chiến dịch:
      - Tiêu đề: ${campaign.title}
      - Mô tả: ${campaign.description}
      
      Trả về JSON:
      {
        "trustScore": number, // 0-100
        "sentiment": "positive" | "neutral" | "negative",
        "credibilityFactors": ["yếu tố 1", "yếu tố 2"],
        "riskFactors": ["rủi ro 1", "rủi ro 2"],
        "recommendations": ["đề xuất 1", "đề xuất 2"]
      }
    `;
    const result = await this.geminiService.generateContent(prompt);
    const data = JSON.parse(result);
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return data;
  }

  async optimizeCampaignContent(
    title: string,
    description: string,
  ): Promise<CampaignOptimization> {
    const prompt = ` Bạn là một chuyên gia về truyền thông xã hội và viết nội dung từ thiện. Hãy phân tích và tối ưu hóa chiến dịch dưới đây, chỉ cải thiện cách diễn đạt, từ ngữ và cấu trúc – **không rút gọn hay bỏ bất kỳ thông tin nào**.
    Chiến dịch:
    Tiêu đề: ${title}
    Mô tả: ${description}
    
    YÊU CẦU NGHIÊM NGẶT:
    - KHÔNG được tóm tắt hoặc rút gọn mô tả
    - Phải giữ nguyên toàn bộ độ dài và nội dung gốc
    - Chỉ cải thiện: ngữ pháp, cách hành văn, cách diễn đạt và bố cục
    - Mô tả sau tối ưu **phải sử dụng định dạng HTML**, gồm các thẻ <p>, <ul>, <li> khi phù hợp
    
    Trả về kết quả ở định dạng JSON (nội dung bằng tiếng Việt):
    {
      "optimizedTitle": "Tiêu đề đã cải thiện, vẫn giữ nguyên ý nghĩa gốc",
      "optimizedDescription": "<div>Mô tả được cải thiện, sử dụng HTML đầy đủ, giữ nguyên nội dung và độ dài gốc</div>",
      "keywords": ["từ khóa 1", "từ khóa 2", "từ khóa 3"],
      "suggestedImprovements": [
        "Gợi ý cải thiện cách trình bày, bố cục hoặc ngôn từ",
        "Gợi ý tăng tính cảm xúc hoặc kết nối với người đọc"
      ],
      "targetAudienceInsights": [
        "Nhận định về nhóm người có khả năng quan tâm chiến dịch",
        "Phân tích hành vi hoặc nhu cầu của đối tượng mục tiêu"
      ]
    }
    `;

    try {
      const result = await this.geminiService.generateContent(prompt);

      const parsed = JSON.parse(result);

      if (parsed.optimizedDescription.length < description.length * 0.9) {
        throw new Error('Nội dung đã bị rút gọn quá nhiều');
      }

      if (!parsed.optimizedDescription.startsWith('<')) {
        parsed.optimizedDescription = `<div>${parsed.optimizedDescription}</div>`;
      }

      return parsed as CampaignOptimization;
    } catch (error) {
      console.error('Không thể tối ưu hóa nội dung chiến dịch:', error);
      throw new Error('Tối ưu hóa chiến dịch thất bại - Vui lòng thử lại');
    }
  }

  async getPersonalizedRecommendations(
    userId: number,
  ): Promise<RecommendationResponse> {
    const user = await this.userService.findById(userId);
    const userDonations = await this.donationService.findAllByUserId(userId);

    const donationHistory = userDonations.map((d) => ({
      campaignId: d.campaignId,
      amount: d.amount,
      categoryId: d.campaign.categoryId,
      date: d.donatedAt,
    }));

    const prompt = `
      Phân tích mẫu quyên góp của người dùng và đề xuất các chiến dịch phù hợp.
      
      Thông tin người dùng:
      - Địa chỉ ví: ${user?.address || 'Chưa xác định'} // Địa chỉ ví MetaMask
      - Lịch sử giao dịch: ${JSON.stringify(donationHistory)}
      
      Xem xét các yếu tố:
      - Mẫu giao dịch blockchain trước đây
      - Tần suất và số tiền quyên góp
      - Danh mục chiến dịch mà người dùng đã ủng hộ
      - Các tương tác với smart contract
      
      Trả về đề xuất chiến dịch dưới dạng JSON:
      {
        "recommendations": [
          {
            "campaignId": số, // ID chiến dịch
            "score": số (0-100), // Điểm đánh giá độ phù hợp
            "matchingFactors": ["yếu tố phù hợp 1", "yếu tố phù hợp 2"],
            "relevanceScore": số (0-1), // Điểm liên quan
            "blockchainFactors": {
              "gasFeeEstimate": "ước tính phí gas",
              "networkCompatibility": "độ tương thích mạng",
              "contractSecurity": "độ an toàn của hợp đồng"
            }
          }
        ],
        "explanations": ["giải thích 1", "giải thích 2"] // Các giải thích cho đề xuất
      }
    `;

    try {
      const result = await this.geminiService.generateContent(prompt);
      return JSON.parse(result) as RecommendationResponse;
    } catch (error) {
      console.error('Không thể tạo đề xuất:', error);
      throw new Error('Không thể tạo đề xuất chiến dịch');
    }
  }

  async textToSpeech(campaignId: number) {
    const campaign = await this.campaignService.findOne(campaignId);
    if (!campaign) {
      throw new Error('Campaign not found');
    }
    const article = campaign.description;
    if (!article || article.length < 50) {
      throw new Error('Article content is too short for TTS');
    }
    return await this.geminiService.tts(article, campaignId);
  }
}

```

### src/ai/ai.controller.ts
```ts
import { Body, Controller, Get, Param, Post, UseGuards } from '@nestjs/common';
import { AiService } from './ai.service';
import { AnalyzeCampaignDto } from './dto/analyze-campaign.dto';
import { GetUser, UserExtract } from 'src/auth/decorators/auth.decorators';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { RolesGuard } from 'src/auth/guards/roles.guard';
import { Roles } from 'src/auth/decorators/roles.decorator';

@Controller('ai')
@UseGuards(JwtAuthGuard, RolesGuard)
@Roles('ADMIN', 'USER')
export class AiController {
  constructor(private readonly aiService: AiService) {}

  @Post('analyze-campaign')
  async analyze(@Body() dto: AnalyzeCampaignDto) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return this.aiService.analyzeCampaign(dto.title, dto.description);
  }
  @Post('analyze-campaign-gemini')
  async analyzeGemine(@Body() dto: AnalyzeCampaignDto) {
    return this.aiService.analyzeCampaignWithGemini(dto.title, dto.description);
  }

  @Get('analyze-campaign-trust/:campaignId')
  async analyzeTrust(@Param('campaignId') campaignId: number) {
    return this.aiService.analyzeCampaignTrust(+campaignId);
  }

  @Post('optimize-campaign')
  async optimize(@Body() dto: AnalyzeCampaignDto) {
    return this.aiService.optimizeCampaignContent(dto.title, dto.description);
  }

  @Get('recommendations')
  async getRecommendations(@GetUser() user: UserExtract) {
    return this.aiService.getPersonalizedRecommendations(+user.id);
  }

  @Get('tts/:campaignId')
  async textToSpeech(@Param('campaignId') campaignId: number) {
    return this.aiService.textToSpeech(+campaignId);
  }
}

```

### src/ai/types/analyze-campaign.type.ts
```ts
export interface CampaignAnalysis {
  summary: string;
  analysis: string;
}

```

### src/ai/types/campaign-optimization.type.ts
```ts
export interface CampaignOptimization {
  optimizedTitle: string;
  optimizedDescription: string;
  keywords: string[];
  suggestedImprovements: string[];
  targetAudienceInsights: string[];
}

```

### src/ai/types/campaign-recommendations.type.ts
```ts
export interface BlockchainFactors {
  gasFeeEstimate: string;
  networkCompatibility: string;
  contractSecurity: string;
}

export interface CampaignRecommendation {
  campaignId: number;
  score: number;
  matchingFactors: string[];
  relevanceScore: number;
  blockchainFactors: BlockchainFactors;
}

export interface RecommendationResponse {
  recommendations: CampaignRecommendation[];
  explanations: string[];
}

```

### src/ai/types/trust-analyze.type.ts
```ts
export interface TrustAnalysis {
  trustScore: number;
  sentiment: 'positive' | 'neutral' | 'negative';
  credibilityFactors: string[];
  riskFactors: string[];
  recommendations: string[];
}

```

### src/ai/types/thank-you-letter.type.ts
```ts
export interface ThankYouLetterResponse {
  subject: string;
  content: string;
}

```

### src/ai/dto/analyze-campaign.dto.ts
```ts
import { IsString } from 'class-validator';

export class AnalyzeCampaignDto {
  @IsString()
  title: string;

  @IsString()
  description: string;
}

```

### src/types/express.d.ts
```ts
import { UserExtract } from '../auth/decorators/auth.decorators';

declare global {
  namespace Express {
    interface Request {
      user?: UserExtract;
    }
  }
}

```

### src/prisma/prisma.module.ts
```ts
import { Module, Global } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global()
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}

```

### src/prisma/prisma.service.ts
```ts
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService
  extends PrismaClient
  implements OnModuleInit, OnModuleDestroy
{
  async onModuleInit() {
    await this.$connect();
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}

```

### src/role/role.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { BaseRepository } from 'src/common/base.repository';
import { Prisma, Role } from '@prisma/client';

@Injectable()
export class RoleRepository extends BaseRepository<
  Role,
  Prisma.RoleWhereInput,
  Prisma.RoleCreateInput,
  Prisma.RoleUpdateInput,
  Prisma.RoleOrderByWithRelationInput,
  Prisma.RoleInclude
> {
  protected readonly prisma: PrismaService;
  protected readonly modelName: Prisma.ModelName = 'Role';

  constructor(prisma: PrismaService) {
    super();
    this.prisma = prisma;
  }
}

```

### src/role/role.module.ts
```ts
import { Module } from '@nestjs/common';
import { RoleService } from './role.service';
import { RoleController } from './role.controller';
import { RoleRepository } from './role.repository';
import { PrismaModule } from 'src/prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [RoleController],
  providers: [RoleService, RoleRepository],
  exports: [RoleService],
})
export class RoleModule {}

```

### src/role/role.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
} from '@nestjs/common';
import { RoleService } from './role.service';
import { CreateRoleDto } from './dto/create-role.dto';
import { UpdateRoleDto } from './dto/update-role.dto';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { RolesGuard } from 'src/auth/guards/roles.guard';
import { Roles } from 'src/auth/decorators/roles.decorator';

@Controller('roles')
export class RoleController {
  constructor(private readonly roleService: RoleService) {}

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  create(@Body() createRoleDto: CreateRoleDto) {
    return this.roleService.create(createRoleDto);
  }

  @Get()
  findAll() {
    return this.roleService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.roleService.findOne(+id);
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  update(@Param('id') id: string, @Body() updateRoleDto: UpdateRoleDto) {
    return this.roleService.update(+id, updateRoleDto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  remove(@Param('id') id: string) {
    return this.roleService.remove(+id);
  }
}

```

### src/role/role.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { CreateRoleDto } from './dto/create-role.dto';
import { UpdateRoleDto } from './dto/update-role.dto';
import { RoleRepository } from './role.repository';
import { Prisma } from '@prisma/client';

@Injectable()
export class RoleService {
  constructor(private readonly roleRepository: RoleRepository) {}

  create(createRoleDto: CreateRoleDto) {
    return this.roleRepository.create(createRoleDto);
  }

  findAll() {
    return this.roleRepository.findAll();
  }

  findOne(id: number) {
    return this.roleRepository.findOne(id);
  }

  update(id: number, updateRoleDto: UpdateRoleDto) {
    return this.roleRepository.update(id, updateRoleDto);
  }

  remove(id: number) {
    return this.roleRepository.delete(id);
  }

  findOneBy(where: Prisma.RoleWhereInput) {
    return this.roleRepository.findOneBy(where);
  }
}

```

### src/role/dto/update-role.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateRoleDto } from './create-role.dto';

export class UpdateRoleDto extends PartialType(CreateRoleDto) {}

```

### src/role/dto/create-role.dto.ts
```ts
import { IsNotEmpty, IsOptional, IsString } from 'class-validator';

export class CreateRoleDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsOptional()
  description?: string;
}

```

### src/fundraise-type/fundraise-type.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { FundraiseType, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class FundraiseTypeRepo extends BaseRepository<
  FundraiseType,
  Prisma.FundraiseTypeWhereInput,
  Prisma.FundraiseTypeCreateInput,
  Prisma.FundraiseTypeUpdateInput,
  Prisma.FundraiseTypeOrderByWithRelationInput,
  Prisma.FundraiseTypeInclude
> {
  protected readonly modelName = 'FundraiseType' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/fundraise-type/fundraise-type.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { CreateFundraiseTypeDto } from './dto/create-fundraise-type.dto';
import { UpdateFundraiseTypeDto } from './dto/update-fundraise-type.dto';
import { FundraiseTypeRepo } from './fundraise-type.repository';

@Injectable()
export class FundraiseTypeService {
  constructor(private readonly fundraiseTypeRepo: FundraiseTypeRepo) {}

  create(createFundraiseTypeDto: CreateFundraiseTypeDto) {
    return this.fundraiseTypeRepo.create(createFundraiseTypeDto);
  }

  findAll() {
    return this.fundraiseTypeRepo.findAll();
  }

  findOne(id: number) {
    return this.fundraiseTypeRepo.findOne(id);
  }

  update(id: number, updateFundraiseTypeDto: UpdateFundraiseTypeDto) {
    return this.fundraiseTypeRepo.update(id, updateFundraiseTypeDto);
  }

  remove(id: number) {
    return this.fundraiseTypeRepo.delete(id);
  }
}

```

### src/fundraise-type/fundraise-type.module.ts
```ts
import { Module } from '@nestjs/common';
import { FundraiseTypeService } from './fundraise-type.service';
import { FundraiseTypeController } from './fundraise-type.controller';
import { FundraiseTypeRepo } from './fundraise-type.repository';

@Module({
  controllers: [FundraiseTypeController],
  providers: [FundraiseTypeService, FundraiseTypeRepo],
})
export class FundraiseTypeModule {}

```

### src/fundraise-type/fundraise-type.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  ParseIntPipe,
} from '@nestjs/common';
import { FundraiseTypeService } from './fundraise-type.service';
import { CreateFundraiseTypeDto } from './dto/create-fundraise-type.dto';
import { UpdateFundraiseTypeDto } from './dto/update-fundraise-type.dto';

@Controller('fundraise-types')
export class FundraiseTypeController {
  constructor(private readonly fundraiseTypeService: FundraiseTypeService) {}

  @Post()
  create(@Body() createFundraiseTypeDto: CreateFundraiseTypeDto) {
    return this.fundraiseTypeService.create(createFundraiseTypeDto);
  }

  @Get()
  findAll() {
    return this.fundraiseTypeService.findAll();
  }

  @Get(':id')
  findOne(@Param('id', ParseIntPipe) id: number) {
    return this.fundraiseTypeService.findOne(id);
  }

  @Patch(':id')
  update(
    @Param('id', ParseIntPipe) id: number,
    @Body() updateFundraiseTypeDto: UpdateFundraiseTypeDto,
  ) {
    return this.fundraiseTypeService.update(id, updateFundraiseTypeDto);
  }

  @Delete(':id')
  remove(@Param('id', ParseIntPipe) id: number) {
    return this.fundraiseTypeService.remove(id);
  }
}

```

### src/fundraise-type/entities/fundraise-type.entity.ts
```ts
export class FundraiseType {
  id: number;
  name: string;
  description: string;
}

```

### src/fundraise-type/dto/update-fundraise-type.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateFundraiseTypeDto } from './create-fundraise-type.dto';

export class UpdateFundraiseTypeDto extends PartialType(
  CreateFundraiseTypeDto,
) {}

```

### src/fundraise-type/dto/create-fundraise-type.dto.ts
```ts
import { IsString, IsNotEmpty } from 'class-validator';

export class CreateFundraiseTypeDto {
  @IsString()
  @IsNotEmpty()
  name: string;
  @IsString()
  @IsNotEmpty()
  description: string;
}

```

### src/utils/string.ts
```ts
export function toCamelCase(name: string | undefined) {
  if (!name) return '';
  return name.charAt(0).toLowerCase() + name.slice(1);
}

```

### src/post/post.module.ts
```ts
import { Module } from '@nestjs/common';
import { PostController } from './post.controller';
import { PostService } from './post.service';
import { PostRepository } from './post.repository';

@Module({
  controllers: [PostController],
  providers: [PostService, PostRepository],
  exports: [PostService],
})
export class PostModule {}

```

### src/post/post.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { PostRepository } from './post.repository';
import { CreatePostDto } from './dto/create-post.dto';
import { UpdatePostDto } from './dto/update-post.dto';
import { Post, Prisma } from '@prisma/client';

@Injectable()
export class PostService {
  constructor(private readonly postRepo: PostRepository) {}

  async create(
    createPostDto: CreatePostDto & { userId: number },
  ): Promise<Post> {
    const { userId, topicId, ...rest } = createPostDto;
    return this.postRepo.create({
      ...rest,
      user: { connect: { id: userId } },
      topic: { connect: { id: topicId } },
      slug: this.createSlug(rest.title),
    });
  }

  async findOneBySlug(slug: string) {
    return this.postRepo.findOneBy(
      {
        slug,
      },
      {
        topic: true,
        user: {
          select: {
            id: true,
            name: true,
            image: true,
          },
        },
      },
    );
  }

  async findAll(
    page: number = 1,
    limit: number = 10,
    search?: string,
    topicId?: number,
    published: boolean = true,
  ) {
    const where: Prisma.PostWhereInput = {
      published,
      ...(topicId && { topicId: Number(topicId) }),
      ...(search && {
        OR: [
          {
            title: {
              contains: search,
              mode: Prisma.QueryMode.insensitive,
            },
          },
          {
            content: {
              contains: search,
              mode: Prisma.QueryMode.insensitive,
            },
          },
        ],
      }),
    };

    return this.postRepo.paginate(page, limit, {
      where,
      orderBy: { createdAt: 'desc' },
      include: {
        topic: true,
        user: {
          select: {
            id: true,
            name: true,
            image: true,
          },
        },
      },
    });
  }

  findOne(id: number) {
    return this.postRepo.findOne(id, {
      topic: true,
      user: {
        select: {
          id: true,
          name: true,
          image: true,
        },
      },
    });
  }

  update(id: number, updatePostDto: UpdatePostDto) {
    const { topicId, ...rest } = updatePostDto;
    return this.postRepo.update(
      id,
      {
        ...rest,
        ...(topicId && { topic: { connect: { id: topicId } } }),
      },
      {
        topic: true,
        user: {
          select: {
            id: true,
            name: true,
            image: true,
          },
        },
      },
    );
  }

  remove(id: number) {
    return this.postRepo.delete(id);
  }

  private createSlug(title: string): string {
    return title
      .toLowerCase()
      .replace(/ /g, '-')
      .replace(/[^\w-]+/g, '')
      .replace(/--+/g, '-');
  }
}

```

### src/post/post.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from '../common/base.repository';
import { Post, Prisma } from '@prisma/client';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class PostRepository extends BaseRepository<
  Post,
  Prisma.PostWhereInput,
  Prisma.PostCreateInput,
  Prisma.PostUpdateInput,
  Prisma.PostOrderByWithRelationInput,
  Prisma.PostInclude
> {
  protected readonly modelName = 'Post' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/post/post.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  UseGuards,
} from '@nestjs/common';
import { PostService } from './post.service';
import { CreatePostDto } from './dto/create-post.dto';
import { UpdatePostDto } from './dto/update-post.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { GetUser } from '../auth/decorators/auth.decorators';
import { RolesGuard } from 'src/auth/guards/roles.guard';
import { Roles } from 'src/auth/decorators/roles.decorator';

@Controller('posts')
export class PostController {
  constructor(private readonly postService: PostService) {}

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  create(
    @Body() createPostDto: CreatePostDto,
    @GetUser() user: { id: number },
  ) {
    return this.postService.create({
      ...createPostDto,
      userId: user.id,
    });
  }

  @Get()
  findAll(
    @Query('page') page: number,
    @Query('limit') limit: number,
    @Query('search') search: string,
    @Query('topicId') topicId: number,
    @Query('published') published: boolean,
  ) {
    return this.postService.findAll(page, limit, search, topicId, published);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.postService.findOne(+id);
  }

  @Get('slug/:slug')
  findOneBySlug(@Param('slug') slug: string) {
    return this.postService.findOneBySlug(slug);
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  update(@Param('id') id: string, @Body() updatePostDto: UpdatePostDto) {
    return this.postService.update(+id, updatePostDto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  remove(@Param('id') id: string) {
    return this.postService.remove(+id);
  }
}

```

### src/post/dto/update-post.dto.ts
```ts
// filepath: src/post/dto/update-post.dto.ts
import { PartialType } from '@nestjs/mapped-types';
import { CreatePostDto } from './create-post.dto';

export class UpdatePostDto extends PartialType(CreatePostDto) {}

```

### src/post/dto/create-post.dto.ts
```ts
// filepath: src/post/dto/create-post.dto.ts
import { IsNotEmpty, IsString, IsOptional, IsBoolean } from 'class-validator';

export class CreatePostDto {
  @IsString()
  @IsNotEmpty()
  title: string;

  @IsString()
  @IsNotEmpty()
  content: string;

  @IsString()
  @IsOptional()
  thumbnail?: string;

  @IsNotEmpty()
  topicId: number;

  @IsBoolean()
  @IsOptional()
  published?: boolean;
}

```

### src/users/users.module.ts
```ts
import { Module } from '@nestjs/common';
import { UsersService } from './users.service';
import { PrismaModule } from '../prisma/prisma.module';
import { UserController } from './users.controller';
import { UserRepository } from './user.repository';
import { PrismaService } from 'src/prisma/prisma.service';

@Module({
  controllers: [UserController],
  imports: [PrismaModule],
  providers: [UsersService, UserRepository, PrismaService],
  exports: [UsersService],
})
export class UsersModule {}

```

### src/users/users.service.ts
```ts
import { ConflictException, Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Prisma, User } from '@prisma/client';
import { UserRegisterDTO } from 'src/auth/dtos/user-register.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { UserRepository } from './user.repository';

@Injectable()
export class UsersService {
  constructor(
    private prisma: PrismaService,
    private readonly userRepository: UserRepository,
  ) {}

  async findByEmail(email: string): Promise<User | null> {
    return this.prisma.user.findUnique({
      where: { email },
      include: {
        role: true, // Include role information if needed
      },
    });
  }

  async findById(id: number): Promise<User | null> {
    return this.prisma.user.findUnique({
      where: { id },
      include: {
        role: true, // Include role information if needed
        UserBadge: {
          include: {
            badge: true, // Include badge information if needed
          },
        },
      },
    });
  }

  async create(userRegisterDto: UserRegisterDTO): Promise<User> {
    const { email, password, name, address } = userRegisterDto;
    try {
      return await this.prisma.user.create({
        data: {
          email,
          password,
          name,
          address,
          roleId: 2,
        },
      });
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
          throw new ConflictException(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Unique constraint failed on the fields: (${error?.meta?.target})`,
          );
        }
      }
      throw error;
    }
  }
  async update(id: number, data: UpdateUserDto) {
    return this.prisma.user.update({
      where: { id },
      data,
    });
  }

  async findAllByRole(roleId: number) {
    return this.prisma.user.findMany({
      where: { roleId },
    });
  }

  async findAll(
    page: number,
    limit: number,
    name: string,
    email: string,
    role: string,
  ) {
    return this.userRepository.paginate(page, limit, {
      where: {
        ...(name && { name: { contains: name, mode: 'insensitive' } }),
        ...(email && { email: { contains: email, mode: 'insensitive' } }),
        ...(role && { roleId: Number(role) }),
      },
    });
  }

  async remove(id: number) {
    return this.prisma.user.update({
      where: { id },
      data: { isActive: false },
    });
  }
}

```

### src/users/user.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { User, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class UserRepository extends BaseRepository<
  User,
  Prisma.UserWhereInput,
  Prisma.UserCreateInput,
  Prisma.UserUpdateInput,
  Prisma.UserOrderByWithRelationInput,
  Prisma.UserInclude
> {
  protected readonly modelName = 'User' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/users/users.controller.ts
```ts
import {
  Body,
  Controller,
  Delete,
  Get,
  Param,
  Patch,
  Query,
  UseGuards,
} from '@nestjs/common';
import { UsersService } from './users.service';
import { UpdateUserDto } from './dto/update-user.dto';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { RolesGuard } from 'src/auth/guards/roles.guard';
import { Roles } from 'src/auth/decorators/roles.decorator';

@Controller('users')
export class UserController {
  constructor(private readonly userService: UsersService) {}

  @Get('')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  findAll(
    @Query('page') page: number,
    @Query('limit') limit: number,
    @Query('name') name: string,
    @Query('email') email: string,
    @Query('role') role: string,
  ) {
    return this.userService.findAll(page, limit, name, email, role);
  }

  @Patch(':id')
  update(@Body() updateUserDto: UpdateUserDto, @Param('id') id: string) {
    return this.userService.update(+id, updateUserDto);
  }

  @Get('role/:id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  findAllByRole(@Param('id') id: number) {
    return this.userService.findAllByRole(+id);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.userService.findById(+id);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  remove(@Param('id') id: string) {
    return this.userService.remove(+id);
  }
}

```

### src/users/dto/update-user.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { UserRegisterDTO } from 'src/auth/dtos/user-register.dto';

export class UpdateUserDto extends PartialType(UserRegisterDTO) {}

```

### src/gemini/gemini.module.ts
```ts
import { Module } from '@nestjs/common';
import { GeminiService } from './gemini.service';
import { ConfigModule } from '@nestjs/config';
import { UploadModule } from '../upload/upload.module';
import { PrismaModule } from '../prisma/prisma.module';
import { UploadService } from 'src/upload/upload.service';

@Module({
  imports: [ConfigModule, UploadModule, PrismaModule],
  providers: [GeminiService, UploadService],
  exports: [GeminiService],
})
export class GeminiModule {}

```

### src/gemini/gemini.service.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-argument */
/* eslint-disable @typescript-eslint/await-thenable */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { GoogleGenAI } from '@google/genai';
import * as wav from 'wav';
import * as path from 'path';
import * as fs from 'fs';
import { UploadService } from 'src/upload/upload.service';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class GeminiService {
  private genAI: GoogleGenerativeAI;
  private model: any;
  private googleGenAI: GoogleGenAI;
  private readonly outputDir: string;
  constructor(
    private configService: ConfigService,
    private readonly uploadService: UploadService, // Add this
    private readonly prisma: PrismaService, // Add this
  ) {
    this.genAI = new GoogleGenerativeAI(
      this.configService.get<string>('GEMINI_API_KEY') || '',
    );
    this.googleGenAI = new GoogleGenAI({
      apiKey: this.configService.get<string>('GEMINI_API_KEY') || '',
    });
    this.model = this.genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });
    this.outputDir =
      this.configService.get<string>('AUDIO_OUTPUT_DIR') || 'audio-output';
    if (!fs.existsSync(this.outputDir)) {
      fs.mkdirSync(this.outputDir, { recursive: true });
    }
  }
  async generateContent(prompt: string): Promise<string> {
    try {
      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      let textResponse = response.text();

      // Clean and parse JSON response
      try {
        // Remove markdown code blocks if present
        textResponse = textResponse.replace(/^```json\s*/, '');
        textResponse = textResponse.replace(/\s*```$/, '');

        // Remove any trailing commas in objects/arrays
        textResponse = textResponse.replace(/,(\s*[}\]])/g, '$1');

        // Clean any non-JSON content before or after
        textResponse = textResponse.replace(/^[^{[]+/, '');
        textResponse = textResponse.replace(/[^}\]]+$/, '');

        // Attempt to parse the cleaned JSON
        const jsonParsed = JSON.parse(textResponse.trim());
        return JSON.stringify(jsonParsed, null, 2);
      } catch (parseError) {
        console.warn('Failed to parse JSON response:', parseError.message);
        console.warn('Raw response:', textResponse);
        return textResponse;
      }
    } catch (error) {
      console.error('Gemini API error:', error);
      throw new Error(`Failed to generate content: ${error.message}`);
    }
  }

  async generateContentFromImage(prompt: string, imageUrl: string) {
    try {
      const model = this.genAI.getGenerativeModel({
        model: 'gemini-2.0-flash',
      });

      const response = await fetch(imageUrl);
      const imageBytes = await response.arrayBuffer();

      const result = await model.generateContent([
        prompt,
        {
          inlineData: {
            data: Buffer.from(imageBytes).toString('base64'),
            mimeType: 'image/jpeg',
          },
        },
      ]);

      const text = await result.response;
      return (
        ' Làm cho Iapetus có vẻ đồng cảm và thấu hiểu, và Despina nghe có lạc quan và tin vào tương lai tươi sáng:' +
        text.text()
      );
    } catch (error) {
      throw new Error(
        `Failed to generate content from image: ${error.message}`,
      );
    }
  }

  async tts(article: string, campaignId: number) {
    try {
      const conversation = await this.generateConversation(article);
      const response = await this.googleGenAI.models.generateContent({
        model: 'gemini-2.5-flash-preview-tts',
        contents: [{ parts: [{ text: conversation }] }],
        config: {
          responseModalities: ['AUDIO'],
          speechConfig: {
            languageCode: 'vi-VN',
            multiSpeakerVoiceConfig: {
              speakerVoiceConfigs: [
                {
                  speaker: 'Iapetus',
                  voiceConfig: {
                    prebuiltVoiceConfig: { voiceName: 'Iapetus' },
                  },
                },
                {
                  speaker: 'Despina',
                  voiceConfig: {
                    prebuiltVoiceConfig: { voiceName: 'Despina' },
                  },
                },
              ],
            },
          },
        },
      });
      const data =
        response.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
      const audioBuffer = Buffer.from(data || '', 'base64');

      // Create temporary file
      const tempFileName = path.join(
        this.outputDir,
        `output-${Date.now()}.wav`,
      );
      await this.saveWaveFile(tempFileName, audioBuffer);

      try {
        const result = await this.uploadService.uploadAudio({
          path: tempFileName,
          filename: `campaign-audio-${campaignId}-${Date.now()}.wav`,
          mimetype: 'audio/wav',
        });

        await this.prisma.campaign.update({
          where: { id: campaignId },
          data: { audio: (result as { secure_url: string }).secure_url },
        });

        fs.unlinkSync(tempFileName);

        return (result as { secure_url: string }).secure_url;
      } catch (error) {
        if (fs.existsSync(tempFileName)) {
          fs.unlinkSync(tempFileName);
        }
        throw error;
      }
    } catch (error) {
      throw new Error(`Failed to generate TTS: ${error.message}`);
    }
  }

  async generateConversation(article: string): Promise<string> {
    try {
      const prompt = `
            Hãy chuyển đổi bài báo này thành một cuộc đối thoại tự nhiên giữa hai nhân vật:
            - Iapetus (nam)
            - Despina (nữ)
            
            Yêu cầu:
            1. Giữ nguyên toàn bộ thông tin từ bài báo gốc
            2. Chuyển thành đối thoại tự nhiên, sinh động
            3. Hai nhân vật luân phiên trao đổi về các ý chính
            4. Sử dụng ngôn ngữ tiếng Việt tự nhiên, dễ hiểu
            5. Thể hiện cảm xúc và phản ứng của nhân vật
            6. Không bao gồm tên nhân vật trong lời thoại
            7. Đảm bảo rằng các câu thoại có độ dài hợp lý
            
            Định dạng đầu ra:
            Iapetus: [lời thoại]
            Despina: [lời thoại]
            
            Bài báo cần chuyển đổi:
            ${article}
            
            Lưu ý: 
            - Giữ nguyên mọi chi tiết quan trọng từ bài báo
            - Đảm bảo tính liên kết và mạch lạc trong đối thoại
            - Thể hiện tính cách riêng của từng nhân vật`;
      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      return response.text();
    } catch (error) {
      throw new Error(`Failed to generate conversation: ${error.message}`);
    }
  }

  async saveWaveFile(
    filename: string,
    pcmData: Buffer,
    channels = 1,
    rate = 24000,
    sampleWidth = 2,
  ) {
    return new Promise<void>((resolve, reject) => {
      // Create writer with proper type access
      const writer = new wav.FileWriter(filename, {
        channels,
        sampleRate: rate,
        bitDepth: sampleWidth * 8,
      });

      writer.on('finish', () => resolve());
      // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
      writer.on('error', (err) => reject(err));

      writer.write(pcmData);
      writer.end();
    });
  }
}

```

### src/gemini/interfaces/wav-config.interface.ts
```ts
export interface WavConfig {
  channels: number;
  sampleRate: number;
  bitDepth: number;
}

```

### src/otp/otp.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { MailerService } from '../mailer/mailer.service';

@Injectable()
export class OTPService {
  constructor(
    private prisma: PrismaService,
    private mailerService: MailerService,
  ) {}

  async generateOTP(email: string): Promise<string> {
    const code = Math.floor(100000 + Math.random() * 900000).toString();
    const expiresAt = new Date();
    expiresAt.setMinutes(expiresAt.getMinutes() + 15);

    await this.prisma.oTP.upsert({
      where: { email },
      update: {
        code,
        expiresAt,
        verified: false,
      },
      create: {
        email,
        code,
        expiresAt,
      },
    });
    await this.mailerService.sendMail(
      email,
      'Xác thực email của bạn',
      'verify-email',
      {
        code,
        logoUrl: 'http://chain4good.io.vn/logo.png',
        supportUrl: 'http://chain4good.io.vn/support',
        privacyUrl: 'http://chain4good.io.vn/privacy',
        termsUrl: 'http://chain4good.io.vn/terms',
        currentYear: new Date().getFullYear(),
      },
    );
    return code;
  }

  async verifyOTP(email: string, code: string): Promise<boolean> {
    const otp = await this.prisma.oTP.findUniqueOrThrow({
      where: { email },
    });

    if (!otp) return false;
    if (otp.verified) return false;
    if (otp.code !== code) return false;
    if (otp.expiresAt < new Date()) return false;

    await this.prisma.oTP.update({
      where: { email },
      data: { verified: true },
    });

    return true;
  }
}

```

### src/mailer/mailer.module.ts
```ts
import { Module } from '@nestjs/common';
import { MailerModule as NestMailerModule } from '@nestjs-modules/mailer';
import { mailerConfig } from '../config/mailer.config';
import { MailerService } from './mailer.service';

@Module({
  imports: [NestMailerModule.forRoot(mailerConfig)],
  providers: [MailerService],
  exports: [MailerService],
})
export class MailerModule {}

```

### src/mailer/mailer.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { MailerService as NestMailerService } from '@nestjs-modules/mailer';

@Injectable()
export class MailerService {
  constructor(private readonly mailerService: NestMailerService) {}

  async sendCampaignCreated(
    email: string,
    campaignName: string,
    campaignId: number,
  ) {
    await this.mailerService.sendMail({
      to: email,
      subject: 'Chiến dịch tạo ra thành công',
      template: 'campaign-created',
      context: {
        campaignName,
        campaignId,
      },
    });
  }

  async sendMail(
    email: string,
    subject: string,
    template: string,
    context: object,
  ) {
    await this.mailerService.sendMail({
      to: email,
      subject: subject,
      template: template,
      context,
    });
  }

  async sendDonationConfirmation(
    email: string,
    data: {
      campaignName: string;
      amount: number;
      donorName: string;
    },
  ) {
    await this.mailerService.sendMail({
      to: email,
      subject: 'Thank You for Your Donation',
      template: 'donation-confirmation',
      context: {
        ...data,
      },
    });
  }

  async sendCampaignStatusUpdate(
    email: string,
    data: {
      campaignName: string;
      status: string;
    },
  ) {
    await this.mailerService.sendMail({
      to: email,
      subject: 'Campaign Status Updated',
      template: 'campaign-status-update',
      context: {
        ...data,
      },
    });
  }

  async sendCustomThankYouEmail(
    email: string,
    subject: string,
    content: string,
  ) {
    await this.mailerService.sendMail({
      to: email,
      subject,
      html: content,
    });
  }

  async sendCustomEmail(email: string, subject: string, content: string) {
    await this.mailerService.sendMail({
      to: email,
      subject,
      html: content,
    });
  }

  async sendToAdminCampaignCreated(email: string, campaignName: string) {
    await this.mailerService.sendMail({
      to: email,
      subject: 'Chiến dịch mới được tạo',
      template: 'campaign-created-admin',
      context: {
        campaignName,
      },
    });
  }
}

```

### src/upload/upload.module.ts
```ts
import { Module } from '@nestjs/common';
import { UploadController } from './upload.controller';
import { UploadService } from './upload.service';
import { CloudinaryProvider } from './cloudinary.provider';
import { mkdir } from 'fs/promises';

@Module({
  controllers: [UploadController],
  providers: [
    UploadService,
    CloudinaryProvider,
    {
      provide: 'UPLOAD_INIT',
      useFactory: async () => {
        try {
          await mkdir('./uploads', { recursive: true });
        } catch (error) {
          // Ignore error if directory already exists
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          if (error.code !== 'EEXIST') {
            throw error;
          }
        }
      },
    },
  ],
})
export class UploadModule {}

```

### src/upload/cloudinary.provider.ts
```ts
import { v2 as cloudinary } from 'cloudinary';

export const CloudinaryProvider = {
  provide: 'CLOUDINARY',
  useFactory: () => {
    return cloudinary.config({
      cloud_name: process.env.CLOUDINARY_NAME,
      api_key: process.env.CLOUDINARY_API_KEY,
      api_secret: process.env.CLOUDINARY_API_SECRET,
      secure: true,
    });
  },
};

```

### src/upload/upload.service.ts
```ts
/* eslint-disable @typescript-eslint/prefer-promise-reject-errors */
import { Injectable, OnModuleInit } from '@nestjs/common';
import { v2 as cloudinary } from 'cloudinary';
import { createReadStream } from 'fs';
import { ConfigService } from '@nestjs/config';
import * as path from 'path';

@Injectable()
export class UploadService implements OnModuleInit {
  constructor(private configService: ConfigService) {}

  onModuleInit() {
    const cloudName: string | undefined = this.configService.get(
      'CLOUDINARY_CLOUD_NAME',
    );
    const apiKey: string | undefined =
      this.configService.get('CLOUDINARY_API_KEY');
    const apiSecret: string | undefined = this.configService.get(
      'CLOUDINARY_API_SECRET',
    );

    if (!cloudName || !apiKey || !apiSecret) {
      throw new Error('Missing required Cloudinary configuration');
    }

    cloudinary.config({
      cloud_name: cloudName,
      api_key: apiKey,
      api_secret: apiSecret,
    });
  }

  async uploadImage(file: Express.Multer.File) {
    return new Promise((resolve, reject) => {
      const uploadStream = cloudinary.uploader.upload_stream(
        {
          folder: 'charity',
          resource_type: 'auto',
        },
        (error, result) => {
          if (error) return reject(error);
          resolve(result);
        },
      );
      createReadStream(file.path).pipe(uploadStream);
    });
  }

  async uploadAudio(file: {
    path: string;
    filename: string;
    mimetype: string;
  }) {
    return new Promise((resolve, reject) => {
      const uploadStream = cloudinary.uploader.upload_stream(
        {
          folder: 'campaign-audio',
          resource_type: 'auto',
          public_id: path.parse(file.filename).name,
        },
        (error, result) => {
          if (error) return reject(error);
          resolve(result);
        },
      );

      createReadStream(file.path).pipe(uploadStream);
    });
  }
}

```

### src/upload/upload.controller.ts
```ts
import {
  Controller,
  Post,
  UploadedFile,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { UploadService } from './upload.service';
import { diskStorage } from 'multer';
import { unlink } from 'fs/promises';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { RolesGuard } from 'src/auth/guards/roles.guard';
import { Roles } from 'src/auth/decorators/roles.decorator';

@Controller('uploads')
export class UploadController {
  constructor(private readonly uploadService: UploadService) {}

  @Post()
  @UseInterceptors(
    FileInterceptor('file', {
      storage: diskStorage({
        destination: './uploads',
        filename: (req, file, cb) => {
          const uniqueName = `${Date.now()}-${file.originalname}`;
          cb(null, uniqueName);
        },
      }),
    }),
  )
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN', 'USER')
  async uploadFile(@UploadedFile() file: Express.Multer.File) {
    try {
      const result = await this.uploadService.uploadImage(file);

      await unlink(file.path);

      return { url: (result as { secure_url: string }).secure_url };
    } catch (error) {
      await unlink(file.path);
      throw error;
    }
  }
}

```

### src/report/report.module.ts
```ts
import { Module } from '@nestjs/common';
import { ReportService } from './report.service';
import { ReportController } from './report.controller';
import { ReportRepository } from './report.repository';

@Module({
  controllers: [ReportController],
  providers: [ReportService, ReportRepository],
})
export class ReportModule {}

```

### src/report/report.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  UseGuards,
} from '@nestjs/common';
import { ReportService } from './report.service';
import { CreateReportDto } from './dto/create-report.dto';
import { UpdateReportDto } from './dto/update-report.dto';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { RolesGuard } from 'src/auth/guards/roles.guard';
import { Roles } from 'src/auth/decorators/roles.decorator';

@Controller('reports')
export class ReportController {
  constructor(private readonly reportService: ReportService) {}

  @Post()
  create(@Body() createReportDto: CreateReportDto) {
    return this.reportService.create(createReportDto);
  }

  @Get()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  findAll(@Query('page') page: number, @Query('limit') limit: number) {
    return this.reportService.findAll(+page, +limit);
  }

  @Get(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  findOne(@Param('id') id: string) {
    return this.reportService.findOne(+id);
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  update(@Param('id') id: string, @Body() updateReportDto: UpdateReportDto) {
    return this.reportService.update(+id, updateReportDto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  remove(@Param('id') id: string) {
    return this.reportService.remove(+id);
  }
}

```

### src/report/report.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from '../common/base.repository';
import { Report, Prisma } from '@prisma/client';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class ReportRepository extends BaseRepository<
  Report,
  Prisma.ReportWhereInput,
  Prisma.ReportCreateInput,
  Prisma.ReportUpdateInput,
  Prisma.ReportOrderByWithRelationInput,
  Prisma.ReportInclude
> {
  protected readonly modelName = 'Report' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/report/report.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { CreateReportDto } from './dto/create-report.dto';
import { UpdateReportDto } from './dto/update-report.dto';
import { ReportRepository } from './report.repository';

@Injectable()
export class ReportService {
  constructor(private readonly reportRepository: ReportRepository) {}
  create(createReportDto: CreateReportDto) {
    return this.reportRepository.create({
      content: createReportDto.content,
      type: createReportDto.type,
      campaign: { connect: { id: createReportDto.campaignId } },
    });
  }

  findAll(page: number, limit: number) {
    return this.reportRepository.paginate(page, limit, {
      include: {
        campaign: true,
        user: true,
      },
    });
  }

  findOne(id: number) {
    return this.reportRepository.findOne(id);
  }

  update(id: number, updateReportDto: UpdateReportDto) {
    return this.reportRepository.update(id, updateReportDto);
  }

  remove(id: number) {
    return this.reportRepository.delete(id);
  }
}

```

### src/report/entities/report.entity.ts
```ts
export class Report {}

```

### src/report/dto/create-report.dto.ts
```ts
import { ReportType } from '@prisma/client';
import { IsEnum, IsNotEmpty, IsNumber, IsString } from 'class-validator';

export class CreateReportDto {
  @IsString()
  @IsNotEmpty()
  content: string;

  @IsEnum(ReportType)
  @IsNotEmpty()
  type: ReportType;

  @IsNumber()
  @IsNotEmpty()
  campaignId: number;
}

```

### src/report/dto/update-report.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateReportDto } from './create-report.dto';

export class UpdateReportDto extends PartialType(CreateReportDto) {}

```

### src/image/image.controller.ts
```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { ImageService } from './image.service';
import { CreateImageDto } from './dto/create-image.dto';
import { UpdateImageDto } from './dto/update-image.dto';

@Controller('image')
export class ImageController {
  constructor(private readonly imageService: ImageService) {}

  @Post()
  create(@Body() createImageDto: CreateImageDto) {
    return this.imageService.create(createImageDto);
  }

  @Get()
  findAll() {
    return this.imageService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.imageService.findOne(+id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateImageDto: UpdateImageDto) {
    return this.imageService.update(+id, updateImageDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.imageService.remove(+id);
  }
}

```

### src/image/image.module.ts
```ts
import { Module } from '@nestjs/common';
import { ImageService } from './image.service';
import { ImageController } from './image.controller';
import { ImageRepo } from './image.repository';

@Module({
  controllers: [ImageController],
  providers: [ImageService, ImageRepo],
})
export class ImageModule {}

```

### src/image/image.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Image, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class ImageRepo extends BaseRepository<
  Image,
  Prisma.ImageWhereInput,
  Prisma.ImageCreateInput,
  Prisma.ImageUpdateInput,
  Prisma.ImageOrderByWithRelationInput,
  Prisma.ImageInclude
> {
  protected readonly modelName = 'Image' as Prisma.ModelName;
  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/image/image.service.ts
```ts
import { Injectable } from '@nestjs/common';
import { CreateImageDto } from './dto/create-image.dto';
import { UpdateImageDto } from './dto/update-image.dto';
import { ImageRepo } from './image.repository';

@Injectable()
export class ImageService {
  constructor(private readonly imageRepo: ImageRepo) {}
  create(createImageDto: CreateImageDto) {
    return this.imageRepo.create(createImageDto);
  }

  findAll() {
    return this.imageRepo.findAll();
  }

  findOne(id: number) {
    return this.imageRepo.findOne(id);
  }

  update(id: number, updateImageDto: UpdateImageDto) {
    return this.imageRepo.update(id, updateImageDto);
  }

  remove(id: number) {
    return this.imageRepo.delete(id);
  }
}

```

### src/image/entities/image.entity.ts
```ts
export class Image {}

```

### src/image/dto/update-image.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateImageDto } from './create-image.dto';

export class UpdateImageDto extends PartialType(CreateImageDto) {}

```

### src/image/dto/create-image.dto.ts
```ts
import { ImageType } from '@prisma/client';
import {
  IsEnum,
  IsInt,
  IsNotEmpty,
  IsOptional,
  IsString,
  IsUrl,
} from 'class-validator';

export class CreateImageDto {
  @IsNotEmpty()
  @IsString()
  @IsUrl({}, { message: 'URL must be a valid URL' })
  url: string;

  @IsOptional()
  @IsInt({ message: 'Campaign ID must be an integer' })
  campaignId?: number;

  @IsOptional()
  @IsEnum(ImageType, { message: 'Type must be either IMAGE or VIDEO' })
  type?: ImageType;
}

```

### src/campaign/campaign.repository.ts
```ts
import { Injectable } from '@nestjs/common';
import { BaseRepository } from 'src/common/base.repository';
import { Campaign, Prisma } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class CampaignRepo extends BaseRepository<
  Campaign,
  Prisma.CampaignWhereInput,
  Prisma.CampaignCreateInput,
  Prisma.CampaignUpdateInput,
  Prisma.CampaignOrderByWithRelationInput,
  Prisma.CampaignInclude
> {
  protected readonly modelName = 'Campaign' as Prisma.ModelName;

  constructor(protected readonly prisma: PrismaService) {
    super();
  }
}

```

### src/campaign/campaign.controller.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-return */
import {
  Body,
  Controller,
  Delete,
  Get,
  Param,
  Patch,
  Post,
  Query,
  UseGuards,
} from '@nestjs/common';
import { CampaignStatus } from '@prisma/client';
import { GetUser, UserExtract } from 'src/auth/decorators/auth.decorators';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { CampaignService } from './campaign.service';
import { CreateCampaignDto } from './dto/create-campaign.dto';
import { UpdateCampaignDto } from './dto/update-campaign.dto';
import { CreateCampaignProgressDto } from './dto/create-campaign-progress.dto';
import { RolesGuard } from 'src/auth/guards/roles.guard';
import { Roles } from 'src/auth/decorators/roles.decorator';

@Controller('campaigns')
export class CampaignController {
  constructor(private readonly campaignService: CampaignService) {}

  @Post()
  @UseGuards(JwtAuthGuard)
  @Roles('USER', 'ADMIN')
  async create(
    @Body() createCampaignDto: CreateCampaignDto,
    @GetUser() user: UserExtract,
  ) {
    const campaign = await this.campaignService.create({
      ...createCampaignDto,
      userId: user.id,
      email: user.email,
    });
    return campaign;
  }

  @Get()
  findAll(
    @Query('userId') userId: number,
    @Query('email') email: string,
    @Query('status') status: CampaignStatus,
    @Query('page') page: number,
    @Query('limit') limit: number,
    @Query('search') search: string,
    @Query('sort') sort: 'asc' | 'desc',
    @Query('sortBy') sortBy: string,
    @Query('categoryId') categoryId: number,
    @Query('fundraiseTypeId') fundraiseTypeId: number,
    @Query('countryId') countryId: number,
  ) {
    return this.campaignService.findAll(
      userId,
      email,
      status,
      page,
      limit,
      search,
      sort,
      sortBy,
      categoryId,
      fundraiseTypeId,
      countryId,
    );
  }

  @Get('valid')
  async findCampaignValid(
    @Query('userId') userId: number,
    @Query('email') email: string,
    @Query('page') page: number,
    @Query('limit') limit: number,
    @Query('search') search: string,
    @Query('sort') sort: 'asc' | 'desc',
    @Query('sortBy') sortBy: string,
    @Query('categoryId') categoryId: number,
    @Query('fundraiseTypeId') fundraiseTypeId: number,
    @Query('countryId') countryId: number,
  ) {
    return this.campaignService.findAllValid(
      userId,
      email,
      page,
      limit,
      search,
      sort,
      sortBy,
      categoryId,
      fundraiseTypeId,
      countryId,
    );
  }

  @Get('my-campaigns')
  @UseGuards(JwtAuthGuard)
  @Roles('USER', 'ADMIN')
  async findMyCampaigns(
    @GetUser() user: UserExtract,
    @Query('page') page: number,
    @Query('limit') limit: number,
    @Query('status') status: CampaignStatus,
  ) {
    const campaigns = await this.campaignService.findMyCampaigns(
      user.id,
      page,
      limit,
      status,
    );

    return campaigns;
  }

  @Get('calculate-eth-goal')
  calculateEthGoal(@Query('vndAmount') vndAmount: number) {
    return this.campaignService.calculateEthGoal(vndAmount);
  }

  @Get('calculate-goal')
  calculateGoal(
    @Query('vndAmount') vndAmount: number,
    @Query('token') token: string,
  ) {
    return this.campaignService.calculateGoal(vndAmount, token);
  }

  @UseGuards(JwtAuthGuard, RolesGuard)
  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.campaignService.findOne(+id);
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN', 'USER')
  async update(
    @Param('id') id: string,
    @Body() updateCampaignDto: UpdateCampaignDto,
  ) {
    const campaign = await this.campaignService.update(+id, updateCampaignDto);
    return campaign;
  }
  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  remove(@Param('id') id: string) {
    return this.campaignService.remove(+id);
  }

  @Get(':id/donation-history')
  async getDonationHistory(
    @Param('id') id: string,
    @Query('startDate') startDate?: string,
    @Query('endDate') endDate?: string,
    @Query('groupBy') groupBy: 'day' | 'week' | 'month' = 'day',
  ) {
    return this.campaignService.getDonationHistory(
      +id,
      startDate ? new Date(startDate) : undefined,
      endDate ? new Date(endDate) : undefined,
      groupBy,
    );
  }

  @Post(':id/progress')
  @UseGuards(JwtAuthGuard)
  async addProgress(
    @Param('id') id: string,
    @Body() createProgressDto: CreateCampaignProgressDto,
  ) {
    return this.campaignService.addProgress(+id, createProgressDto);
  }

  @Get(':id/progress')
  async getProgressHistory(@Param('id') id: string) {
    return this.campaignService.getProgressHistory(+id);
  }

  @Get(':id/financial-report')
  @UseGuards(JwtAuthGuard)
  @Roles('USER', 'ADMIN')
  async getFinancialReport(@Param('id') id: string) {
    return this.campaignService.generateFinancialReport(+id);
  }
}

```

### src/campaign/campaign.service.ts
```ts
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-argument */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { Injectable, NotFoundException } from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { CampaignStatus, Prisma } from '@prisma/client';
import { AiService } from 'src/ai/ai.service';
import { DonationService } from 'src/donation/donation.service';
import { CampaignEmailService } from 'src/email/campaign-email.service';
import { PrismaService } from 'src/prisma/prisma.service';
import { MailerService } from '../mailer/mailer.service';
import { CampaignRepo } from './campaign.repository';
import { CreateCampaignDto } from './dto/create-campaign.dto';
import { UpdateCampaignDto } from './dto/update-campaign.dto';
import { CampaignCreatedEvent } from './events/campaign-created.event';
import { CreateCampaignProgressDto } from './dto/create-campaign-progress.dto';

interface CampaignWithRelations {
  id: number;
  title: string;
  description: string;
  status: string;
  name: string;
  user: {
    id: number;
    name: string;
    email: string;
  };
  category?: any;
  country?: any;
  cover?: any;
  images?: any[];
  donations?: any[];
}

@Injectable()
export class CampaignService {
  constructor(
    private readonly campaignRepo: CampaignRepo,
    private readonly mailerService: MailerService,
    private readonly aiService: AiService,
    private readonly donationService: DonationService,
    private readonly eventEmitter: EventEmitter2,
    private readonly prisma: PrismaService,
    private readonly campaignEmailService: CampaignEmailService,
  ) {}

  async create(
    createCampaignDto: CreateCampaignDto & { userId: number; email: string },
  ) {
    try {
      const {
        images,
        userId,
        categoryId,
        countryId,
        coverId,
        fundraiseTypeId,
        email,
        ...rest
      } = createCampaignDto;

      const ethGoal = await this.calculateEthGoal(rest.goal);

      const campaign = await this.campaignRepo.create(
        {
          ...rest,
          user: { connect: { id: userId } },
          category: { connect: { id: categoryId } },
          images: {
            create: images.map((url) => ({ url, type: 'IMAGE' })),
          },
          country: { connect: { id: countryId } },
          cover: { connect: { id: coverId } },
          fundraiseType: { connect: { id: fundraiseTypeId } },
          deadline: new Date(rest.deadline),
          ethGoal,
        },
        {
          user: true,
        },
      );

      this.eventEmitter.emit(
        'campaign.created',
        new CampaignCreatedEvent(campaign.title, email, campaign.id),
      );

      return campaign;
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  findAll(
    userId?: number,
    email?: string,
    status?: CampaignStatus,
    page: number = 1,
    limit: number = 10,
    search?: string,
    sort: 'asc' | 'desc' = 'desc',
    sortBy: string = 'createdAt',
    categoryId?: number,
    fundraiseTypeId?: number,
    countryId?: number,
  ) {
    const where: Prisma.CampaignWhereInput = {
      ...(userId && { userId: Number(userId) }),
      ...(email && { user: { email } }),
      ...(status && { status: status }),
      ...(categoryId && { categoryId: Number(categoryId) }),
      ...(fundraiseTypeId && { fundraiseTypeId: Number(fundraiseTypeId) }),
      ...(countryId && { countryId: Number(countryId) }),
      ...(search && {
        OR: [
          {
            title: {
              contains: search,
              mode: Prisma.QueryMode.insensitive,
            },
          },
          {
            description: {
              contains: search,
              mode: Prisma.QueryMode.insensitive,
            },
          },
        ],
      }),
    };

    const orderBy = {
      [sortBy]: sort,
    };

    return this.campaignRepo.paginate(page, limit, {
      where,
      orderBy,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            image: true,
            address: true,
          },
        },
        category: true,
        country: true,
        cover: true,
        images: true,
        fundraiseType: true,
        // donations: {}
        _count: {
          select: {
            donations: true,
          },
        },
      },
    });
  }

  findAllValid(
    userId?: number,
    email?: string,
    page: number = 1,
    limit: number = 10,
    search?: string,
    sort: 'asc' | 'desc' = 'desc',
    sortBy: string = 'createdAt',
    categoryId?: number,
    fundraiseTypeId?: number,
    countryId?: number,
  ) {
    const where: Prisma.CampaignWhereInput = {
      ...(userId && { userId: Number(userId) }),
      ...(email && { user: { email } }),
      ...{ status: { in: ['ACTIVE', 'FINISHED'] } },
      ...(categoryId && { categoryId: Number(categoryId) }),
      ...(fundraiseTypeId && { fundraiseTypeId: Number(fundraiseTypeId) }),
      ...(countryId && { countryId: Number(countryId) }),
      ...(search && {
        OR: [
          {
            title: {
              contains: search,
              mode: Prisma.QueryMode.insensitive,
            },
          },
          {
            description: {
              contains: search,
              mode: Prisma.QueryMode.insensitive,
            },
          },
        ],
      }),
    };

    const orderBy = {
      [sortBy]: sort,
    };

    return this.campaignRepo.paginate(page, limit, {
      where,
      orderBy,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            image: true,
            address: true,
          },
        },
        category: true,
        country: true,
        cover: true,
        images: true,
        fundraiseType: true,
        // donations: {}
        _count: {
          select: {
            donations: true,
          },
        },
      },
    });
  }

  findMyCampaigns(
    userId: number,
    page: number = 1,
    limit: number = 10,
    status: CampaignStatus,
  ) {
    return this.campaignRepo.paginate(page, limit, {
      where: { userId, ...(status && { status }) },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            image: true,
            address: true,
          },
        },
        category: true,
        country: true,
        cover: true,
        images: true,
        fundraiseType: true,
      },
    });
  }
  findOne(id: number) {
    return this.campaignRepo.findOne(id, {
      category: true,
      country: true,
      cover: true,
      images: true,
      user: {
        select: {
          id: true,
          name: true,
          email: true,
          image: true,
          UserBadge: {
            select: {
              badge: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  iconUrl: true,
                },
              },
            },
          },
        },
      },
      donations: {
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
              image: true,
              address: true,
            },
          },
        },
      },
    });
  }

  async update(id: number, updateCampaignDto: UpdateCampaignDto) {
    const { images, ...rest } = updateCampaignDto;

    const data: Prisma.CampaignUpdateInput = {
      ...rest,
      ...(images && images.length > 0
        ? {
            images: {
              connect: images.map((id) => ({ id: Number(id) })),
            },
          }
        : {}),
    };

    if (updateCampaignDto.status === 'FINISHED') {
      const campaign = await this.campaignRepo.findOne(id);
      if (!campaign) {
        throw new Error('Campaign not found');
      }
      const donations =
        await this.donationService.findAllUserDonationByCampaignId(id);
      if (donations.length === 0) {
        throw new Error('No donations found');
      }
      const aiContent = await this.aiService.generateThankYouLetter(
        campaign.title,
      );
      await Promise.all(
        donations.map(async (donation) => {
          if (donation.user?.name || donation.user?.email) {
            try {
              if (
                donation.user.email &&
                aiContent.subject &&
                aiContent.content
              ) {
                await this.mailerService.sendCustomThankYouEmail(
                  donation.user.email,
                  aiContent.subject,
                  aiContent.content,
                );
              }
            } catch (error) {
              console.error('Failed to generate thank you letter:', error);
            }
          }
        }),
      );
    }

    return this.campaignRepo.update(id, data);
  }

  remove(id: number) {
    return this.campaignRepo.delete(id);
  }

  async calculateEthGoal(vndAmount: number): Promise<number> {
    const ethPrice = await this.getEthPrice();
    return vndAmount / ethPrice;
  }

  async calculateGoal(vndAmount: number, token: string): Promise<number> {
    const tokenPrice = await this.getTokenPrice(token);
    return vndAmount / tokenPrice;
  }

  async getEthPrice(): Promise<number> {
    try {
      const response = await fetch(
        'https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=vnd',
      );
      const data = await response.json();

      return data.ethereum.vnd;
    } catch (error) {
      console.error('Failed to fetch ETH price:', error);
      throw new Error('Could not fetch ETH price');
    }
  }

  async getTokenPrice(token: string): Promise<number> {
    try {
      const response = await fetch(
        `https://api.coingecko.com/api/v3/simple/price?ids=${token}&vs_currencies=vnd`,
      );
      const data = await response.json();
      if (!data[token] || !data[token].vnd) {
        throw new Error(`Token ${token} not found`);
      }
      return data[token].vnd;
    } catch (error) {
      console.error(`Failed to fetch ${token} price:`, error);
      throw new Error(`Could not fetch ${token} price`);
    }
  }

  async getDonationHistory(
    campaignId: number,
    startDate?: Date,
    endDate?: Date,
    groupBy: 'day' | 'week' | 'month' = 'day',
  ) {
    let grouping;
    switch (groupBy) {
      case 'week':
        grouping = `date_trunc('week', "donatedAt")`;
        break;
      case 'month':
        grouping = `date_trunc('month', "donatedAt")`;
        break;
      default: // day
        grouping = `date_trunc('day', "donatedAt")`;
    }

    const donationHistory = await this.prisma.$queryRaw<
      { date: string; count: number; total_amount: number }[]
    >`
      SELECT 
        ${Prisma.raw(grouping)} as date,
        COUNT(*)::int as count,
        SUM(amount)::float as total_amount
      FROM "Donation"
      WHERE "campaignId" = ${campaignId}
        ${startDate ? Prisma.sql`AND "donatedAt" >= ${startDate}` : Prisma.empty}
        ${endDate ? Prisma.sql`AND "donatedAt" <= ${endDate}` : Prisma.empty}
      GROUP BY ${Prisma.raw(grouping)}
      ORDER BY ${Prisma.raw(grouping)} ASC
    `;

    // Xử lý kết quả để điền các ngày thiếu
    const result = this.fillMissingDates(
      donationHistory,
      startDate || new Date(donationHistory[0]?.date),
      endDate || new Date(),
      groupBy,
    );

    return {
      data: result,
      summary: {
        totalDonations: result.reduce((sum, item) => sum + item.count, 0),
        totalAmount: result.reduce((sum, item) => sum + item.total_amount, 0),
        averageAmount:
          result.reduce((sum, item) => sum + item.total_amount, 0) /
            result.reduce((sum, item) => sum + item.count, 0) || 0,
      },
    };
  }

  private fillMissingDates(
    data: any[],
    startDate: Date,
    endDate: Date,
    groupBy: 'day' | 'week' | 'month',
  ) {
    const result: { date: Date; count: number; total_amount: number }[] = [];
    const current = new Date(startDate);
    const dataMap = new Map(
      data.map((item) => [new Date(item.date).getTime(), item]),
    );

    while (current <= endDate) {
      const time = current.getTime();
      const existingData = dataMap.get(time);

      result.push({
        date: new Date(time),
        count: existingData?.count || 0,
        total_amount: existingData?.total_amount || 0,
      });

      switch (groupBy) {
        case 'week':
          current.setDate(current.getDate() + 7);
          break;
        case 'month':
          current.setMonth(current.getMonth() + 1);
          break;
        default: // day
          current.setDate(current.getDate() + 1);
      }
    }

    return result;
  }

  async approveCampaign(campaignId: number) {
    const campaign = (await this.findOne(
      campaignId,
    )) as unknown as CampaignWithRelations;
    if (!campaign) {
      throw new Error('Campaign not found');
    }
    if (!campaign) {
      throw new Error('Campaign not found');
    }
    campaign.status = 'APPROVED';
    await this.campaignRepo.update(campaignId, {
      status: 'APPROVED',
    });

    await this.campaignEmailService.sendCampaignApprovalEmail(
      campaign.user.email,
      campaign.name,
    );

    return campaign;
  }

  async rejectCampaign(campaignId: number, reason?: string) {
    const campaign = (await this.findOne(
      campaignId,
    )) as unknown as CampaignWithRelations;
    if (!campaign) {
      throw new Error('Campaign not found');
    }

    campaign.status = 'REJECTED';
    await this.campaignRepo.update(campaignId, {
      status: 'REJECTED',
    });

    if (!campaign.user?.email) {
      throw new Error('Campaign user email not found');
    }

    await this.campaignEmailService.sendCampaignRejectionEmail(
      campaign.user.email,
      campaign.name,
      reason,
    );

    return campaign;
  }

  async addProgress(
    campaignId: number,
    createProgressDto: CreateCampaignProgressDto,
  ) {
    const campaign = await this.findOne(campaignId);
    if (!campaign) {
      throw new NotFoundException('Campaign not found');
    }

    const progress = await this.prisma.campaignProgress.create({
      data: {
        ...createProgressDto,
        campaign: {
          connect: { id: campaignId },
        },
      },
      include: {
        campaign: {
          include: {
            user: true,
          },
        },
      },
    });

    const donors =
      await this.donationService.findAllUserDonationByCampaignId(campaignId);

    await Promise.all(
      donors.map(async (donation) => {
        if (donation.user?.email) {
          await this.mailerService.sendMail(
            donation.user.email,
            `Cập nhật mới từ chiến dịch: ${campaign.title}`,
            'campaign-progress-update',
            {
              campaignTitle: campaign.title,
              progressTitle: progress.title,
              progressDescription: progress.description,
              images: progress.images,
              documents: progress.documents,
              date: progress.createdAt,
            },
          );
        }
      }),
    );

    return progress;
  }

  async getProgressHistory(campaignId: number) {
    const progresses = await this.prisma.campaignProgress.findMany({
      where: {
        campaignId,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return progresses;
  }

  async generateFinancialReport(campaignId: number) {
    const campaign = await this.campaignRepo.findOne(campaignId);
    if (!campaign) {
      throw new NotFoundException('Campaign not found');
    }

    const donationHistory = await this.getDonationHistory(campaignId);

    return {
      campaignId: campaign.id,
      campaignTitle: campaign.title,
      totalDonatedAmount: donationHistory.summary.totalAmount,
      totalDonationsCount: donationHistory.summary.totalDonations,
      averageDonationAmount: donationHistory.summary.averageAmount,
      detailedDonationHistory: donationHistory.data,
    };
  }
}

```

### src/campaign/campaign.module.ts
```ts
import { Module, forwardRef } from '@nestjs/common';
import { EventEmitterModule } from '@nestjs/event-emitter';
import { CampaignController } from './campaign.controller';
import { CampaignService } from './campaign.service';
import { CampaignRepo } from './campaign.repository';
import { MailerModule } from '../mailer/mailer.module';
import { AiModule } from '../ai/ai.module';
import { DonationModule } from '../donation/donation.module';
import { UsersModule } from '../users/users.module';
import { CampaignCreatedListener } from './listeners/campaign-created.listener';
import { CampaignEmailService } from 'src/email/campaign-email.service';

@Module({
  imports: [
    EventEmitterModule.forRoot(),
    MailerModule,
    forwardRef(() => AiModule), // Add forwardRef here
    UsersModule,
    forwardRef(() => DonationModule),
  ],
  controllers: [CampaignController],
  providers: [
    CampaignService,
    CampaignRepo,
    CampaignCreatedListener,
    CampaignEmailService,
  ],
  exports: [CampaignService],
})
export class CampaignModule {}

```

### src/campaign/entities/campaign.entity.ts
```ts
export class Campaign {
  id: number;
  title: string;
  description?: string;
  startDate?: Date;
  endDate?: Date;
  status?: string;
}

```

### src/campaign/listeners/campaign-created.listener.ts
```ts
import { Injectable } from '@nestjs/common';
import { OnEvent } from '@nestjs/event-emitter';
import { MailerService } from '../../mailer/mailer.service';
import { UsersService } from '../../users/users.service';
import { CampaignCreatedEvent } from '../events/campaign-created.event';

@Injectable()
export class CampaignCreatedListener {
  constructor(
    private readonly mailerService: MailerService,
    private readonly userService: UsersService,
  ) {}

  @OnEvent('campaign.created', { async: true })
  async handleCampaignCreatedEvent(event: CampaignCreatedEvent) {
    try {
      await this.mailerService.sendCampaignCreated(
        event.userEmail,
        event.campaignTitle,
        event.campaignId,
      );

      const admins = await this.userService.findAllByRole(1);
      await Promise.all(
        admins.map((admin) =>
          this.mailerService.sendToAdminCampaignCreated(
            admin.email,
            event.campaignTitle,
          ),
        ),
      );
    } catch (error) {
      console.error('Failed to send campaign created emails:', error);
    }
  }
}

```

### src/campaign/events/campaign-created.event.ts
```ts
export class CampaignCreatedEvent {
  constructor(
    public readonly campaignTitle: string,
    public readonly userEmail: string,
    public readonly campaignId: number,
  ) {}
}

export class CampaignCreatedSuccessEvent {
  constructor(
    public readonly campaignTitle: string,
    public readonly userEmail: string,
    public readonly campaignId: number,
  ) {}
}

```

### src/campaign/dto/update-campaign.dto.ts
```ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateCampaignDto } from './create-campaign.dto';

export class UpdateCampaignDto extends PartialType(CreateCampaignDto) {}

```

### src/campaign/dto/create-campaign.dto.ts
```ts
// src/campaign/dto/create-campaign.dto.ts
import { CampaignStatus } from '@prisma/client';
import {
  IsArray,
  IsBoolean,
  IsDateString,
  IsEnum,
  IsInt,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
} from 'class-validator';

export class CreateCampaignDto {
  @IsString()
  @IsNotEmpty()
  title: string;

  @IsString()
  description: string;

  @IsNumber()
  @IsNotEmpty()
  goal: number;

  @IsDateString()
  @IsNotEmpty()
  deadline: string;

  @IsNumber()
  @IsOptional()
  totalDonated: number;

  @IsBoolean()
  @IsOptional()
  isClosed: boolean;

  @IsBoolean()
  @IsOptional()
  isNoLimit: boolean;

  @IsInt()
  @IsNotEmpty()
  categoryId: number;

  @IsInt()
  @IsNotEmpty()
  countryId: number;

  @IsArray()
  @IsNotEmpty()
  images: string[];

  @IsOptional()
  @IsEnum(CampaignStatus)
  status?: CampaignStatus;

  @IsInt()
  @IsNotEmpty()
  fundraiseTypeId: number;

  @IsInt()
  @IsNotEmpty()
  coverId: number;

  @IsInt()
  @IsOptional()
  chainCampaignId: number;

  @IsString()
  @IsOptional()
  txHash: string;

  @IsString()
  @IsOptional()
  creatorAddress: string;

  @IsString()
  @IsOptional()
  tokenAddress: string;

  @IsString()
  @IsOptional()
  tokenGoal: string;

  @IsString()
  @IsOptional()
  tokenSymbol: string;

  @IsInt()
  @IsOptional()
  tokenDecimals: number;
}

```

### src/campaign/dto/create-campaign-progress.dto.ts
```ts
import { IsString, IsNotEmpty, IsArray, IsOptional } from 'class-validator';

export class CreateCampaignProgressDto {
  @IsString()
  @IsNotEmpty()
  title: string;

  @IsString()
  @IsNotEmpty()
  description: string;

  @IsArray()
  @IsNotEmpty()
  images: string[];

  @IsArray()
  @IsOptional()
  documents?: string[];
}

```

### src/campaign/use-cases/create-campaign-with-images.use-case.ts
```ts
import { Injectable } from '@nestjs/common';
import { CampaignService } from '../campaign.service';
import { ImageService } from 'src/image/image.service';
import { CreateCampaignDto } from '../dto/create-campaign.dto';

@Injectable()
export class CreateCampaignWithImagesUseCase {
  constructor(
    private readonly campaignService: CampaignService,
    private readonly imageService: ImageService,
  ) {}

  async execute(dto: CreateCampaignDto) {
    // const campaign = await this.campaignService.create(dto);
    // const imageCreatePromises = dto.images.map((url) =>
    //   this.imageService.create({
    //     url,
    //     campaignId: campaign.id,
    //     type: 'IMAGE',
    //   }),
    // );
    // await Promise.all(imageCreatePromises);
    // return campaign;
  }
}

```

### test/app.e2e-spec.ts
```ts
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { App } from 'supertest/types';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication<App>;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});

```
